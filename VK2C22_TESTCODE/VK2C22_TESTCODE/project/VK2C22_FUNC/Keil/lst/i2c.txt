; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\i2c.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\i2c.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M451Series\Include -I..\..\..\Library\StdDriver\inc -I..\Bsp -I..\User -I..\lcd_driver -I..\exti_driver -I..\led_driver -I..\touch -I..\dotmatix_lcd -I..\KH -I.\RTE\_project -ID:\KEIL_STM32\Packs\ARM\CMSIS\6.1.0\CMSIS\Core\Include -D__UVISION_VERSION=541 -D_RTE_ --omf_browse=.\obj\i2c.crf ..\..\..\Library\StdDriver\src\i2c.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C_Open PROC
;;;38       */
;;;39     uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;40     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;41         uint32_t u32Div;
;;;42         uint32_t u32Pclk;
;;;43     	
;;;44         if(i2c == I2C1) 
000008  48c2              LDR      r0,|L1.788|
00000a  4284              CMP      r4,r0
00000c  d103              BNE      |L1.22|
;;;45         {
;;;46             u32Pclk = CLK_GetPCLK1Freq();
00000e  f7fffffe          BL       CLK_GetPCLK1Freq
000012  4605              MOV      r5,r0
000014  e002              B        |L1.28|
                  |L1.22|
;;;47         } 
;;;48         else
;;;49         {
;;;50             u32Pclk = CLK_GetPCLK0Freq();
000016  f7fffffe          BL       CLK_GetPCLK0Freq
00001a  4605              MOV      r5,r0
                  |L1.28|
;;;51         }
;;;52     
;;;53         u32Div = (uint32_t)(((u32Pclk * 10u) / (u32BusClock * 4u) + 5u) / 10u - 1u); /* Compute proper divider for I2C clock */
00001c  eb050085          ADD      r0,r5,r5,LSL #2
000020  0040              LSLS     r0,r0,#1
000022  00b9              LSLS     r1,r7,#2
000024  fbb0f0f1          UDIV     r0,r0,r1
000028  1d40              ADDS     r0,r0,#5
00002a  210a              MOVS     r1,#0xa
00002c  fbb0f0f1          UDIV     r0,r0,r1
000030  1e46              SUBS     r6,r0,#1
;;;54         i2c->CLKDIV = u32Div;
000032  6126              STR      r6,[r4,#0x10]
;;;55     
;;;56         /* Enable I2C */
;;;57         i2c->CTL |= I2C_CTL_I2CEN_Msk;
000034  6820              LDR      r0,[r4,#0]
000036  f0400040          ORR      r0,r0,#0x40
00003a  6020              STR      r0,[r4,#0]
;;;58     
;;;59         return (u32Pclk / ((u32Div + 1u) << 2u));
00003c  1c70              ADDS     r0,r6,#1
00003e  0080              LSLS     r0,r0,#2
000040  fbb5f0f0          UDIV     r0,r5,r0
;;;60     }
000044  e8bd81f0          POP      {r4-r8,pc}
;;;61     
                          ENDP

                  I2C_Close PROC
;;;72     
;;;73     void I2C_Close(I2C_T *i2c)
000048  49b3              LDR      r1,|L1.792|
;;;74     {
;;;75         /* Reset I2C Controller */
;;;76         if(i2c == I2C0)
00004a  4288              CMP      r0,r1
00004c  d10b              BNE      |L1.102|
;;;77         {
;;;78             SYS->IPRST1 |= SYS_IPRST1_I2C0RST_Msk;
00004e  02c1              LSLS     r1,r0,#11
000050  68c9              LDR      r1,[r1,#0xc]
000052  f4417180          ORR      r1,r1,#0x100
000056  02c2              LSLS     r2,r0,#11
000058  60d1              STR      r1,[r2,#0xc]
;;;79             SYS->IPRST1 &= ~SYS_IPRST1_I2C0RST_Msk;
00005a  02c1              LSLS     r1,r0,#11
00005c  68c9              LDR      r1,[r1,#0xc]
00005e  f4217180          BIC      r1,r1,#0x100
000062  60d1              STR      r1,[r2,#0xc]
000064  e00d              B        |L1.130|
                  |L1.102|
;;;80         }
;;;81         else if(i2c == I2C1)
000066  49ab              LDR      r1,|L1.788|
000068  4288              CMP      r0,r1
00006a  d10a              BNE      |L1.130|
;;;82         {
;;;83             SYS->IPRST1 |= SYS_IPRST1_I2C1RST_Msk;
00006c  0481              LSLS     r1,r0,#18
00006e  68c9              LDR      r1,[r1,#0xc]
000070  f4417100          ORR      r1,r1,#0x200
000074  0482              LSLS     r2,r0,#18
000076  60d1              STR      r1,[r2,#0xc]
;;;84             SYS->IPRST1 &= ~SYS_IPRST1_I2C1RST_Msk;
000078  0481              LSLS     r1,r0,#18
00007a  68c9              LDR      r1,[r1,#0xc]
00007c  f4217100          BIC      r1,r1,#0x200
000080  60d1              STR      r1,[r2,#0xc]
                  |L1.130|
;;;85         }
;;;86     
;;;87         /* Disable I2C */
;;;88         i2c->CTL &= ~I2C_CTL_I2CEN_Msk;
000082  6801              LDR      r1,[r0,#0]
000084  f0210140          BIC      r1,r1,#0x40
000088  6001              STR      r1,[r0,#0]
;;;89     }
00008a  4770              BX       lr
;;;90     
                          ENDP

                  I2C_ClearTimeoutFlag PROC
;;;100      */
;;;101    void I2C_ClearTimeoutFlag(I2C_T *i2c)
00008c  6941              LDR      r1,[r0,#0x14]
;;;102    {
;;;103        i2c->TOCTL |= I2C_TOCTL_TOIF_Msk;
00008e  f0410101          ORR      r1,r1,#1
000092  6141              STR      r1,[r0,#0x14]
;;;104    }
000094  4770              BX       lr
;;;105    
                          ENDP

                  I2C_Trigger PROC
;;;119      */
;;;120    void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack)
000096  b570              PUSH     {r4-r6,lr}
;;;121    {
000098  4604              MOV      r4,r0
00009a  9d04              LDR      r5,[sp,#0x10]
;;;122        uint32_t u32Reg = 0;
00009c  2000              MOVS     r0,#0
;;;123    
;;;124        if(u8Start)
00009e  b109              CBZ      r1,|L1.164|
;;;125            u32Reg |= I2C_CTL_STA;
0000a0  f0400020          ORR      r0,r0,#0x20
                  |L1.164|
;;;126        if(u8Stop)
0000a4  b10a              CBZ      r2,|L1.170|
;;;127            u32Reg |= I2C_CTL_STO;
0000a6  f0400010          ORR      r0,r0,#0x10
                  |L1.170|
;;;128        if(u8Si)
0000aa  b10b              CBZ      r3,|L1.176|
;;;129            u32Reg |= I2C_CTL_SI;
0000ac  f0400008          ORR      r0,r0,#8
                  |L1.176|
;;;130        if(u8Ack)
0000b0  b10d              CBZ      r5,|L1.182|
;;;131            u32Reg |= I2C_CTL_AA;
0000b2  f0400004          ORR      r0,r0,#4
                  |L1.182|
;;;132    
;;;133        i2c->CTL = (i2c->CTL & ~0x3C) | u32Reg;
0000b6  6826              LDR      r6,[r4,#0]
0000b8  f026063c          BIC      r6,r6,#0x3c
0000bc  4306              ORRS     r6,r6,r0
0000be  6026              STR      r6,[r4,#0]
;;;134    }
0000c0  bd70              POP      {r4-r6,pc}
;;;135    
                          ENDP

                  I2C_DisableInt PROC
;;;145      */
;;;146    void I2C_DisableInt(I2C_T *i2c)
0000c2  6801              LDR      r1,[r0,#0]
;;;147    {
;;;148        i2c->CTL &= ~I2C_CTL_INTEN_Msk;
0000c4  f0210180          BIC      r1,r1,#0x80
0000c8  6001              STR      r1,[r0,#0]
;;;149    }
0000ca  4770              BX       lr
;;;150    
                          ENDP

                  I2C_EnableInt PROC
;;;160      */
;;;161    void I2C_EnableInt(I2C_T *i2c)
0000cc  6801              LDR      r1,[r0,#0]
;;;162    {
;;;163        i2c->CTL |= I2C_CTL_INTEN_Msk;
0000ce  f0410180          ORR      r1,r1,#0x80
0000d2  6001              STR      r1,[r0,#0]
;;;164    }
0000d4  4770              BX       lr
;;;165    
                          ENDP

                  I2C_GetBusClockFreq PROC
;;;174     */
;;;175    uint32_t I2C_GetBusClockFreq(I2C_T *i2c)
0000d6  b570              PUSH     {r4-r6,lr}
;;;176    {
0000d8  4605              MOV      r5,r0
;;;177        uint32_t u32Divider = i2c->CLKDIV;
0000da  692e              LDR      r6,[r5,#0x10]
;;;178        uint32_t u32Pclk;
;;;179    
;;;180        if(i2c == I2C1)
0000dc  488d              LDR      r0,|L1.788|
0000de  4285              CMP      r5,r0
0000e0  d103              BNE      |L1.234|
;;;181        {
;;;182            u32Pclk = CLK_GetPCLK1Freq();    
0000e2  f7fffffe          BL       CLK_GetPCLK1Freq
0000e6  4604              MOV      r4,r0
0000e8  e002              B        |L1.240|
                  |L1.234|
;;;183        }
;;;184        else
;;;185        {
;;;186            u32Pclk = CLK_GetPCLK0Freq();
0000ea  f7fffffe          BL       CLK_GetPCLK0Freq
0000ee  4604              MOV      r4,r0
                  |L1.240|
;;;187        }
;;;188    
;;;189        return (u32Pclk / ((u32Divider + 1u) << 2u));
0000f0  1c70              ADDS     r0,r6,#1
0000f2  0080              LSLS     r0,r0,#2
0000f4  fbb4f0f0          UDIV     r0,r4,r0
;;;190    }
0000f8  bd70              POP      {r4-r6,pc}
;;;191    
                          ENDP

                  I2C_SetBusClockFreq PROC
;;;201     */
;;;202    uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock)
0000fa  e92d41f0          PUSH     {r4-r8,lr}
;;;203    {
0000fe  4605              MOV      r5,r0
000100  460f              MOV      r7,r1
;;;204        uint32_t u32Div;
;;;205        uint32_t u32Pclk;
;;;206    
;;;207        if(i2c == I2C1) 
000102  4884              LDR      r0,|L1.788|
000104  4285              CMP      r5,r0
000106  d103              BNE      |L1.272|
;;;208        {
;;;209            u32Pclk = CLK_GetPCLK1Freq();
000108  f7fffffe          BL       CLK_GetPCLK1Freq
00010c  4604              MOV      r4,r0
00010e  e002              B        |L1.278|
                  |L1.272|
;;;210        } 
;;;211        else
;;;212        {
;;;213            u32Pclk = CLK_GetPCLK0Freq();
000110  f7fffffe          BL       CLK_GetPCLK0Freq
000114  4604              MOV      r4,r0
                  |L1.278|
;;;214        }
;;;215        
;;;216        u32Div = (uint32_t)(((u32Pclk * 10u) / (u32BusClock * 4u) + 5u) / 10u - 1u); /* Compute proper divider for I2C clock */
000116  eb040084          ADD      r0,r4,r4,LSL #2
00011a  0040              LSLS     r0,r0,#1
00011c  00b9              LSLS     r1,r7,#2
00011e  fbb0f0f1          UDIV     r0,r0,r1
000122  1d40              ADDS     r0,r0,#5
000124  210a              MOVS     r1,#0xa
000126  fbb0f0f1          UDIV     r0,r0,r1
00012a  1e46              SUBS     r6,r0,#1
;;;217        i2c->CLKDIV = u32Div;
00012c  612e              STR      r6,[r5,#0x10]
;;;218    
;;;219        return (u32Pclk / ((u32Div + 1u) << 2u));
00012e  1c70              ADDS     r0,r6,#1
000130  0080              LSLS     r0,r0,#2
000132  fbb4f0f0          UDIV     r0,r4,r0
;;;220    }
000136  e8bd81f0          POP      {r4-r8,pc}
;;;221    
                          ENDP

                  I2C_GetIntFlag PROC
;;;230     */
;;;231    uint32_t I2C_GetIntFlag(I2C_T *i2c)
00013a  4601              MOV      r1,r0
;;;232    {
;;;233        return ((i2c->CTL & I2C_CTL_SI_Msk) == I2C_CTL_SI_Msk ? 1 : 0);
00013c  6808              LDR      r0,[r1,#0]
00013e  f3c000c0          UBFX     r0,r0,#3,#1
;;;234    }
000142  4770              BX       lr
;;;235    
                          ENDP

                  I2C_GetStatus PROC
;;;244     */
;;;245    uint32_t I2C_GetStatus(I2C_T *i2c)
000144  4601              MOV      r1,r0
;;;246    {
;;;247        return (i2c->STATUS);
000146  68c8              LDR      r0,[r1,#0xc]
;;;248    }
000148  4770              BX       lr
;;;249    
                          ENDP

                  I2C_GetData PROC
;;;258     */
;;;259    uint8_t I2C_GetData(I2C_T *i2c)
00014a  4601              MOV      r1,r0
;;;260    {
;;;261        return (i2c->DAT);
00014c  6888              LDR      r0,[r1,#8]
00014e  b2c0              UXTB     r0,r0
;;;262    }
000150  4770              BX       lr
;;;263    
                          ENDP

                  I2C_SetData PROC
;;;273     */
;;;274    void I2C_SetData(I2C_T *i2c, uint8_t u8Data)
000152  6081              STR      r1,[r0,#8]
;;;275    {
;;;276        i2c->DAT = u8Data;
;;;277    }
000154  4770              BX       lr
;;;278    
                          ENDP

                  I2C_SetSlaveAddr PROC
;;;292     */
;;;293    void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode)
000156  b510              PUSH     {r4,lr}
;;;294    {
;;;295        switch(u8SlaveNo)
000158  b199              CBZ      r1,|L1.386|
00015a  2901              CMP      r1,#1
00015c  d004              BEQ      |L1.360|
00015e  2902              CMP      r1,#2
000160  d006              BEQ      |L1.368|
000162  2903              CMP      r1,#3
000164  d10c              BNE      |L1.384|
000166  e007              B        |L1.376|
                  |L1.360|
;;;296        {
;;;297            case 1:
;;;298                i2c->ADDR1  = (u8SlaveAddr << 1) | u8GCMode;
000168  ea430442          ORR      r4,r3,r2,LSL #1
00016c  6184              STR      r4,[r0,#0x18]
;;;299                break;
00016e  e00c              B        |L1.394|
                  |L1.368|
;;;300            case 2:
;;;301                i2c->ADDR2  = (u8SlaveAddr << 1) | u8GCMode;
000170  ea430442          ORR      r4,r3,r2,LSL #1
000174  61c4              STR      r4,[r0,#0x1c]
;;;302                break;
000176  e008              B        |L1.394|
                  |L1.376|
;;;303            case 3:
;;;304                i2c->ADDR3  = (u8SlaveAddr << 1) | u8GCMode;
000178  ea430442          ORR      r4,r3,r2,LSL #1
00017c  6204              STR      r4,[r0,#0x20]
;;;305                break;
00017e  e004              B        |L1.394|
                  |L1.384|
;;;306            case 0:
000180  bf00              NOP      
                  |L1.386|
;;;307            default:
;;;308                i2c->ADDR0  = (u8SlaveAddr << 1) | u8GCMode;
000182  ea430442          ORR      r4,r3,r2,LSL #1
000186  6044              STR      r4,[r0,#4]
;;;309                break;
000188  bf00              NOP      
                  |L1.394|
00018a  bf00              NOP                            ;299
;;;310        }
;;;311    }
00018c  bd10              POP      {r4,pc}
;;;312    
                          ENDP

                  I2C_SetSlaveAddrMask PROC
;;;324     */
;;;325    void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask)
00018e  b181              CBZ      r1,|L1.434|
;;;326    {
;;;327        switch(u8SlaveNo)
000190  2901              CMP      r1,#1
000192  d004              BEQ      |L1.414|
000194  2902              CMP      r1,#2
000196  d005              BEQ      |L1.420|
000198  2903              CMP      r1,#3
00019a  d109              BNE      |L1.432|
00019c  e005              B        |L1.426|
                  |L1.414|
;;;328        {
;;;329            case 1:
;;;330                i2c->ADDRMSK1  = u8SlaveAddrMask << 1;
00019e  0053              LSLS     r3,r2,#1
0001a0  6283              STR      r3,[r0,#0x28]
;;;331                break;
0001a2  e009              B        |L1.440|
                  |L1.420|
;;;332            case 2:
;;;333                i2c->ADDRMSK2  = u8SlaveAddrMask << 1;
0001a4  0053              LSLS     r3,r2,#1
0001a6  62c3              STR      r3,[r0,#0x2c]
;;;334                break;
0001a8  e006              B        |L1.440|
                  |L1.426|
;;;335            case 3:
;;;336                i2c->ADDRMSK3  = u8SlaveAddrMask << 1;
0001aa  0053              LSLS     r3,r2,#1
0001ac  6303              STR      r3,[r0,#0x30]
;;;337                break;
0001ae  e003              B        |L1.440|
                  |L1.432|
;;;338            case 0:
0001b0  bf00              NOP      
                  |L1.434|
;;;339            default:
;;;340                i2c->ADDRMSK0  = u8SlaveAddrMask << 1;
0001b2  0053              LSLS     r3,r2,#1
0001b4  6243              STR      r3,[r0,#0x24]
;;;341                break;
0001b6  bf00              NOP      
                  |L1.440|
0001b8  bf00              NOP                            ;331
;;;342        }
;;;343    }
0001ba  4770              BX       lr
;;;344    
                          ENDP

                  I2C_EnableTimeout PROC
;;;356     */
;;;357    void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout)
0001bc  b121              CBZ      r1,|L1.456|
;;;358    {
;;;359        if(u8LongTimeout)
;;;360            i2c->TOCTL |= I2C_TOCTL_TOCDIV4_Msk;
0001be  6942              LDR      r2,[r0,#0x14]
0001c0  f0420202          ORR      r2,r2,#2
0001c4  6142              STR      r2,[r0,#0x14]
0001c6  e003              B        |L1.464|
                  |L1.456|
;;;361        else
;;;362            i2c->TOCTL &= ~I2C_TOCTL_TOCDIV4_Msk;
0001c8  6942              LDR      r2,[r0,#0x14]
0001ca  f0220202          BIC      r2,r2,#2
0001ce  6142              STR      r2,[r0,#0x14]
                  |L1.464|
;;;363    
;;;364        i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
0001d0  6942              LDR      r2,[r0,#0x14]
0001d2  f0420204          ORR      r2,r2,#4
0001d6  6142              STR      r2,[r0,#0x14]
;;;365    }
0001d8  4770              BX       lr
;;;366    
                          ENDP

                  I2C_DisableTimeout PROC
;;;376     */
;;;377    void I2C_DisableTimeout(I2C_T *i2c)
0001da  6941              LDR      r1,[r0,#0x14]
;;;378    {
;;;379        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
0001dc  f0210104          BIC      r1,r1,#4
0001e0  6141              STR      r1,[r0,#0x14]
;;;380    }
0001e2  4770              BX       lr
;;;381    
                          ENDP

                  I2C_EnableWakeup PROC
;;;391     */
;;;392    void I2C_EnableWakeup(I2C_T *i2c)
0001e4  6bc1              LDR      r1,[r0,#0x3c]
;;;393    {
;;;394        i2c->WKCTL |= I2C_WKCTL_WKEN_Msk;
0001e6  f0410101          ORR      r1,r1,#1
0001ea  63c1              STR      r1,[r0,#0x3c]
;;;395    }
0001ec  4770              BX       lr
;;;396    
                          ENDP

                  I2C_DisableWakeup PROC
;;;406     */
;;;407    void I2C_DisableWakeup(I2C_T *i2c)
0001ee  6bc1              LDR      r1,[r0,#0x3c]
;;;408    {
;;;409        i2c->WKCTL &= ~I2C_WKCTL_WKEN_Msk;
0001f0  f0210101          BIC      r1,r1,#1
0001f4  63c1              STR      r1,[r0,#0x3c]
;;;410    }
0001f6  4770              BX       lr
;;;411    
                          ENDP

                  I2C_SMBusGetStatus PROC
;;;421     */
;;;422    uint32_t I2C_SMBusGetStatus(I2C_T *i2c)
0001f8  4601              MOV      r1,r0
;;;423    {
;;;424        return (i2c->BUSSTS);
0001fa  6cc8              LDR      r0,[r1,#0x4c]
;;;425    }
0001fc  4770              BX       lr
;;;426    
                          ENDP

                  I2C_SMBusClearInterruptFlag PROC
;;;437     */
;;;438    void I2C_SMBusClearInterruptFlag(I2C_T *i2c, uint8_t u8SMBusIntFlag)
0001fe  6cc2              LDR      r2,[r0,#0x4c]
;;;439    {
;;;440        i2c->BUSSTS |= u8SMBusIntFlag;
000200  430a              ORRS     r2,r2,r1
000202  64c2              STR      r2,[r0,#0x4c]
;;;441    }
000204  4770              BX       lr
;;;442    
                          ENDP

                  I2C_SMBusSetPacketByteCount PROC
;;;453     */
;;;454    void I2C_SMBusSetPacketByteCount(I2C_T *i2c, uint32_t u32PktSize)
000206  6501              STR      r1,[r0,#0x50]
;;;455    {
;;;456        i2c->PKTSIZE = u32PktSize;
;;;457    }
000208  4770              BX       lr
;;;458    
                          ENDP

                  I2C_SMBusOpen PROC
;;;469     */
;;;470    void I2C_SMBusOpen(I2C_T *i2c, uint8_t u8HostDevice)
00020a  6c42              LDR      r2,[r0,#0x44]
;;;471    {
;;;472        /* Clear  BMHEN, BMDEN of BUSCTL Register */
;;;473        i2c->BUSCTL &=  ~(I2C_BUSCTL_BMHEN_Msk | I2C_BUSCTL_BMDEN_Msk);
00020c  f022020c          BIC      r2,r2,#0xc
000210  6442              STR      r2,[r0,#0x44]
;;;474    
;;;475        /* Set SMBus Host/Device Mode, and enable Bus Management*/
;;;476        if(u8HostDevice == I2C_SMBH_ENABLE)
000212  2901              CMP      r1,#1
000214  d104              BNE      |L1.544|
;;;477            i2c->BUSCTL |= (I2C_BUSCTL_BMHEN_Msk | I2C_BUSCTL_BUSEN_Msk);
000216  6c42              LDR      r2,[r0,#0x44]
000218  f0420288          ORR      r2,r2,#0x88
00021c  6442              STR      r2,[r0,#0x44]
00021e  e003              B        |L1.552|
                  |L1.544|
;;;478        else
;;;479            i2c->BUSCTL |= (I2C_BUSCTL_BMDEN_Msk | I2C_BUSCTL_BUSEN_Msk);
000220  6c42              LDR      r2,[r0,#0x44]
000222  f0420284          ORR      r2,r2,#0x84
000226  6442              STR      r2,[r0,#0x44]
                  |L1.552|
;;;480    }
000228  4770              BX       lr
;;;481    
                          ENDP

                  I2C_SMBusClose PROC
;;;491     */
;;;492    void I2C_SMBusClose(I2C_T *i2c)
00022a  2100              MOVS     r1,#0
;;;493    {
;;;494    
;;;495        i2c->BUSCTL = 0x00;
00022c  6441              STR      r1,[r0,#0x44]
;;;496    }
00022e  4770              BX       lr
;;;497    
                          ENDP

                  I2C_SMBusPECTxEnable PROC
;;;508     */
;;;509    void I2C_SMBusPECTxEnable(I2C_T *i2c, uint8_t u8PECTxEn)
000230  6c42              LDR      r2,[r0,#0x44]
;;;510    {
;;;511        i2c->BUSCTL &= ~I2C_BUSCTL_PECTXEN_Msk;
000232  f4227280          BIC      r2,r2,#0x100
000236  6442              STR      r2,[r0,#0x44]
;;;512    
;;;513        if(u8PECTxEn)
000238  b121              CBZ      r1,|L1.580|
;;;514            i2c->BUSCTL |= (I2C_BUSCTL_PECEN_Msk | I2C_BUSCTL_PECTXEN_Msk);
00023a  6c42              LDR      r2,[r0,#0x44]
00023c  f4427281          ORR      r2,r2,#0x102
000240  6442              STR      r2,[r0,#0x44]
000242  e003              B        |L1.588|
                  |L1.580|
;;;515        else
;;;516            i2c->BUSCTL |= I2C_BUSCTL_PECEN_Msk;
000244  6c42              LDR      r2,[r0,#0x44]
000246  f0420202          ORR      r2,r2,#2
00024a  6442              STR      r2,[r0,#0x44]
                  |L1.588|
;;;517    }
00024c  4770              BX       lr
;;;518    
                          ENDP

                  I2C_SMBusGetPECValue PROC
;;;528     */
;;;529    uint8_t I2C_SMBusGetPECValue(I2C_T *i2c)
00024e  4601              MOV      r1,r0
;;;530    {
;;;531        return i2c->PKTCRC;
000250  6d48              LDR      r0,[r1,#0x54]
000252  b2c0              UXTB     r0,r0
;;;532    }
000254  4770              BX       lr
;;;533    
                          ENDP

                  I2C_SMBusIdleTimeout PROC
;;;546    
;;;547    void I2C_SMBusIdleTimeout(I2C_T *i2c, uint32_t us, uint32_t u32Hclk)
000256  b570              PUSH     {r4-r6,lr}
;;;548    {
;;;549        uint32_t  u32Div, u32Hclk_kHz;
;;;550    
;;;551        i2c->BUSCTL |= I2C_BUSCTL_TIDLE_Msk;
000258  6c45              LDR      r5,[r0,#0x44]
00025a  f4457500          ORR      r5,r5,#0x200
00025e  6445              STR      r5,[r0,#0x44]
;;;552        u32Hclk_kHz = u32Hclk / 1000;
000260  f44f757a          MOV      r5,#0x3e8
000264  fbb2f4f5          UDIV     r4,r2,r5
;;;553        u32Div = (((us * u32Hclk_kHz) / 1000) >> 2) - 1;
000268  fb01f504          MUL      r5,r1,r4
00026c  f44f767a          MOV      r6,#0x3e8
000270  fbb5f5f6          UDIV     r5,r5,r6
000274  2601              MOVS     r6,#1
000276  ebc60395          RSB      r3,r6,r5,LSR #2
;;;554        if(u32Div > 255)
00027a  2bff              CMP      r3,#0xff
00027c  d902              BLS      |L1.644|
;;;555        {
;;;556            i2c->BUSTOUT = 0xFF;
00027e  25ff              MOVS     r5,#0xff
000280  6585              STR      r5,[r0,#0x58]
000282  e000              B        |L1.646|
                  |L1.644|
;;;557        }
;;;558        else
;;;559        {
;;;560            i2c->BUSTOUT = u32Div;
000284  6583              STR      r3,[r0,#0x58]
                  |L1.646|
;;;561        }
;;;562    
;;;563    }
000286  bd70              POP      {r4-r6,pc}
;;;564    
                          ENDP

                  I2C_SMBusTimeout PROC
;;;578    
;;;579    void I2C_SMBusTimeout(I2C_T *i2c, uint32_t ms, uint32_t u32Pclk)
000288  b570              PUSH     {r4-r6,lr}
;;;580    {
;;;581        uint32_t u32Div, u32Pclk_kHz;
;;;582    
;;;583        i2c->BUSCTL &= ~I2C_BUSCTL_TIDLE_Msk;
00028a  6c45              LDR      r5,[r0,#0x44]
00028c  f4257500          BIC      r5,r5,#0x200
000290  6445              STR      r5,[r0,#0x44]
;;;584    
;;;585        /* DIV4 disabled */
;;;586        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000292  6945              LDR      r5,[r0,#0x14]
000294  f0250504          BIC      r5,r5,#4
000298  6145              STR      r5,[r0,#0x14]
;;;587        u32Pclk_kHz = u32Pclk / 1000;
00029a  f44f757a          MOV      r5,#0x3e8
00029e  fbb2f4f5          UDIV     r4,r2,r5
;;;588        u32Div = ((ms * u32Pclk_kHz) / (16 * 1024)) - 1;
0002a2  fb01f504          MUL      r5,r1,r4
0002a6  2601              MOVS     r6,#1
0002a8  ebc63395          RSB      r3,r6,r5,LSR #14
;;;589        if(u32Div <= 0xFF)
0002ac  2bff              CMP      r3,#0xff
0002ae  d801              BHI      |L1.692|
;;;590        {
;;;591            i2c->BUSTOUT = u32Div;
0002b0  6583              STR      r3,[r0,#0x58]
                  |L1.690|
;;;592            return;
;;;593        }
;;;594    
;;;595        /* DIV4 enabled */
;;;596        i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
;;;597    
;;;598        i2c->BUSTOUT = (((ms * u32Pclk_kHz) / (16 * 1024 * 4)) - 1) & 0xFF; //The max value is 255
;;;599    }
0002b2  bd70              POP      {r4-r6,pc}
                  |L1.692|
0002b4  6945              LDR      r5,[r0,#0x14]         ;596
0002b6  f0450504          ORR      r5,r5,#4              ;596
0002ba  6145              STR      r5,[r0,#0x14]         ;596
0002bc  fb01f504          MUL      r5,r1,r4              ;598
0002c0  2601              MOVS     r6,#1                 ;598
0002c2  ebc64515          RSB      r5,r6,r5,LSR #16      ;598
0002c6  b2ed              UXTB     r5,r5                 ;598
0002c8  6585              STR      r5,[r0,#0x58]         ;598
0002ca  bf00              NOP      
0002cc  e7f1              B        |L1.690|
;;;600    
                          ENDP

                  I2C_SMBusClockLoTimeout PROC
;;;614    
;;;615    void I2C_SMBusClockLoTimeout(I2C_T *i2c, uint32_t ms, uint32_t u32Pclk)
0002ce  b570              PUSH     {r4-r6,lr}
;;;616    {
;;;617        uint32_t u32Div, u32Pclk_kHz;
;;;618    
;;;619        i2c->BUSCTL &= ~I2C_BUSCTL_TIDLE_Msk;
0002d0  6c45              LDR      r5,[r0,#0x44]
0002d2  f4257500          BIC      r5,r5,#0x200
0002d6  6445              STR      r5,[r0,#0x44]
;;;620    
;;;621        /* DIV4 disabled */
;;;622        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
0002d8  6945              LDR      r5,[r0,#0x14]
0002da  f0250504          BIC      r5,r5,#4
0002de  6145              STR      r5,[r0,#0x14]
;;;623        u32Pclk_kHz = u32Pclk / 1000;
0002e0  f44f757a          MOV      r5,#0x3e8
0002e4  fbb2f4f5          UDIV     r4,r2,r5
;;;624        u32Div = ((ms * u32Pclk_kHz) / (16 * 1024)) - 1;
0002e8  fb01f504          MUL      r5,r1,r4
0002ec  2601              MOVS     r6,#1
0002ee  ebc63395          RSB      r3,r6,r5,LSR #14
;;;625        if(u32Div <= 0xFF)
0002f2  2bff              CMP      r3,#0xff
0002f4  d801              BHI      |L1.762|
;;;626        {
;;;627            i2c->CLKTOUT = u32Div;
0002f6  65c3              STR      r3,[r0,#0x5c]
                  |L1.760|
;;;628            return;
;;;629        }
;;;630    
;;;631        /* DIV4 enabled */
;;;632        i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
;;;633        i2c->CLKTOUT = (((ms * u32Pclk_kHz) / (16 * 1024 * 4)) - 1) & 0xFF; //The max value is 255
;;;634    }
0002f8  bd70              POP      {r4-r6,pc}
                  |L1.762|
0002fa  6945              LDR      r5,[r0,#0x14]         ;632
0002fc  f0450504          ORR      r5,r5,#4              ;632
000300  6145              STR      r5,[r0,#0x14]         ;632
000302  fb01f504          MUL      r5,r1,r4              ;633
000306  2601              MOVS     r6,#1                 ;633
000308  ebc64515          RSB      r5,r6,r5,LSR #16      ;633
00030c  b2ed              UXTB     r5,r5                 ;633
00030e  65c5              STR      r5,[r0,#0x5c]         ;633
000310  bf00              NOP      
000312  e7f1              B        |L1.760|
;;;635    
                          ENDP

                  |L1.788|
                          DCD      0x40081000
                  |L1.792|
                          DCD      0x40080000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REV16|
#line 114 "..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_i2c_c_I2C_Open____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REVSH|
#line 128
|__asm___5_i2c_c_I2C_Open____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
