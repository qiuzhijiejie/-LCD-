; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M451Series\Include -I..\..\..\Library\StdDriver\inc -I..\Bsp -I..\User -I..\lcd_driver -I..\exti_driver -I..\led_driver -I..\touch -I..\dotmatix_lcd -I..\KH -I.\RTE\_project -ID:\KEIL_STM32\Packs\ARM\CMSIS\6.1.0\CMSIS\Core\Include -D__UVISION_VERSION=541 -D_RTE_ --omf_browse=.\obj\clk.crf ..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;525      */
;;;526    void CLK_DisableModuleClock(unsigned int u32ModuleIdx)
000000  2103              MOVS     r1,#3
;;;527    {
;;;528        *(volatile unsigned int *)((unsigned int)&CLK->AHBCLK + (MODULE_APBCLK(u32ModuleIdx) * 4))  &= ~(1 << MODULE_IP_EN_Pos(u32ModuleIdx));
000002  ea017190          AND      r1,r1,r0,LSR #30
000006  0089              LSLS     r1,r1,#2
000008  f1014180          ADD      r1,r1,#0x40000000
00000c  f8d11204          LDR      r1,[r1,#0x204]
000010  f000031f          AND      r3,r0,#0x1f
000014  2201              MOVS     r2,#1
000016  409a              LSLS     r2,r2,r3
000018  4391              BICS     r1,r1,r2
00001a  2203              MOVS     r2,#3
00001c  ea027290          AND      r2,r2,r0,LSR #30
000020  0092              LSLS     r2,r2,#2
000022  f1024280          ADD      r2,r2,#0x40000000
000026  f8c21204          STR      r1,[r2,#0x204]
;;;529    }
00002a  4770              BX       lr
;;;530    
                          ENDP

                  CLK_DisableCKO PROC
;;;31       */
;;;32     void CLK_DisableCKO(void)
00002c  b500              PUSH     {lr}
;;;33     {
;;;34         /* Disable CKO clock source */
;;;35         CLK_DisableModuleClock(CLKO_MODULE);
00002e  48fe              LDR      r0,|L1.1064|
000030  f7fffffe          BL       CLK_DisableModuleClock
;;;36     }
000034  bd00              POP      {pc}
;;;37     
                          ENDP

                  CLK_SetModuleClock PROC
;;;372      */
;;;373    void CLK_SetModuleClock(unsigned int u32ModuleIdx, unsigned int u32ClkSrc, unsigned int u32ClkDiv)
000036  b5f0              PUSH     {r4-r7,lr}
;;;374    {
;;;375        unsigned int u32sel = 0, u32div = 0;
000038  2300              MOVS     r3,#0
00003a  2400              MOVS     r4,#0
;;;376    
;;;377        if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
00003c  f3c02587          UBFX     r5,r0,#10,#8
000040  b16d              CBZ      r5,|L1.94|
;;;378        {
;;;379            /* Get clock divider control register address */
;;;380            u32div = (unsigned int)&CLK->CLKDIV0 + ((MODULE_CLKDIV(u32ModuleIdx)) * 4);
000042  f3c04581          UBFX     r5,r0,#18,#2
000046  4ef9              LDR      r6,|L1.1068|
000048  eb060485          ADD      r4,r6,r5,LSL #2
;;;381            /* Apply new divider */
;;;382            M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
00004c  6825              LDR      r5,[r4,#0]
00004e  f3c02687          UBFX     r6,r0,#10,#8
000052  f3c01744          UBFX     r7,r0,#5,#5
000056  40be              LSLS     r6,r6,r7
000058  43b5              BICS     r5,r5,r6
00005a  4315              ORRS     r5,r5,r2
00005c  6025              STR      r5,[r4,#0]
                  |L1.94|
;;;383        }
;;;384    
;;;385        if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
00005e  f3c06542          UBFX     r5,r0,#25,#3
000062  b175              CBZ      r5,|L1.130|
;;;386        {
;;;387            /* Get clock select control register address */
;;;388            u32sel = (unsigned int)&CLK->CLKSEL0 + ((MODULE_CLKSEL(u32ModuleIdx)) * 4);
000064  f3c07501          UBFX     r5,r0,#28,#2
000068  4ef0              LDR      r6,|L1.1068|
00006a  3e10              SUBS     r6,r6,#0x10
00006c  eb060385          ADD      r3,r6,r5,LSL #2
;;;389            /* Set new clock selection setting */
;;;390            M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
000070  681d              LDR      r5,[r3,#0]
000072  f3c06642          UBFX     r6,r0,#25,#3
000076  f3c05704          UBFX     r7,r0,#20,#5
00007a  40be              LSLS     r6,r6,r7
00007c  43b5              BICS     r5,r5,r6
00007e  430d              ORRS     r5,r5,r1
000080  601d              STR      r5,[r3,#0]
                  |L1.130|
;;;391        }
;;;392    }
000082  bdf0              POP      {r4-r7,pc}
;;;393    
                          ENDP

                  CLK_EnableModuleClock PROC
;;;482      */
;;;483    void CLK_EnableModuleClock(unsigned int u32ModuleIdx)
000084  2103              MOVS     r1,#3
;;;484    {
;;;485        *(volatile unsigned int *)((unsigned int)&CLK->AHBCLK + (MODULE_APBCLK(u32ModuleIdx) * 4))  |= 1 << MODULE_IP_EN_Pos(u32ModuleIdx);
000086  ea017190          AND      r1,r1,r0,LSR #30
00008a  0089              LSLS     r1,r1,#2
00008c  f1014180          ADD      r1,r1,#0x40000000
000090  f8d11204          LDR      r1,[r1,#0x204]
000094  f000031f          AND      r3,r0,#0x1f
000098  2201              MOVS     r2,#1
00009a  409a              LSLS     r2,r2,r3
00009c  4311              ORRS     r1,r1,r2
00009e  2203              MOVS     r2,#3
0000a0  ea027290          AND      r2,r2,r0,LSR #30
0000a4  0092              LSLS     r2,r2,#2
0000a6  f1024280          ADD      r2,r2,#0x40000000
0000aa  f8c21204          STR      r1,[r2,#0x204]
;;;486    }
0000ae  4770              BX       lr
;;;487    
                          ENDP

                  CLK_EnableCKO PROC
;;;54       */
;;;55     void CLK_EnableCKO(unsigned int u32ClkSrc, unsigned int u32ClkDiv, unsigned int u32ClkDivBy1En)
0000b0  b570              PUSH     {r4-r6,lr}
;;;56     {
0000b2  4604              MOV      r4,r0
0000b4  460d              MOV      r5,r1
0000b6  4616              MOV      r6,r2
;;;57         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;58         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | u32ClkDiv | (u32ClkDivBy1En << CLK_CLKOCTL_DIV1EN_Pos);
0000b8  f0450010          ORR      r0,r5,#0x10
0000bc  ea401046          ORR      r0,r0,r6,LSL #5
0000c0  49da              LDR      r1,|L1.1068|
0000c2  3140              ADDS     r1,r1,#0x40
0000c4  6008              STR      r0,[r1,#0]
;;;59     
;;;60         /* Enable CKO clock source */
;;;61         CLK_EnableModuleClock(CLKO_MODULE);
0000c6  48d8              LDR      r0,|L1.1064|
0000c8  f7fffffe          BL       CLK_EnableModuleClock
;;;62     
;;;63         /* Select CKO clock source */
;;;64         CLK_SetModuleClock(CLKO_MODULE, u32ClkSrc, 0);
0000cc  2200              MOVS     r2,#0
0000ce  4621              MOV      r1,r4
0000d0  48d5              LDR      r0,|L1.1064|
0000d2  f7fffffe          BL       CLK_SetModuleClock
;;;65     }
0000d6  bd70              POP      {r4-r6,pc}
;;;66     
                          ENDP

                  CLK_PowerDown PROC
;;;73       */
;;;74     void CLK_PowerDown(void)
0000d8  48d5              LDR      r0,|L1.1072|
;;;75     {
;;;76         /* Set the processor uses deep sleep as its low power mode */
;;;77         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
0000da  6800              LDR      r0,[r0,#0]
0000dc  f0400004          ORR      r0,r0,#4
0000e0  49d3              LDR      r1,|L1.1072|
0000e2  6008              STR      r0,[r1,#0]
;;;78     
;;;79         /* Set system Power-down enabled and Power-down entry condition */
;;;80         CLK->PWRCTL |= (CLK_PWRCTL_PDEN_Msk | CLK_PWRCTL_PDWTCPU_Msk);
0000e4  48d1              LDR      r0,|L1.1068|
0000e6  3820              SUBS     r0,r0,#0x20
0000e8  6800              LDR      r0,[r0,#0]
0000ea  f44070c0          ORR      r0,r0,#0x180
0000ee  0689              LSLS     r1,r1,#26
0000f0  f8c10200          STR      r0,[r1,#0x200]
;;;81     
;;;82         /* Chip enter Power-down mode after CPU run WFI instruction */
;;;83         __WFI();
0000f4  bf30              WFI      
;;;84     }
0000f6  4770              BX       lr
;;;85     
                          ENDP

                  CLK_Idle PROC
;;;92       */
;;;93     void CLK_Idle(void)
0000f8  48cd              LDR      r0,|L1.1072|
;;;94     {
;;;95         /* Set the processor uses sleep as its low power mode */
;;;96         SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
0000fa  6800              LDR      r0,[r0,#0]
0000fc  f0200004          BIC      r0,r0,#4
000100  49cb              LDR      r1,|L1.1072|
000102  6008              STR      r0,[r1,#0]
;;;97     
;;;98         /* Set chip in idle mode because of WFI command */
;;;99         CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
000104  48c9              LDR      r0,|L1.1068|
000106  3820              SUBS     r0,r0,#0x20
000108  6800              LDR      r0,[r0,#0]
00010a  f0200080          BIC      r0,r0,#0x80
00010e  0689              LSLS     r1,r1,#26
000110  f8c10200          STR      r0,[r1,#0x200]
;;;100    
;;;101        /* Chip enter idle mode after CPU run WFI instruction */
;;;102        __WFI();
000114  bf30              WFI      
;;;103    }
000116  4770              BX       lr
;;;104    
                          ENDP

                  CLK_GetHXTFreq PROC
;;;110      */
;;;111    unsigned int CLK_GetHXTFreq(void)
000118  48c4              LDR      r0,|L1.1068|
;;;112    {
;;;113        if(CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk)
00011a  3820              SUBS     r0,r0,#0x20
00011c  6800              LDR      r0,[r0,#0]
00011e  f0000001          AND      r0,r0,#1
000122  b108              CBZ      r0,|L1.296|
;;;114            return __HXT;
000124  48c3              LDR      r0,|L1.1076|
                  |L1.294|
;;;115        else
;;;116            return 0;
;;;117    }
000126  4770              BX       lr
                  |L1.296|
000128  2000              MOVS     r0,#0                 ;116
00012a  e7fc              B        |L1.294|
;;;118    
                          ENDP

                  CLK_GetLXTFreq PROC
;;;125      */
;;;126    unsigned int CLK_GetLXTFreq(void)
00012c  48bf              LDR      r0,|L1.1068|
;;;127    {
;;;128        if(CLK->PWRCTL & CLK_PWRCTL_LXTEN_Msk)
00012e  3820              SUBS     r0,r0,#0x20
000130  6800              LDR      r0,[r0,#0]
000132  f0000002          AND      r0,r0,#2
000136  b110              CBZ      r0,|L1.318|
;;;129            return __LXT;
000138  f44f4000          MOV      r0,#0x8000
                  |L1.316|
;;;130        else
;;;131            return 0;
;;;132    }
00013c  4770              BX       lr
                  |L1.318|
00013e  2000              MOVS     r0,#0                 ;131
000140  e7fc              B        |L1.316|
;;;133    
                          ENDP

                  CLK_GetPCLK0Freq PROC
;;;139      */
;;;140    unsigned int CLK_GetPCLK0Freq(void)
000142  b510              PUSH     {r4,lr}
;;;141    {
;;;142        SystemCoreClockUpdate();
000144  f7fffffe          BL       SystemCoreClockUpdate
;;;143        if(CLK->CLKSEL0 & CLK_CLKSEL0_PCLK0SEL_Msk)
000148  48b8              LDR      r0,|L1.1068|
00014a  3810              SUBS     r0,r0,#0x10
00014c  6800              LDR      r0,[r0,#0]
00014e  f0000040          AND      r0,r0,#0x40
000152  b118              CBZ      r0,|L1.348|
;;;144            return SystemCoreClock / 2;
000154  48b8              LDR      r0,|L1.1080|
000156  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000158  0840              LSRS     r0,r0,#1
                  |L1.346|
;;;145        else
;;;146            return SystemCoreClock;
;;;147    }
00015a  bd10              POP      {r4,pc}
                  |L1.348|
00015c  48b6              LDR      r0,|L1.1080|
00015e  6800              LDR      r0,[r0,#0]            ;146  ; SystemCoreClock
000160  e7fb              B        |L1.346|
;;;148    
                          ENDP

                  CLK_GetPCLK1Freq PROC
;;;155      */
;;;156    unsigned int CLK_GetPCLK1Freq(void)
000162  b510              PUSH     {r4,lr}
;;;157    {
;;;158        SystemCoreClockUpdate();
000164  f7fffffe          BL       SystemCoreClockUpdate
;;;159        if(CLK->CLKSEL0 & CLK_CLKSEL0_PCLK1SEL_Msk)
000168  48b0              LDR      r0,|L1.1068|
00016a  3810              SUBS     r0,r0,#0x10
00016c  6800              LDR      r0,[r0,#0]
00016e  f0000080          AND      r0,r0,#0x80
000172  b118              CBZ      r0,|L1.380|
;;;160            return SystemCoreClock / 2;
000174  48b0              LDR      r0,|L1.1080|
000176  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000178  0840              LSRS     r0,r0,#1
                  |L1.378|
;;;161        else
;;;162            return SystemCoreClock;
;;;163    }
00017a  bd10              POP      {r4,pc}
                  |L1.380|
00017c  48ae              LDR      r0,|L1.1080|
00017e  6800              LDR      r0,[r0,#0]            ;162  ; SystemCoreClock
000180  e7fb              B        |L1.378|
;;;164    
                          ENDP

                  CLK_GetHCLKFreq PROC
;;;171      */
;;;172    unsigned int CLK_GetHCLKFreq(void)
000182  b510              PUSH     {r4,lr}
;;;173    {
;;;174        SystemCoreClockUpdate();
000184  f7fffffe          BL       SystemCoreClockUpdate
;;;175        return SystemCoreClock;
000188  48ab              LDR      r0,|L1.1080|
00018a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;176    }
00018c  bd10              POP      {r4,pc}
;;;177    
                          ENDP

                  CLK_GetCPUFreq PROC
;;;184      */
;;;185    unsigned int CLK_GetCPUFreq(void)
00018e  b510              PUSH     {r4,lr}
;;;186    {
;;;187        SystemCoreClockUpdate();
000190  f7fffffe          BL       SystemCoreClockUpdate
;;;188        return SystemCoreClock;
000194  48a8              LDR      r0,|L1.1080|
000196  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;189    }
000198  bd10              POP      {r4,pc}
;;;190    
                          ENDP

                  CLK_WaitClockReady PROC
;;;683      */
;;;684    unsigned int CLK_WaitClockReady(unsigned int u32ClkMask)
00019a  4601              MOV      r1,r0
;;;685    {    
;;;686        int32_t i32TimeOutCnt = 2160000;
00019c  4aa7              LDR      r2,|L1.1084|
;;;687    
;;;688        while((CLK->STATUS & u32ClkMask) != u32ClkMask)
00019e  e005              B        |L1.428|
                  |L1.416|
;;;689        {
;;;690            if(i32TimeOutCnt-- <= 0)
0001a0  1e10              SUBS     r0,r2,#0
0001a2  f1a20201          SUB      r2,r2,#1
0001a6  dc01              BGT      |L1.428|
;;;691                return 0;
0001a8  2000              MOVS     r0,#0
                  |L1.426|
;;;692        }
;;;693    
;;;694        return 1;
;;;695    }
0001aa  4770              BX       lr
                  |L1.428|
0001ac  489f              LDR      r0,|L1.1068|
0001ae  3030              ADDS     r0,r0,#0x30           ;688
0001b0  6800              LDR      r0,[r0,#0]            ;688
0001b2  4008              ANDS     r0,r0,r1              ;688
0001b4  4288              CMP      r0,r1                 ;688
0001b6  d1f3              BNE      |L1.416|
0001b8  2001              MOVS     r0,#1                 ;694
0001ba  e7f6              B        |L1.426|
;;;696    
                          ENDP

                  CLK_SetHCLK PROC
;;;260      */
;;;261    void CLK_SetHCLK(unsigned int u32ClkSrc, unsigned int u32ClkDiv)
0001bc  b570              PUSH     {r4-r6,lr}
;;;262    {
0001be  4604              MOV      r4,r0
0001c0  460d              MOV      r5,r1
;;;263        unsigned int u32HIRCSTB;
;;;264    
;;;265        /* Read HIRC clock source stable flag */
;;;266        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
0001c2  489a              LDR      r0,|L1.1068|
0001c4  3030              ADDS     r0,r0,#0x30
0001c6  6800              LDR      r0,[r0,#0]
0001c8  f0000610          AND      r6,r0,#0x10
;;;267    
;;;268        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;269        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
0001cc  f04f4080          MOV      r0,#0x40000000
0001d0  f8d00200          LDR      r0,[r0,#0x200]
0001d4  f0400004          ORR      r0,r0,#4
0001d8  4994              LDR      r1,|L1.1068|
0001da  3920              SUBS     r1,r1,#0x20
0001dc  6008              STR      r0,[r1,#0]
;;;270        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
0001de  2010              MOVS     r0,#0x10
0001e0  f7fffffe          BL       CLK_WaitClockReady
;;;271        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
0001e4  4891              LDR      r0,|L1.1068|
0001e6  3810              SUBS     r0,r0,#0x10
0001e8  6800              LDR      r0,[r0,#0]
0001ea  f0200007          BIC      r0,r0,#7
0001ee  1dc0              ADDS     r0,r0,#7
0001f0  f04f4180          MOV      r1,#0x40000000
0001f4  f8c10210          STR      r0,[r1,#0x210]
;;;272    
;;;273        /* Apply new Divider */
;;;274        CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
0001f8  488c              LDR      r0,|L1.1068|
0001fa  6800              LDR      r0,[r0,#0]
0001fc  f020000f          BIC      r0,r0,#0xf
000200  4328              ORRS     r0,r0,r5
000202  f8c10220          STR      r0,[r1,#0x220]
;;;275    
;;;276        /* Switch HCLK to new HCLK source */
;;;277        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
000206  4889              LDR      r0,|L1.1068|
000208  3810              SUBS     r0,r0,#0x10
00020a  6800              LDR      r0,[r0,#0]
00020c  f0200007          BIC      r0,r0,#7
000210  4320              ORRS     r0,r0,r4
000212  4986              LDR      r1,|L1.1068|
000214  3910              SUBS     r1,r1,#0x10
000216  6008              STR      r0,[r1,#0]
;;;278    
;;;279        /* Update System Core Clock */
;;;280        SystemCoreClockUpdate();
000218  f7fffffe          BL       SystemCoreClockUpdate
;;;281    
;;;282        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;283        if(u32HIRCSTB == 0)
00021c  b946              CBNZ     r6,|L1.560|
;;;284            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
00021e  4883              LDR      r0,|L1.1068|
000220  3820              SUBS     r0,r0,#0x20
000222  6800              LDR      r0,[r0,#0]
000224  f0200004          BIC      r0,r0,#4
000228  f04f4180          MOV      r1,#0x40000000
00022c  f8c10200          STR      r0,[r1,#0x200]
                  |L1.560|
;;;285    }
000230  bd70              POP      {r4-r6,pc}
;;;286    
                          ENDP

                  CLK_DisablePLL PROC
;;;665      */
;;;666    void CLK_DisablePLL(void)
000232  487e              LDR      r0,|L1.1068|
;;;667    {
;;;668        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000234  3020              ADDS     r0,r0,#0x20
000236  6800              LDR      r0,[r0,#0]
000238  f4403080          ORR      r0,r0,#0x10000
00023c  f04f4180          MOV      r1,#0x40000000
000240  f8c10240          STR      r0,[r1,#0x240]
;;;669    }
000244  4770              BX       lr
;;;670    
                          ENDP

                  CLK_EnablePLL PROC
;;;541      */
;;;542    unsigned int CLK_EnablePLL(unsigned int u32PllClkSrc, unsigned int u32PllFreq)
000246  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;543    {
00024a  b085              SUB      sp,sp,#0x14
00024c  460c              MOV      r4,r1
;;;544        unsigned int u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC;
;;;545        unsigned int u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR;
;;;546    
;;;547        /* Disable PLL first to avoid unstable when setting PLL */
;;;548        CLK_DisablePLL();
00024e  f7fffffe          BL       CLK_DisablePLL
;;;549    
;;;550        /* PLL source clock is from HXT */
;;;551        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
000252  9805              LDR      r0,[sp,#0x14]
000254  b988              CBNZ     r0,|L1.634|
;;;552        {
;;;553            /* Enable HXT clock */
;;;554            CLK->PWRCTL |= CLK_PWRCTL_HXTEN_Msk;
000256  4875              LDR      r0,|L1.1068|
000258  3820              SUBS     r0,r0,#0x20
00025a  6800              LDR      r0,[r0,#0]
00025c  f0400001          ORR      r0,r0,#1
000260  f04f4180          MOV      r1,#0x40000000
000264  f8c10200          STR      r0,[r1,#0x200]
;;;555    
;;;556            /* Wait for HXT clock ready */
;;;557            CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
000268  2001              MOVS     r0,#1
00026a  f7fffffe          BL       CLK_WaitClockReady
;;;558    
;;;559            /* Select PLL source clock from HXT */
;;;560            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
00026e  f04f0b00          MOV      r11,#0
;;;561            u32PllSrcClk = __HXT;
000272  f8df81c0          LDR      r8,|L1.1076|
;;;562    
;;;563            /* u32NR start from 2 */
;;;564            u32NR = 2;
000276  2502              MOVS     r5,#2
000278  e010              B        |L1.668|
                  |L1.634|
;;;565        }
;;;566    
;;;567        /* PLL source clock is from HIRC */
;;;568        else
;;;569        {
;;;570            /* Enable HIRC clock */
;;;571            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00027a  486c              LDR      r0,|L1.1068|
00027c  3820              SUBS     r0,r0,#0x20
00027e  6800              LDR      r0,[r0,#0]
000280  f0400004          ORR      r0,r0,#4
000284  f04f4180          MOV      r1,#0x40000000
000288  f8c10200          STR      r0,[r1,#0x200]
;;;572    
;;;573            /* Wait for HIRC clock ready */
;;;574            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00028c  2010              MOVS     r0,#0x10
00028e  f7fffffe          BL       CLK_WaitClockReady
;;;575    
;;;576            /* Select PLL source clock from HIRC */
;;;577            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC;
000292  f44f2b00          MOV      r11,#0x80000
;;;578            u32PllSrcClk = __HIRC;
000296  f8df81a8          LDR      r8,|L1.1088|
;;;579    
;;;580            /* u32NR start from 4 when FIN = 22.1184MHz to avoid calculation overflow */
;;;581            u32NR = 4;
00029a  2504              MOVS     r5,#4
                  |L1.668|
;;;582        }
;;;583    
;;;584        /* Select "NO" according to request frequency */
;;;585        if((u32PllFreq <= FREQ_500MHZ) && (u32PllFreq > FREQ_250MHZ))
00029c  4869              LDR      r0,|L1.1092|
00029e  4284              CMP      r4,r0
0002a0  d804              BHI      |L1.684|
0002a2  1040              ASRS     r0,r0,#1
0002a4  4284              CMP      r4,r0
0002a6  d901              BLS      |L1.684|
;;;586        {
;;;587            u32NO = 0;
0002a8  2700              MOVS     r7,#0
0002aa  e012              B        |L1.722|
                  |L1.684|
;;;588        }
;;;589        else if((u32PllFreq <= FREQ_250MHZ) && (u32PllFreq > FREQ_125MHZ))
0002ac  4866              LDR      r0,|L1.1096|
0002ae  4284              CMP      r4,r0
0002b0  d805              BHI      |L1.702|
0002b2  1040              ASRS     r0,r0,#1
0002b4  4284              CMP      r4,r0
0002b6  d902              BLS      |L1.702|
;;;590        {
;;;591            u32NO = 1;
0002b8  2701              MOVS     r7,#1
;;;592            u32PllFreq = u32PllFreq << 1;
0002ba  0064              LSLS     r4,r4,#1
0002bc  e009              B        |L1.722|
                  |L1.702|
;;;593        }
;;;594        else if((u32PllFreq <= FREQ_125MHZ) && (u32PllFreq >= FREQ_50MHZ))
0002be  4863              LDR      r0,|L1.1100|
0002c0  4284              CMP      r4,r0
0002c2  d805              BHI      |L1.720|
0002c4  4862              LDR      r0,|L1.1104|
0002c6  4284              CMP      r4,r0
0002c8  d302              BCC      |L1.720|
;;;595        {
;;;596            u32NO = 3;
0002ca  2703              MOVS     r7,#3
;;;597            u32PllFreq = u32PllFreq << 2;
0002cc  00a4              LSLS     r4,r4,#2
0002ce  e000              B        |L1.722|
                  |L1.720|
;;;598        }
;;;599        else
;;;600        {
;;;601            /* Wrong frequency request. Just return default setting. */
;;;602            goto lexit;
0002d0  e04e              B        |L1.880|
                  |L1.722|
;;;603        }
;;;604    
;;;605        /* Find best solution */
;;;606        u32Min = (unsigned int) - 1;
0002d2  f04f30ff          MOV      r0,#0xffffffff
0002d6  9003              STR      r0,[sp,#0xc]
;;;607        u32MinNR = 0;
0002d8  2000              MOVS     r0,#0
0002da  9001              STR      r0,[sp,#4]
;;;608        u32MinNF = 0;
0002dc  9002              STR      r0,[sp,#8]
;;;609        for(; u32NR <= 33; u32NR++)
0002de  e02c              B        |L1.826|
                  |L1.736|
;;;610        {
;;;611            u32Tmp = u32PllSrcClk / u32NR;
0002e0  fbb8faf5          UDIV     r10,r8,r5
;;;612            if((u32Tmp > 1600000) && (u32Tmp < 16000000))
0002e4  485b              LDR      r0,|L1.1108|
0002e6  4582              CMP      r10,r0
0002e8  d926              BLS      |L1.824|
0002ea  485b              LDR      r0,|L1.1112|
0002ec  4582              CMP      r10,r0
0002ee  d223              BCS      |L1.824|
;;;613            {
;;;614                for(u32NF = 2; u32NF <= 513; u32NF++)
0002f0  f04f0902          MOV      r9,#2
0002f4  e01b              B        |L1.814|
                  |L1.758|
;;;615                {
;;;616                    u32Tmp2 = u32Tmp * u32NF;
0002f6  fb0af609          MUL      r6,r10,r9
;;;617                    if((u32Tmp2 >= 200000000) && (u32Tmp2 <= 500000000))
0002fa  4858              LDR      r0,|L1.1116|
0002fc  4286              CMP      r6,r0
0002fe  d314              BCC      |L1.810|
000300  4850              LDR      r0,|L1.1092|
000302  4286              CMP      r6,r0
000304  d811              BHI      |L1.810|
;;;618                    {
;;;619                        u32Tmp3 = (u32Tmp2 > u32PllFreq) ? u32Tmp2 - u32PllFreq : u32PllFreq - u32Tmp2;
000306  42a6              CMP      r6,r4
000308  d901              BLS      |L1.782|
00030a  1b30              SUBS     r0,r6,r4
00030c  e000              B        |L1.784|
                  |L1.782|
00030e  1ba0              SUBS     r0,r4,r6
                  |L1.784|
000310  9004              STR      r0,[sp,#0x10]
;;;620                        if(u32Tmp3 < u32Min)
000312  e9dd1003          LDRD     r1,r0,[sp,#0xc]
000316  4288              CMP      r0,r1
000318  d207              BCS      |L1.810|
;;;621                        {
;;;622                            u32Min = u32Tmp3;
00031a  9804              LDR      r0,[sp,#0x10]
00031c  9003              STR      r0,[sp,#0xc]
;;;623                            u32MinNR = u32NR;
00031e  9501              STR      r5,[sp,#4]
;;;624                            u32MinNF = u32NF;
000320  f8cd9008          STR      r9,[sp,#8]
;;;625    
;;;626                            /* Break when get good results */
;;;627                            if(u32Min == 0)
000324  9803              LDR      r0,[sp,#0xc]
000326  b900              CBNZ     r0,|L1.810|
;;;628                                break;
000328  e005              B        |L1.822|
                  |L1.810|
00032a  f1090901          ADD      r9,r9,#1              ;614
                  |L1.814|
00032e  f2402001          MOV      r0,#0x201             ;614
000332  4581              CMP      r9,r0                 ;614
000334  d9df              BLS      |L1.758|
                  |L1.822|
000336  bf00              NOP      
                  |L1.824|
000338  1c6d              ADDS     r5,r5,#1              ;609
                  |L1.826|
00033a  2d21              CMP      r5,#0x21              ;609
00033c  d9d0              BLS      |L1.736|
;;;629                        }
;;;630                    }
;;;631                }
;;;632            }
;;;633        }
;;;634    
;;;635        /* Enable and apply new PLL setting. */
;;;636        CLK->PLLCTL = u32CLK_SRC | (u32NO << 14) | ((u32MinNR - 2) << 9) | (u32MinNF - 2);
00033e  ea4b3187          ORR      r1,r11,r7,LSL #14
000342  9801              LDR      r0,[sp,#4]
000344  1e80              SUBS     r0,r0,#2
000346  ea412140          ORR      r1,r1,r0,LSL #9
00034a  9802              LDR      r0,[sp,#8]
00034c  1e80              SUBS     r0,r0,#2
00034e  4301              ORRS     r1,r1,r0
000350  4836              LDR      r0,|L1.1068|
000352  3020              ADDS     r0,r0,#0x20
000354  6001              STR      r1,[r0,#0]
;;;637    
;;;638        /* Wait for PLL clock stable */
;;;639        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
000356  2004              MOVS     r0,#4
000358  f7fffffe          BL       CLK_WaitClockReady
;;;640    
;;;641        /* Return actual PLL output clock frequency */
;;;642        return u32PllSrcClk / ((u32NO + 1) * u32MinNR) * u32MinNF;
00035c  1c78              ADDS     r0,r7,#1
00035e  9901              LDR      r1,[sp,#4]
000360  4348              MULS     r0,r1,r0
000362  fbb8f0f0          UDIV     r0,r8,r0
000366  9902              LDR      r1,[sp,#8]
000368  4348              MULS     r0,r1,r0
                  |L1.874|
;;;643    
;;;644    lexit:
;;;645    
;;;646        /* Apply default PLL setting and return */
;;;647        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;648            CLK->PLLCTL = CLK_PLLCTL_72MHz_HXT; /* 72MHz */
;;;649        else
;;;650            CLK->PLLCTL = CLK_PLLCTL_72MHz_HIRC; /* 71.8848MHz */
;;;651    
;;;652        /* Wait for PLL clock stable */
;;;653        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;654    
;;;655        return CLK_GetPLLClockFreq();
;;;656    
;;;657    }
00036a  b007              ADD      sp,sp,#0x1c
00036c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.880|
000370  9805              LDR      r0,[sp,#0x14]         ;647
000372  b928              CBNZ     r0,|L1.896|
000374  f24c002e          MOV      r0,#0xc02e            ;648
000378  492c              LDR      r1,|L1.1068|
00037a  3120              ADDS     r1,r1,#0x20           ;648
00037c  6008              STR      r0,[r1,#0]            ;648
00037e  e003              B        |L1.904|
                  |L1.896|
000380  4837              LDR      r0,|L1.1120|
000382  492a              LDR      r1,|L1.1068|
000384  3120              ADDS     r1,r1,#0x20           ;650
000386  6008              STR      r0,[r1,#0]            ;650
                  |L1.904|
000388  2004              MOVS     r0,#4                 ;653
00038a  f7fffffe          BL       CLK_WaitClockReady
00038e  f7fffffe          BL       CLK_GetPLLClockFreq
000392  e7ea              B        |L1.874|
;;;658    
                          ENDP

                  CLK_SetCoreClock PROC
;;;200      */
;;;201    unsigned int CLK_SetCoreClock(unsigned int u32Hclk)
000394  b570              PUSH     {r4-r6,lr}
;;;202    {
000396  4604              MOV      r4,r0
;;;203        unsigned int u32HIRCSTB;
;;;204    
;;;205        /* Read HIRC clock source stable flag */
;;;206        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000398  4824              LDR      r0,|L1.1068|
00039a  3030              ADDS     r0,r0,#0x30
00039c  6800              LDR      r0,[r0,#0]
00039e  f0000510          AND      r5,r0,#0x10
;;;207    
;;;208        /* The range of u32Hclk is 25 MHz ~ 72 MHz */
;;;209        if(u32Hclk > FREQ_72MHZ)
0003a2  4830              LDR      r0,|L1.1124|
0003a4  4284              CMP      r4,r0
0003a6  d900              BLS      |L1.938|
;;;210            u32Hclk = FREQ_72MHZ;
0003a8  4604              MOV      r4,r0
                  |L1.938|
;;;211        if(u32Hclk < FREQ_25MHZ)
0003aa  482f              LDR      r0,|L1.1128|
0003ac  4284              CMP      r4,r0
0003ae  d200              BCS      |L1.946|
;;;212            u32Hclk = FREQ_25MHZ;
0003b0  4604              MOV      r4,r0
                  |L1.946|
;;;213    
;;;214        /* Switch HCLK clock source to HIRC clock for safe */
;;;215        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
0003b2  481e              LDR      r0,|L1.1068|
0003b4  3820              SUBS     r0,r0,#0x20
0003b6  6800              LDR      r0,[r0,#0]
0003b8  f0400004          ORR      r0,r0,#4
0003bc  f04f4180          MOV      r1,#0x40000000
0003c0  f8c10200          STR      r0,[r1,#0x200]
;;;216        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
0003c4  2010              MOVS     r0,#0x10
0003c6  f7fffffe          BL       CLK_WaitClockReady
;;;217        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
0003ca  f04f4080          MOV      r0,#0x40000000
0003ce  f8d00210          LDR      r0,[r0,#0x210]
0003d2  f0400007          ORR      r0,r0,#7
0003d6  f04f4180          MOV      r1,#0x40000000
0003da  f8c10210          STR      r0,[r1,#0x210]
;;;218        CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
0003de  4608              MOV      r0,r1
0003e0  f8d00220          LDR      r0,[r0,#0x220]
0003e4  f020000f          BIC      r0,r0,#0xf
0003e8  f8c10220          STR      r0,[r1,#0x220]
;;;219    
;;;220        /* Configure PLL setting if HXT clock is stable */
;;;221        if(CLK->STATUS & CLK_STATUS_HXTSTB_Msk)
0003ec  480f              LDR      r0,|L1.1068|
0003ee  3030              ADDS     r0,r0,#0x30
0003f0  6800              LDR      r0,[r0,#0]
0003f2  f0000001          AND      r0,r0,#1
0003f6  b128              CBZ      r0,|L1.1028|
;;;222            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, (u32Hclk << 1));
0003f8  0061              LSLS     r1,r4,#1
0003fa  2000              MOVS     r0,#0
0003fc  f7fffffe          BL       CLK_EnablePLL
000400  4604              MOV      r4,r0
000402  e00a              B        |L1.1050|
                  |L1.1028|
;;;223    
;;;224        /* Configure PLL setting if HXT clock is not stable */
;;;225        else
;;;226        {
;;;227            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC, (u32Hclk << 1));
000404  0061              LSLS     r1,r4,#1
000406  f44f2000          MOV      r0,#0x80000
00040a  f7fffffe          BL       CLK_EnablePLL
00040e  4604              MOV      r4,r0
;;;228    
;;;229            /* Read HIRC clock source stable flag */
;;;230            u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000410  4806              LDR      r0,|L1.1068|
000412  3030              ADDS     r0,r0,#0x30
000414  6800              LDR      r0,[r0,#0]
000416  f0000510          AND      r5,r0,#0x10
                  |L1.1050|
;;;231        }
;;;232    
;;;233        /* Select HCLK clock source to PLL,
;;;234           Select HCLK clock source divider as 2
;;;235           and update system core clock
;;;236        */
;;;237        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(2));
00041a  2101              MOVS     r1,#1
00041c  2002              MOVS     r0,#2
00041e  f7fffffe          BL       CLK_SetHCLK
;;;238    
;;;239        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;240        if(u32HIRCSTB == 0)
000422  bb5d              CBNZ     r5,|L1.1148|
;;;241            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000424  4801              LDR      r0,|L1.1068|
000426  e021              B        |L1.1132|
                  |L1.1064|
                          DCD      0x57c00006
                  |L1.1068|
                          DCD      0x40000220
                  |L1.1072|
                          DCD      0xe000ed10
                  |L1.1076|
                          DCD      0x00b71b00
                  |L1.1080|
                          DCD      SystemCoreClock
                  |L1.1084|
                          DCD      0x0020f580
                  |L1.1088|
                          DCD      0x01518000
                  |L1.1092|
                          DCD      0x1dcd6500
                  |L1.1096|
                          DCD      0x0ee6b280
                  |L1.1100|
                          DCD      0x07735940
                  |L1.1104|
                          DCD      0x02faf080
                  |L1.1108|
                          DCD      0x00186a00
                  |L1.1112|
                          DCD      0x00f42400
                  |L1.1116|
                          DCD      0x0bebc200
                  |L1.1120|
                          DCD      0x0008c432
                  |L1.1124|
                          DCD      0x044aa200
                  |L1.1128|
                          DCD      0x017d7840
                  |L1.1132|
00046c  3820              SUBS     r0,r0,#0x20
00046e  6800              LDR      r0,[r0,#0]
000470  f0200004          BIC      r0,r0,#4
000474  f04f4180          MOV      r1,#0x40000000
000478  f8c10200          STR      r0,[r1,#0x200]
                  |L1.1148|
;;;242    
;;;243        /* Return actually HCLK frequency is PLL frequency divide 2 */
;;;244        return u32Hclk >> 1;
00047c  0860              LSRS     r0,r4,#1
;;;245    }
00047e  bd70              POP      {r4-r6,pc}
;;;246    
                          ENDP

                  CLK_SetSysTickClockSrc PROC
;;;406      */
;;;407    void CLK_SetSysTickClockSrc(unsigned int u32ClkSrc)
000480  4936              LDR      r1,|L1.1372|
;;;408    {
;;;409        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000482  6809              LDR      r1,[r1,#0]
000484  f0210138          BIC      r1,r1,#0x38
000488  4301              ORRS     r1,r1,r0
00048a  f04f4280          MOV      r2,#0x40000000
00048e  f8c21210          STR      r1,[r2,#0x210]
;;;410    
;;;411    }
000492  4770              BX       lr
;;;412    
                          ENDP

                  CLK_EnableXtalRC PROC
;;;423      */
;;;424    void CLK_EnableXtalRC(unsigned int u32ClkMask)
000494  4931              LDR      r1,|L1.1372|
;;;425    {
;;;426        CLK->PWRCTL |= u32ClkMask;
000496  3910              SUBS     r1,r1,#0x10
000498  6809              LDR      r1,[r1,#0]
00049a  4301              ORRS     r1,r1,r0
00049c  f04f4280          MOV      r2,#0x40000000
0004a0  f8c21200          STR      r1,[r2,#0x200]
;;;427    }
0004a4  4770              BX       lr
;;;428    
                          ENDP

                  CLK_DisableXtalRC PROC
;;;439      */
;;;440    void CLK_DisableXtalRC(unsigned int u32ClkMask)
0004a6  492d              LDR      r1,|L1.1372|
;;;441    {
;;;442        CLK->PWRCTL &= ~u32ClkMask;
0004a8  3910              SUBS     r1,r1,#0x10
0004aa  6809              LDR      r1,[r1,#0]
0004ac  4381              BICS     r1,r1,r0
0004ae  f04f4280          MOV      r2,#0x40000000
0004b2  f8c21200          STR      r1,[r2,#0x200]
;;;443    }
0004b6  4770              BX       lr
;;;444    
                          ENDP

                  CLK_EnableSysTick PROC
;;;710      */
;;;711    void CLK_EnableSysTick(unsigned int u32ClkSrc, unsigned int u32Count) 
0004b8  2200              MOVS     r2,#0
;;;712    {
;;;713        /* Set System Tick counter disabled */
;;;714        SysTick->CTRL = 0;    
0004ba  f04f23e0          MOV      r3,#0xe000e000
0004be  611a              STR      r2,[r3,#0x10]
;;;715    
;;;716        /* Set System Tick clock source */
;;;717        if( u32ClkSrc == CLK_CLKSEL0_STCLKSEL_HCLK )         
0004c0  2804              CMP      r0,#4
0004c2  d105              BNE      |L1.1232|
;;;718            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
0004c4  461a              MOV      r2,r3
0004c6  6912              LDR      r2,[r2,#0x10]
0004c8  f0420204          ORR      r2,r2,#4
0004cc  611a              STR      r2,[r3,#0x10]
0004ce  e008              B        |L1.1250|
                  |L1.1232|
;;;719        else
;;;720            CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc; 
0004d0  4a22              LDR      r2,|L1.1372|
0004d2  6812              LDR      r2,[r2,#0]
0004d4  f0220238          BIC      r2,r2,#0x38
0004d8  4302              ORRS     r2,r2,r0
0004da  f04f4380          MOV      r3,#0x40000000
0004de  f8c32210          STR      r2,[r3,#0x210]
                  |L1.1250|
;;;721    
;;;722        /* Set System Tick reload value */
;;;723        SysTick->LOAD = u32Count;   
0004e2  f04f22e0          MOV      r2,#0xe000e000
0004e6  6151              STR      r1,[r2,#0x14]
;;;724        
;;;725        /* Clear System Tick current value and counter flag */
;;;726        SysTick->VAL = 0;           
0004e8  2200              MOVS     r2,#0
0004ea  f04f23e0          MOV      r3,#0xe000e000
0004ee  619a              STR      r2,[r3,#0x18]
;;;727        
;;;728        /* Set System Tick interrupt enabled and counter enabled */    
;;;729        SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;       
0004f0  461a              MOV      r2,r3
0004f2  6912              LDR      r2,[r2,#0x10]
0004f4  f0420203          ORR      r2,r2,#3
0004f8  611a              STR      r2,[r3,#0x10]
;;;730    }
0004fa  4770              BX       lr
;;;731    
                          ENDP

                  CLK_DisableSysTick PROC
;;;737      */
;;;738    void CLK_DisableSysTick(void) 
0004fc  2000              MOVS     r0,#0
;;;739    {    
;;;740        /* Set System Tick counter disabled */
;;;741    	SysTick->CTRL = 0;    
0004fe  f04f21e0          MOV      r1,#0xe000e000
000502  6108              STR      r0,[r1,#0x10]
;;;742    }
000504  4770              BX       lr
;;;743    
                          ENDP

                  CLK_GetPLLClockFreq PROC
;;;357      */
;;;358    __STATIC_INLINE unsigned int CLK_GetPLLClockFreq(void)
000506  b5f8              PUSH     {r3-r7,lr}
;;;359    {
;;;360        unsigned int u32PllFreq = 0, u32PllReg;
000508  2600              MOVS     r6,#0
;;;361        unsigned int u32FIN, u32NF, u32NR, u32NO;
;;;362        unsigned char au8NoTbl[4] = {1, 2, 2, 4};
00050a  a015              ADR      r0,|L1.1376|
00050c  6800              LDR      r0,[r0,#0]
00050e  9000              STR      r0,[sp,#0]
;;;363    
;;;364        u32PllReg = CLK->PLLCTL;
000510  4812              LDR      r0,|L1.1372|
000512  3030              ADDS     r0,r0,#0x30
000514  6801              LDR      r1,[r0,#0]
;;;365    
;;;366        if(u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
000516  f40120a0          AND      r0,r1,#0x50000
00051a  b108              CBZ      r0,|L1.1312|
;;;367            return 0;           /* PLL is in power down mode or fix low */
00051c  2000              MOVS     r0,#0
                  |L1.1310|
;;;368    
;;;369        if(u32PllReg & CLK_PLLCTL_PLLSRC_HIRC)
;;;370            u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;371        else
;;;372            u32FIN = __HXT;     /* PLL source clock from HXT */
;;;373    
;;;374        if(u32PllReg & CLK_PLLCTL_BP_Msk)
;;;375            return u32FIN;      /* PLL is in bypass mode */
;;;376    
;;;377        /* PLL is output enabled in normal work mode */
;;;378        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;379        u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
;;;380        u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
;;;381    
;;;382        /* u32FIN is shifted 2 bits to avoid overflow */
;;;383        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;384    
;;;385        return u32PllFreq;
;;;386    }
00051e  bdf8              POP      {r3-r7,pc}
                  |L1.1312|
000520  f4012000          AND      r0,r1,#0x80000        ;369
000524  b108              CBZ      r0,|L1.1322|
000526  4a0f              LDR      r2,|L1.1380|
000528  e000              B        |L1.1324|
                  |L1.1322|
00052a  4a0f              LDR      r2,|L1.1384|
                  |L1.1324|
00052c  f4013000          AND      r0,r1,#0x20000        ;374
000530  b108              CBZ      r0,|L1.1334|
000532  4610              MOV      r0,r2                 ;375
000534  e7f3              B        |L1.1310|
                  |L1.1334|
000536  f3c13781          UBFX     r7,r1,#14,#2          ;378
00053a  f81d4007          LDRB     r4,[sp,r7]            ;378
00053e  f3c10008          UBFX     r0,r1,#0,#9           ;379
000542  1c83              ADDS     r3,r0,#2              ;379
000544  f3c12044          UBFX     r0,r1,#9,#5           ;380
000548  1c85              ADDS     r5,r0,#2              ;380
00054a  0890              LSRS     r0,r2,#2              ;383
00054c  4358              MULS     r0,r3,r0              ;383
00054e  fb15f704          SMULBB   r7,r5,r4              ;383
000552  fbb0f0f7          UDIV     r0,r0,r7              ;383
000556  0086              LSLS     r6,r0,#2              ;383
000558  4630              MOV      r0,r6                 ;385
00055a  e7e0              B        |L1.1310|
;;;387    
                          ENDP

                  |L1.1372|
                          DCD      0x40000210
                  |L1.1376|
000560  01020204          DCB      1,2,2,4
                  |L1.1380|
                          DCD      0x01518000
                  |L1.1384|
                          DCD      0x00b71b00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 114 "..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 128
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
