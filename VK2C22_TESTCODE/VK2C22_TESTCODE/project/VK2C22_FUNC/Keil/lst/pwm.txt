; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\pwm.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\pwm.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M451Series\Include -I..\..\..\Library\StdDriver\inc -I..\Bsp -I..\User -I..\lcd_driver -I..\exti_driver -I..\led_driver -I..\touch -I..\dotmatix_lcd -I..\KH -I.\RTE\_project -ID:\KEIL_STM32\Packs\ARM\CMSIS\6.1.0\CMSIS\Core\Include -D__UVISION_VERSION=541 -D_RTE_ --omf_browse=.\obj\pwm.crf ..\..\..\Library\StdDriver\src\pwm.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;357      */
;;;358    __STATIC_INLINE unsigned int CLK_GetPLLClockFreq(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;359    {
;;;360        unsigned int u32PllFreq = 0, u32PllReg;
000002  2600              MOVS     r6,#0
;;;361        unsigned int u32FIN, u32NF, u32NR, u32NO;
;;;362        unsigned char au8NoTbl[4] = {1, 2, 2, 4};
000004  a0f8              ADR      r0,|L1.1000|
000006  6800              LDR      r0,[r0,#0]
000008  9000              STR      r0,[sp,#0]
;;;363    
;;;364        u32PllReg = CLK->PLLCTL;
00000a  48f8              LDR      r0,|L1.1004|
00000c  6801              LDR      r1,[r0,#0]
;;;365    
;;;366        if(u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
00000e  f40120a0          AND      r0,r1,#0x50000
000012  b108              CBZ      r0,|L1.24|
;;;367            return 0;           /* PLL is in power down mode or fix low */
000014  2000              MOVS     r0,#0
                  |L1.22|
;;;368    
;;;369        if(u32PllReg & CLK_PLLCTL_PLLSRC_HIRC)
;;;370            u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;371        else
;;;372            u32FIN = __HXT;     /* PLL source clock from HXT */
;;;373    
;;;374        if(u32PllReg & CLK_PLLCTL_BP_Msk)
;;;375            return u32FIN;      /* PLL is in bypass mode */
;;;376    
;;;377        /* PLL is output enabled in normal work mode */
;;;378        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;379        u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
;;;380        u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
;;;381    
;;;382        /* u32FIN is shifted 2 bits to avoid overflow */
;;;383        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;384    
;;;385        return u32PllFreq;
;;;386    }
000016  bdf8              POP      {r3-r7,pc}
                  |L1.24|
000018  f4012000          AND      r0,r1,#0x80000        ;369
00001c  b108              CBZ      r0,|L1.34|
00001e  4af4              LDR      r2,|L1.1008|
000020  e000              B        |L1.36|
                  |L1.34|
000022  4af4              LDR      r2,|L1.1012|
                  |L1.36|
000024  f4013000          AND      r0,r1,#0x20000        ;374
000028  b108              CBZ      r0,|L1.46|
00002a  4610              MOV      r0,r2                 ;375
00002c  e7f3              B        |L1.22|
                  |L1.46|
00002e  f3c13781          UBFX     r7,r1,#14,#2          ;378
000032  f81d4007          LDRB     r4,[sp,r7]            ;378
000036  f3c10008          UBFX     r0,r1,#0,#9           ;379
00003a  1c83              ADDS     r3,r0,#2              ;379
00003c  f3c12044          UBFX     r0,r1,#9,#5           ;380
000040  1c85              ADDS     r5,r0,#2              ;380
000042  0890              LSRS     r0,r2,#2              ;383
000044  4358              MULS     r0,r3,r0              ;383
000046  fb15f704          SMULBB   r7,r5,r4              ;383
00004a  fbb0f0f7          UDIV     r0,r0,r7              ;383
00004e  0086              LSLS     r6,r0,#2              ;383
000050  4630              MOV      r0,r6                 ;385
000052  e7e0              B        |L1.22|
;;;387    
                          ENDP

                  PWM_ConfigCaptureChannel PROC
;;;36      */
;;;37     uint32_t PWM_ConfigCaptureChannel(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32UnitTimeNsec, uint32_t u32CaptureEdge)
000054  e92d5ff0          PUSH     {r4-r12,lr}
;;;38     {
000058  4604              MOV      r4,r0
00005a  460d              MOV      r5,r1
00005c  4692              MOV      r10,r2
;;;39         uint32_t u32Src;
;;;40         uint32_t u32PWMClockSrc;
;;;41         uint32_t u32NearestUnitTimeNsec;
;;;42         uint16_t u16Prescale = 1, u16CNR = 0xFFFF;
00005e  2701              MOVS     r7,#1
000060  f64f7bff          MOV      r11,#0xffff
;;;43     
;;;44         if(pwm == PWM0)
000064  48e4              LDR      r0,|L1.1016|
000066  4284              CMP      r4,r0
000068  d105              BNE      |L1.118|
;;;45             u32Src = CLK->CLKSEL2 & CLK_CLKSEL2_PWM0SEL_Msk;
00006a  48e0              LDR      r0,|L1.1004|
00006c  3828              SUBS     r0,r0,#0x28
00006e  6800              LDR      r0,[r0,#0]
000070  f0000901          AND      r9,r0,#1
000074  e004              B        |L1.128|
                  |L1.118|
;;;46         else//(pwm == PWM1)
;;;47             u32Src = CLK->CLKSEL2 & CLK_CLKSEL2_PWM1SEL_Msk;
000076  48dd              LDR      r0,|L1.1004|
000078  3828              SUBS     r0,r0,#0x28
00007a  6800              LDR      r0,[r0,#0]
00007c  f0000902          AND      r9,r0,#2
                  |L1.128|
;;;48     
;;;49         if(u32Src == 0)
000080  f1b90f00          CMP      r9,#0
000084  d103              BNE      |L1.142|
;;;50         {
;;;51             //clock source is from PLL clock
;;;52             u32PWMClockSrc = CLK_GetPLLClockFreq();
000086  f7fffffe          BL       CLK_GetPLLClockFreq
00008a  4606              MOV      r6,r0
00008c  e003              B        |L1.150|
                  |L1.142|
;;;53         }
;;;54         else
;;;55         {
;;;56             //clock source is from PCLK
;;;57             SystemCoreClockUpdate();
00008e  f7fffffe          BL       SystemCoreClockUpdate
;;;58             u32PWMClockSrc = SystemCoreClock;
000092  48da              LDR      r0,|L1.1020|
000094  6806              LDR      r6,[r0,#0]  ; SystemCoreClock
                  |L1.150|
;;;59         }
;;;60     
;;;61         u32PWMClockSrc /= 1000;
000096  f44f707a          MOV      r0,#0x3e8
00009a  fbb6f6f0          UDIV     r6,r6,r0
;;;62         for(u16Prescale = 1; u16Prescale <= 0x1000; u16Prescale++)
00009e  2701              MOVS     r7,#1
0000a0  e015              B        |L1.206|
                  |L1.162|
;;;63         {
;;;64             u32NearestUnitTimeNsec = (1000000 * u16Prescale) / u32PWMClockSrc;
0000a2  48d7              LDR      r0,|L1.1024|
0000a4  4378              MULS     r0,r7,r0
0000a6  fbb0f8f6          UDIV     r8,r0,r6
;;;65             if(u32NearestUnitTimeNsec < u32UnitTimeNsec)
0000aa  45d0              CMP      r8,r10
0000ac  d20c              BCS      |L1.200|
;;;66             {
;;;67                 if(u16Prescale == 0x1000)  //limit to the maximum unit time(nano second)
0000ae  f5b75f80          CMP      r7,#0x1000
0000b2  d100              BNE      |L1.182|
;;;68                     break;
0000b4  e00e              B        |L1.212|
                  |L1.182|
;;;69                 if(!((1000000 * (u16Prescale + 1) > (u32NearestUnitTimeNsec * u32PWMClockSrc))))
0000b6  1c78              ADDS     r0,r7,#1
0000b8  49d1              LDR      r1,|L1.1024|
0000ba  4348              MULS     r0,r1,r0
0000bc  fb08f106          MUL      r1,r8,r6
0000c0  4288              CMP      r0,r1
0000c2  d800              BHI      |L1.198|
;;;70                     break;
0000c4  e006              B        |L1.212|
                  |L1.198|
;;;71                 continue;
0000c6  e000              B        |L1.202|
                  |L1.200|
;;;72             }
;;;73             break;
0000c8  e004              B        |L1.212|
                  |L1.202|
0000ca  1c78              ADDS     r0,r7,#1              ;62
0000cc  b287              UXTH     r7,r0                 ;62
                  |L1.206|
0000ce  f5b75f80          CMP      r7,#0x1000            ;62
0000d2  dde6              BLE      |L1.162|
                  |L1.212|
0000d4  bf00              NOP                            ;68
;;;74         }
;;;75     
;;;76         // convert to real register value
;;;77         // every two channels share a prescaler
;;;78         PWM_SET_PRESCALER(pwm, u32ChannelNum, --u16Prescale);
0000d6  1e78              SUBS     r0,r7,#1
0000d8  b281              UXTH     r1,r0
0000da  460f              MOV      r7,r1
0000dc  086a              LSRS     r2,r5,#1
0000de  f1040014          ADD      r0,r4,#0x14
0000e2  f8401022          STR      r1,[r0,r2,LSL #2]
;;;79     
;;;80         // set PWM to down count type(edge aligned)
;;;81         (pwm)->CTL1 = ((pwm)->CTL1 & ~(PWM_CTL1_CNTTYPE0_Msk << (2 * u32ChannelNum))) | (1UL << (2 * u32ChannelNum));
0000e6  6860              LDR      r0,[r4,#4]
0000e8  006a              LSLS     r2,r5,#1
0000ea  2103              MOVS     r1,#3
0000ec  4091              LSLS     r1,r1,r2
0000ee  4388              BICS     r0,r0,r1
0000f0  006a              LSLS     r2,r5,#1
0000f2  2101              MOVS     r1,#1
0000f4  4091              LSLS     r1,r1,r2
0000f6  4308              ORRS     r0,r0,r1
0000f8  6060              STR      r0,[r4,#4]
;;;82         // set PWM to auto-reload mode
;;;83         (pwm)->CTL1 &= ~(PWM_CTL1_CNTMODE0_Msk << u32ChannelNum);
0000fa  6860              LDR      r0,[r4,#4]
0000fc  f44f3180          MOV      r1,#0x10000
000100  40a9              LSLS     r1,r1,r5
000102  4388              BICS     r0,r0,r1
000104  6060              STR      r0,[r4,#4]
;;;84         PWM_SET_CNR(pwm, u32ChannelNum, u16CNR);
000106  f1040030          ADD      r0,r4,#0x30
00010a  f840b025          STR      r11,[r0,r5,LSL #2]
;;;85     
;;;86         return (u32NearestUnitTimeNsec);
00010e  4640              MOV      r0,r8
;;;87     }
000110  e8bd9ff0          POP      {r4-r12,pc}
;;;88     
                          ENDP

                  PWM_ConfigOutputChannel PROC
;;;100     */
;;;101    uint32_t PWM_ConfigOutputChannel(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Frequency, uint32_t u32DutyCycle)
000114  e92d5fff          PUSH     {r0-r12,lr}
;;;102    {
000118  4604              MOV      r4,r0
00011a  460d              MOV      r5,r1
00011c  4699              MOV      r9,r3
;;;103        uint32_t u32Src;
;;;104        uint32_t u32PWMClockSrc;
;;;105        uint32_t i;
;;;106        uint16_t u16Prescale = 1, u16CNR = 0xFFFF;
00011e  2701              MOVS     r7,#1
000120  f64f7bff          MOV      r11,#0xffff
;;;107    
;;;108        if(pwm == PWM0)
000124  48b4              LDR      r0,|L1.1016|
000126  4284              CMP      r4,r0
000128  d105              BNE      |L1.310|
;;;109            u32Src = CLK->CLKSEL2 & CLK_CLKSEL2_PWM0SEL_Msk;
00012a  48b0              LDR      r0,|L1.1004|
00012c  3828              SUBS     r0,r0,#0x28
00012e  6800              LDR      r0,[r0,#0]
000130  f0000a01          AND      r10,r0,#1
000134  e004              B        |L1.320|
                  |L1.310|
;;;110        else//(pwm == PWM1)
;;;111            u32Src = CLK->CLKSEL2 & CLK_CLKSEL2_PWM1SEL_Msk;
000136  48ad              LDR      r0,|L1.1004|
000138  3828              SUBS     r0,r0,#0x28
00013a  6800              LDR      r0,[r0,#0]
00013c  f0000a02          AND      r10,r0,#2
                  |L1.320|
;;;112    
;;;113        if(u32Src == 0)
000140  f1ba0f00          CMP      r10,#0
000144  d103              BNE      |L1.334|
;;;114        {
;;;115            //clock source is from PLL clock
;;;116            u32PWMClockSrc = CLK_GetPLLClockFreq();
000146  f7fffffe          BL       CLK_GetPLLClockFreq
00014a  4606              MOV      r6,r0
00014c  e003              B        |L1.342|
                  |L1.334|
;;;117        }
;;;118        else
;;;119        {
;;;120            //clock source is from PCLK
;;;121            SystemCoreClockUpdate();
00014e  f7fffffe          BL       SystemCoreClockUpdate
;;;122            u32PWMClockSrc = SystemCoreClock;
000152  48aa              LDR      r0,|L1.1020|
000154  6806              LDR      r6,[r0,#0]  ; SystemCoreClock
                  |L1.342|
;;;123        }
;;;124    
;;;125        for(u16Prescale = 1; u16Prescale < 0xFFF; u16Prescale++)//prescale could be 0~0xFFF
000156  2701              MOVS     r7,#1
000158  e00d              B        |L1.374|
                  |L1.346|
;;;126        {
;;;127            i = (u32PWMClockSrc / u32Frequency) / u16Prescale;
00015a  9802              LDR      r0,[sp,#8]
00015c  fbb6f0f0          UDIV     r0,r6,r0
000160  fbb0f8f7          UDIV     r8,r0,r7
;;;128            // If target value is larger than CNR, need to use a larger prescaler
;;;129            if(i > (0x10000))
000164  f5b83f80          CMP      r8,#0x10000
000168  d900              BLS      |L1.364|
;;;130                continue;
00016a  e002              B        |L1.370|
                  |L1.364|
;;;131    
;;;132            u16CNR = i;
00016c  fa1ffb88          UXTH     r11,r8
;;;133            break;
000170  e005              B        |L1.382|
                  |L1.370|
000172  1c78              ADDS     r0,r7,#1              ;125
000174  b287              UXTH     r7,r0                 ;125
                  |L1.374|
000176  f64070ff          MOV      r0,#0xfff             ;125
00017a  4287              CMP      r7,r0                 ;125
00017c  dbed              BLT      |L1.346|
                  |L1.382|
00017e  bf00              NOP      
;;;134        }
;;;135        // Store return value here 'cos we're gonna change u16Prescale & u16CNR to the real value to fill into register
;;;136        i = u32PWMClockSrc / (u16Prescale * u16CNR);
000180  fb07f00b          MUL      r0,r7,r11
000184  fbb6f8f0          UDIV     r8,r6,r0
;;;137    
;;;138        // convert to real register value
;;;139        // every two channels share a prescaler
;;;140        PWM_SET_PRESCALER(pwm, u32ChannelNum, --u16Prescale);
000188  1e78              SUBS     r0,r7,#1
00018a  b281              UXTH     r1,r0
00018c  460f              MOV      r7,r1
00018e  086a              LSRS     r2,r5,#1
000190  f1040014          ADD      r0,r4,#0x14
000194  f8401022          STR      r1,[r0,r2,LSL #2]
;;;141        // set PWM to down count type(edge aligned)
;;;142        (pwm)->CTL1 = ((pwm)->CTL1 & ~(PWM_CTL1_CNTTYPE0_Msk << (2 * u32ChannelNum))) | (1UL << (2 * u32ChannelNum));
000198  6860              LDR      r0,[r4,#4]
00019a  006a              LSLS     r2,r5,#1
00019c  2103              MOVS     r1,#3
00019e  4091              LSLS     r1,r1,r2
0001a0  4388              BICS     r0,r0,r1
0001a2  006a              LSLS     r2,r5,#1
0001a4  2101              MOVS     r1,#1
0001a6  4091              LSLS     r1,r1,r2
0001a8  4308              ORRS     r0,r0,r1
0001aa  6060              STR      r0,[r4,#4]
;;;143        // set PWM to auto-reload mode
;;;144        (pwm)->CTL1 &= ~(PWM_CTL1_CNTMODE0_Msk << u32ChannelNum);
0001ac  6860              LDR      r0,[r4,#4]
0001ae  f44f3180          MOV      r1,#0x10000
0001b2  40a9              LSLS     r1,r1,r5
0001b4  4388              BICS     r0,r0,r1
0001b6  6060              STR      r0,[r4,#4]
;;;145    
;;;146        PWM_SET_CNR(pwm, u32ChannelNum, --u16CNR);
0001b8  f1ab0001          SUB      r0,r11,#1
0001bc  b281              UXTH     r1,r0
0001be  468b              MOV      r11,r1
0001c0  f1040030          ADD      r0,r4,#0x30
0001c4  f8401025          STR      r1,[r0,r5,LSL #2]
;;;147        if(u32DutyCycle)
0001c8  f1b90f00          CMP      r9,#0
0001cc  d02c              BEQ      |L1.552|
;;;148        {
;;;149            PWM_SET_CMR(pwm, u32ChannelNum, u32DutyCycle * (u16CNR + 1) / 100 - 1);
0001ce  f10b0001          ADD      r0,r11,#1
0001d2  fb09f000          MUL      r0,r9,r0
0001d6  2164              MOVS     r1,#0x64
0001d8  fbb0f0f1          UDIV     r0,r0,r1
0001dc  1e40              SUBS     r0,r0,#1
0001de  f1040150          ADD      r1,r4,#0x50
0001e2  f8410025          STR      r0,[r1,r5,LSL #2]
;;;150            (pwm)->WGCTL0 &= ~((PWM_WGCTL0_PRDPCTL0_Msk | PWM_WGCTL0_ZPCTL0_Msk) << (u32ChannelNum * 2));
0001e6  f8540fb0          LDR      r0,[r4,#0xb0]!
0001ea  006a              LSLS     r2,r5,#1
0001ec  f04f1103          MOV      r1,#0x30003
0001f0  4091              LSLS     r1,r1,r2
0001f2  4388              BICS     r0,r0,r1
0001f4  6020              STR      r0,[r4,#0]
;;;151            (pwm)->WGCTL0 |= (PWM_OUTPUT_LOW << (u32ChannelNum * 2 + PWM_WGCTL0_PRDPCTL0_Pos));
0001f6  6820              LDR      r0,[r4,#0]
0001f8  2110              MOVS     r1,#0x10
0001fa  eb010245          ADD      r2,r1,r5,LSL #1
0001fe  2101              MOVS     r1,#1
000200  4091              LSLS     r1,r1,r2
000202  4308              ORRS     r0,r0,r1
000204  6020              STR      r0,[r4,#0]
;;;152            (pwm)->WGCTL1 &= ~((PWM_WGCTL1_CMPDCTL0_Msk | PWM_WGCTL1_CMPUCTL0_Msk) << (u32ChannelNum * 2));
000206  6860              LDR      r0,[r4,#4]
000208  006a              LSLS     r2,r5,#1
00020a  f04f1103          MOV      r1,#0x30003
00020e  4091              LSLS     r1,r1,r2
000210  4388              BICS     r0,r0,r1
000212  6060              STR      r0,[r4,#4]
;;;153            (pwm)->WGCTL1 |= (PWM_OUTPUT_HIGH << (u32ChannelNum * 2 + PWM_WGCTL1_CMPDCTL0_Pos));
000214  6860              LDR      r0,[r4,#4]
000216  2110              MOVS     r1,#0x10
000218  eb010245          ADD      r2,r1,r5,LSL #1
00021c  2102              MOVS     r1,#2
00021e  4091              LSLS     r1,r1,r2
000220  4308              ORRS     r0,r0,r1
000222  6060              STR      r0,[r4,#4]
000224  3cb0              SUBS     r4,r4,#0xb0
000226  e024              B        |L1.626|
                  |L1.552|
;;;154        }
;;;155        else
;;;156        {
;;;157            PWM_SET_CMR(pwm, u32ChannelNum, 0);
000228  2100              MOVS     r1,#0
00022a  f1040050          ADD      r0,r4,#0x50
00022e  f8401025          STR      r1,[r0,r5,LSL #2]
;;;158            (pwm)->WGCTL0 &= ~((PWM_WGCTL0_PRDPCTL0_Msk | PWM_WGCTL0_ZPCTL0_Msk) << (u32ChannelNum * 2));
000232  f8540fb0          LDR      r0,[r4,#0xb0]!
000236  006a              LSLS     r2,r5,#1
000238  f04f1103          MOV      r1,#0x30003
00023c  4091              LSLS     r1,r1,r2
00023e  4388              BICS     r0,r0,r1
000240  6020              STR      r0,[r4,#0]
;;;159            (pwm)->WGCTL0 |= (PWM_OUTPUT_LOW << (u32ChannelNum * 2 + PWM_WGCTL0_ZPCTL0_Pos));
000242  6820              LDR      r0,[r4,#0]
000244  2100              MOVS     r1,#0
000246  eb010245          ADD      r2,r1,r5,LSL #1
00024a  2101              MOVS     r1,#1
00024c  4091              LSLS     r1,r1,r2
00024e  4308              ORRS     r0,r0,r1
000250  6020              STR      r0,[r4,#0]
;;;160            (pwm)->WGCTL1 &= ~((PWM_WGCTL1_CMPDCTL0_Msk | PWM_WGCTL1_CMPUCTL0_Msk) << (u32ChannelNum * 2));
000252  6860              LDR      r0,[r4,#4]
000254  006a              LSLS     r2,r5,#1
000256  f04f1103          MOV      r1,#0x30003
00025a  4091              LSLS     r1,r1,r2
00025c  4388              BICS     r0,r0,r1
00025e  6060              STR      r0,[r4,#4]
;;;161            (pwm)->WGCTL1 |= (PWM_OUTPUT_HIGH << (u32ChannelNum * 2 + PWM_WGCTL1_CMPDCTL0_Pos));
000260  6860              LDR      r0,[r4,#4]
000262  2110              MOVS     r1,#0x10
000264  eb010245          ADD      r2,r1,r5,LSL #1
000268  2102              MOVS     r1,#2
00026a  4091              LSLS     r1,r1,r2
00026c  4308              ORRS     r0,r0,r1
00026e  6060              STR      r0,[r4,#4]
000270  3cb0              SUBS     r4,r4,#0xb0
                  |L1.626|
;;;162        }
;;;163    
;;;164        return(i);
000272  4640              MOV      r0,r8
;;;165    }
000274  b004              ADD      sp,sp,#0x10
000276  e8bd9ff0          POP      {r4-r12,pc}
;;;166    
                          ENDP

                  PWM_Start PROC
;;;176     */
;;;177    void PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask)
00027a  6a02              LDR      r2,[r0,#0x20]
;;;178    {
;;;179        (pwm)->CNTEN |= u32ChannelMask;
00027c  430a              ORRS     r2,r2,r1
00027e  6202              STR      r2,[r0,#0x20]
;;;180    }
000280  4770              BX       lr
;;;181    
                          ENDP

                  PWM_Stop PROC
;;;191     */
;;;192    void PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask)
000282  b510              PUSH     {r4,lr}
;;;193    {
000284  4602              MOV      r2,r0
;;;194        uint32_t i;
;;;195        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000286  2000              MOVS     r0,#0
000288  e009              B        |L1.670|
                  |L1.650|
;;;196        {
;;;197            if(u32ChannelMask & (1 << i))
00028a  2301              MOVS     r3,#1
00028c  4083              LSLS     r3,r3,r0
00028e  400b              ANDS     r3,r3,r1
000290  b123              CBZ      r3,|L1.668|
;;;198            {
;;;199                (pwm)->PERIOD[i] = 0;
000292  2400              MOVS     r4,#0
000294  f1020330          ADD      r3,r2,#0x30
000298  f8434020          STR      r4,[r3,r0,LSL #2]
                  |L1.668|
00029c  1c40              ADDS     r0,r0,#1              ;195
                  |L1.670|
00029e  2806              CMP      r0,#6                 ;195
0002a0  d3f3              BCC      |L1.650|
;;;200            }
;;;201        }
;;;202    }
0002a2  bd10              POP      {r4,pc}
;;;203    
                          ENDP

                  PWM_ForceStop PROC
;;;213     */
;;;214    void PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask)
0002a4  6a02              LDR      r2,[r0,#0x20]
;;;215    {
;;;216        (pwm)->CNTEN &= ~u32ChannelMask;
0002a6  438a              BICS     r2,r2,r1
0002a8  6202              STR      r2,[r0,#0x20]
;;;217    }
0002aa  4770              BX       lr
;;;218    
                          ENDP

                  PWM_EnableADCTrigger PROC
;;;244     */
;;;245    void PWM_EnableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
0002ac  b530              PUSH     {r4,r5,lr}
;;;246    {
;;;247        if(u32ChannelNum < 4)
0002ae  2904              CMP      r1,#4
0002b0  d20f              BCS      |L1.722|
;;;248        {
;;;249            (pwm)->EADCTS0 &= ~((PWM_EADCTS0_TRGSEL0_Msk) << (u32ChannelNum * 8));
0002b2  f8503ff8          LDR      r3,[r0,#0xf8]!
0002b6  00cd              LSLS     r5,r1,#3
0002b8  240f              MOVS     r4,#0xf
0002ba  40ac              LSLS     r4,r4,r5
0002bc  43a3              BICS     r3,r3,r4
0002be  6003              STR      r3,[r0,#0]
;;;250            (pwm)->EADCTS0 |= ((PWM_EADCTS0_TRGEN0_Msk | u32Condition) << (u32ChannelNum * 8));
0002c0  f0420380          ORR      r3,r2,#0x80
0002c4  00cc              LSLS     r4,r1,#3
0002c6  40a3              LSLS     r3,r3,r4
0002c8  6804              LDR      r4,[r0,#0]
0002ca  4323              ORRS     r3,r3,r4
0002cc  f84039f8          STR      r3,[r0],#-0xf8
0002d0  e010              B        |L1.756|
                  |L1.722|
;;;251        }
;;;252        else
;;;253        {
;;;254            (pwm)->EADCTS1 &= ~((PWM_EADCTS1_TRGSEL4_Msk) << ((u32ChannelNum - 4) * 8));
0002d2  f8503ffc          LDR      r3,[r0,#0xfc]!
0002d6  1f0c              SUBS     r4,r1,#4
0002d8  00e5              LSLS     r5,r4,#3
0002da  240f              MOVS     r4,#0xf
0002dc  40ac              LSLS     r4,r4,r5
0002de  43a3              BICS     r3,r3,r4
0002e0  6003              STR      r3,[r0,#0]
;;;255            (pwm)->EADCTS1 |= ((PWM_EADCTS1_TRGEN4_Msk | u32Condition) << ((u32ChannelNum - 4) * 8));
0002e2  f0420380          ORR      r3,r2,#0x80
0002e6  1f0c              SUBS     r4,r1,#4
0002e8  00e4              LSLS     r4,r4,#3
0002ea  40a3              LSLS     r3,r3,r4
0002ec  6804              LDR      r4,[r0,#0]
0002ee  4323              ORRS     r3,r3,r4
0002f0  f84039fc          STR      r3,[r0],#-0xfc
                  |L1.756|
;;;256        }
;;;257    }
0002f4  bd30              POP      {r4,r5,pc}
;;;258    
                          ENDP

                  PWM_DisableADCTrigger PROC
;;;267     */
;;;268    void PWM_DisableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum)
0002f6  b510              PUSH     {r4,lr}
;;;269    {
;;;270        if(u32ChannelNum < 4)
0002f8  2904              CMP      r1,#4
0002fa  d208              BCS      |L1.782|
;;;271        {
;;;272            (pwm)->EADCTS0 &= ~(PWM_EADCTS0_TRGEN0_Msk << (u32ChannelNum * 8));
0002fc  f8d020f8          LDR      r2,[r0,#0xf8]
000300  00cc              LSLS     r4,r1,#3
000302  2380              MOVS     r3,#0x80
000304  40a3              LSLS     r3,r3,r4
000306  439a              BICS     r2,r2,r3
000308  f8c020f8          STR      r2,[r0,#0xf8]
00030c  e008              B        |L1.800|
                  |L1.782|
;;;273        }
;;;274        else
;;;275        {
;;;276            (pwm)->EADCTS1 &= ~(PWM_EADCTS1_TRGEN4_Msk << ((u32ChannelNum - 4) * 8));
00030e  f8d020fc          LDR      r2,[r0,#0xfc]
000312  1f0b              SUBS     r3,r1,#4
000314  00dc              LSLS     r4,r3,#3
000316  2380              MOVS     r3,#0x80
000318  40a3              LSLS     r3,r3,r4
00031a  439a              BICS     r2,r2,r3
00031c  f8c020fc          STR      r2,[r0,#0xfc]
                  |L1.800|
;;;277        }
;;;278    }
000320  bd10              POP      {r4,pc}
;;;279    
                          ENDP

                  PWM_ClearADCTriggerFlag PROC
;;;289     */
;;;290    void PWM_ClearADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000322  f44f3380          MOV      r3,#0x10000
;;;291    {
;;;292        (pwm)->STATUS = (PWM_STATUS_ADCTRGF0_Msk << u32ChannelNum);
000326  408b              LSLS     r3,r3,r1
000328  f8c03120          STR      r3,[r0,#0x120]
;;;293    }
00032c  4770              BX       lr
;;;294    
                          ENDP

                  PWM_GetADCTriggerFlag PROC
;;;304     */
;;;305    uint32_t PWM_GetADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum)
00032e  4602              MOV      r2,r0
;;;306    {
;;;307        return (((pwm)->STATUS & (PWM_STATUS_ADCTRGF0_Msk << u32ChannelNum)) ? 1 : 0);
000330  f8d20120          LDR      r0,[r2,#0x120]
000334  f44f3380          MOV      r3,#0x10000
000338  408b              LSLS     r3,r3,r1
00033a  4018              ANDS     r0,r0,r3
00033c  b108              CBZ      r0,|L1.834|
00033e  2001              MOVS     r0,#1
                  |L1.832|
;;;308    }
000340  4770              BX       lr
                  |L1.834|
000342  2000              MOVS     r0,#0                 ;307
000344  e7fc              B        |L1.832|
;;;309    
                          ENDP

                  PWM_EnableDACTrigger PROC
;;;323     */
;;;324    void PWM_EnableDACTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000346  b510              PUSH     {r4,lr}
;;;325    {
;;;326        (pwm)->DACTRGEN |= (u32Condition << u32ChannelNum);
000348  f8d030f4          LDR      r3,[r0,#0xf4]
00034c  fa02f401          LSL      r4,r2,r1
000350  4323              ORRS     r3,r3,r4
000352  f8c030f4          STR      r3,[r0,#0xf4]
;;;327    }
000356  bd10              POP      {r4,pc}
;;;328    
                          ENDP

                  PWM_DisableDACTrigger PROC
;;;337     */
;;;338    void PWM_DisableDACTrigger(PWM_T *pwm, uint32_t u32ChannelNum)
000358  f8d020f4          LDR      r2,[r0,#0xf4]
;;;339    {
;;;340        (pwm)->DACTRGEN &= ~((PWM_TRIGGER_DAC_ZERO_POINT | PWM_TRIGGER_DAC_PERIOD_POINT | PWM_TRIGGER_DAC_COMPARE_UP_COUNT_POINT | \
00035c  f04f3301          MOV      r3,#0x1010101
000360  408b              LSLS     r3,r3,r1
000362  439a              BICS     r2,r2,r3
000364  f8c020f4          STR      r2,[r0,#0xf4]
;;;341                              PWM_TRIGGER_DAC_COMPARE_DOWN_COUNT_POINT) << u32ChannelNum);
;;;342    }
000368  4770              BX       lr
;;;343    
                          ENDP

                  PWM_ClearDACTriggerFlag PROC
;;;353     */
;;;354    void PWM_ClearDACTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
00036a  f04f7380          MOV      r3,#0x1000000
;;;355    {
;;;356        (pwm)->STATUS = PWM_STATUS_DACTRGF_Msk;
00036e  f8c03120          STR      r3,[r0,#0x120]
;;;357    }
000372  4770              BX       lr
;;;358    
                          ENDP

                  PWM_GetDACTriggerFlag PROC
;;;368     */
;;;369    uint32_t PWM_GetDACTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000374  4602              MOV      r2,r0
;;;370    {
;;;371        return (((pwm)->STATUS & PWM_STATUS_DACTRGF_Msk) ? 1 : 0);
000376  f8d20120          LDR      r0,[r2,#0x120]
00037a  f3c06000          UBFX     r0,r0,#24,#1
;;;372    }
00037e  4770              BX       lr
;;;373    
                          ENDP

                  PWM_EnableFaultBrake PROC
;;;402     */
;;;403    void PWM_EnableFaultBrake(PWM_T *pwm, uint32_t u32ChannelMask, uint32_t u32LevelMask, uint32_t u32BrakeSource)
000380  b5f0              PUSH     {r4-r7,lr}
;;;404    {
000382  4604              MOV      r4,r0
;;;405        uint32_t i;
;;;406        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000384  2000              MOVS     r0,#0
000386  e0af              B        |L1.1256|
                  |L1.904|
;;;407        {
;;;408            if(u32ChannelMask & (1 << i))
000388  2501              MOVS     r5,#1
00038a  4085              LSLS     r5,r5,r0
00038c  400d              ANDS     r5,r5,r1
00038e  b34d              CBZ      r5,|L1.996|
;;;409            {
;;;410                if((u32BrakeSource == PWM_FB_EDGE_SYS_CSS) || (u32BrakeSource == PWM_FB_EDGE_SYS_BOD) || \
000390  2b81              CMP      r3,#0x81
000392  d012              BEQ      |L1.954|
000394  2b82              CMP      r3,#0x82
000396  d010              BEQ      |L1.954|
;;;411                        (u32BrakeSource == PWM_FB_EDGE_SYS_RAM) || (u32BrakeSource == PWM_FB_EDGE_SYS_COR) || \
000398  2b84              CMP      r3,#0x84
00039a  d00e              BEQ      |L1.954|
00039c  2b88              CMP      r3,#0x88
00039e  d00c              BEQ      |L1.954|
;;;412                        (u32BrakeSource == PWM_FB_LEVEL_SYS_CSS) || (u32BrakeSource == PWM_FB_LEVEL_SYS_BOD) || \
0003a0  f2480501          MOV      r5,#0x8001
0003a4  42ab              CMP      r3,r5
0003a6  d008              BEQ      |L1.954|
0003a8  1c6d              ADDS     r5,r5,#1
0003aa  42ab              CMP      r3,r5
0003ac  d005              BEQ      |L1.954|
;;;413                        (u32BrakeSource == PWM_FB_LEVEL_SYS_RAM) || (u32BrakeSource == PWM_FB_LEVEL_SYS_COR))
0003ae  1cad              ADDS     r5,r5,#2
0003b0  42ab              CMP      r3,r5
0003b2  d002              BEQ      |L1.954|
0003b4  1d2d              ADDS     r5,r5,#4
0003b6  42ab              CMP      r3,r5
0003b8  d124              BNE      |L1.1028|
                  |L1.954|
;;;414                {
;;;415                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= (u32BrakeSource & (PWM_BRKCTL0_1_SYSEBEN_Msk | PWM_BRKCTL0_1_SYSLBEN_Msk));
0003ba  0846              LSRS     r6,r0,#1
0003bc  f10405c8          ADD      r5,r4,#0xc8
0003c0  f8555026          LDR      r5,[r5,r6,LSL #2]
0003c4  f2480680          MOV      r6,#0x8080
0003c8  401e              ANDS     r6,r6,r3
0003ca  4335              ORRS     r5,r5,r6
0003cc  0847              LSRS     r7,r0,#1
0003ce  f10406c8          ADD      r6,r4,#0xc8
0003d2  f8465027          STR      r5,[r6,r7,LSL #2]
;;;416                    (pwm)->FAILBRK |= (u32BrakeSource & 0xF);
0003d6  f8d450c4          LDR      r5,[r4,#0xc4]
0003da  f003060f          AND      r6,r3,#0xf
0003de  4335              ORRS     r5,r5,r6
0003e0  f8c450c4          STR      r5,[r4,#0xc4]
                  |L1.996|
0003e4  e019              B        |L1.1050|
0003e6  0000              DCW      0x0000
                  |L1.1000|
0003e8  01020204          DCB      1,2,2,4
                  |L1.1004|
                          DCD      0x40000240
                  |L1.1008|
                          DCD      0x01518000
                  |L1.1012|
                          DCD      0x00b71b00
                  |L1.1016|
                          DCD      0x40058000
                  |L1.1020|
                          DCD      SystemCoreClock
                  |L1.1024|
                          DCD      0x000f4240
                  |L1.1028|
;;;417                }
;;;418                else
;;;419                {
;;;420                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= u32BrakeSource;
000404  0846              LSRS     r6,r0,#1
000406  f10405c8          ADD      r5,r4,#0xc8
00040a  f8555026          LDR      r5,[r5,r6,LSL #2]
00040e  431d              ORRS     r5,r5,r3
000410  0847              LSRS     r7,r0,#1
000412  f10406c8          ADD      r6,r4,#0xc8
000416  f8465027          STR      r5,[r6,r7,LSL #2]
                  |L1.1050|
;;;421                }
;;;422            }
;;;423    
;;;424            if(u32LevelMask & (1 << i))
00041a  2501              MOVS     r5,#1
00041c  4085              LSLS     r5,r5,r0
00041e  4015              ANDS     r5,r5,r2
000420  b385              CBZ      r5,|L1.1156|
;;;425            {
;;;426                if(i % 2 == 0)
000422  f0000501          AND      r5,r0,#1
000426  b9b5              CBNZ     r5,|L1.1110|
;;;427                {
;;;428                    //set brake action as high level for even channel
;;;429                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) &= ~PWM_BRKCTL0_1_BRKAEVEN_Msk;
000428  0846              LSRS     r6,r0,#1
00042a  f10405c8          ADD      r5,r4,#0xc8
00042e  f8555026          LDR      r5,[r5,r6,LSL #2]
000432  f4253640          BIC      r6,r5,#0x30000
000436  0847              LSRS     r7,r0,#1
000438  f10405c8          ADD      r5,r4,#0xc8
00043c  f8456027          STR      r6,[r5,r7,LSL #2]
;;;430                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= ((3UL) << PWM_BRKCTL0_1_BRKAEVEN_Pos);
000440  0846              LSRS     r6,r0,#1
000442  f8555026          LDR      r5,[r5,r6,LSL #2]
000446  f4453640          ORR      r6,r5,#0x30000
00044a  0847              LSRS     r7,r0,#1
00044c  f10405c8          ADD      r5,r4,#0xc8
000450  f8456027          STR      r6,[r5,r7,LSL #2]
000454  e047              B        |L1.1254|
                  |L1.1110|
;;;431                }
;;;432                else
;;;433                {
;;;434                    //set brake action as high level for odd channel
;;;435                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) &= ~PWM_BRKCTL0_1_BRKAODD_Msk;
000456  0846              LSRS     r6,r0,#1
000458  f10405c8          ADD      r5,r4,#0xc8
00045c  f8555026          LDR      r5,[r5,r6,LSL #2]
000460  f4252640          BIC      r6,r5,#0xc0000
000464  0847              LSRS     r7,r0,#1
000466  f10405c8          ADD      r5,r4,#0xc8
00046a  f8456027          STR      r6,[r5,r7,LSL #2]
;;;436                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= ((3UL) << PWM_BRKCTL0_1_BRKAODD_Pos);
00046e  0846              LSRS     r6,r0,#1
000470  f8555026          LDR      r5,[r5,r6,LSL #2]
000474  f4452640          ORR      r6,r5,#0xc0000
000478  0847              LSRS     r7,r0,#1
00047a  f10405c8          ADD      r5,r4,#0xc8
00047e  f8456027          STR      r6,[r5,r7,LSL #2]
000482  e030              B        |L1.1254|
                  |L1.1156|
000484  e7ff              B        |L1.1158|
                  |L1.1158|
;;;437                }
;;;438            }
;;;439            else
;;;440            {
;;;441                if(i % 2 == 0)
000486  f0000501          AND      r5,r0,#1
00048a  b9b5              CBNZ     r5,|L1.1210|
;;;442                {
;;;443                    //set brake action as low level for even channel
;;;444                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) &= ~PWM_BRKCTL0_1_BRKAEVEN_Msk;
00048c  0846              LSRS     r6,r0,#1
00048e  f10405c8          ADD      r5,r4,#0xc8
000492  f8555026          LDR      r5,[r5,r6,LSL #2]
000496  f4253640          BIC      r6,r5,#0x30000
00049a  0847              LSRS     r7,r0,#1
00049c  f10405c8          ADD      r5,r4,#0xc8
0004a0  f8456027          STR      r6,[r5,r7,LSL #2]
;;;445                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= ((2UL) << PWM_BRKCTL0_1_BRKAEVEN_Pos);
0004a4  0846              LSRS     r6,r0,#1
0004a6  f8555026          LDR      r5,[r5,r6,LSL #2]
0004aa  f4453600          ORR      r6,r5,#0x20000
0004ae  0847              LSRS     r7,r0,#1
0004b0  f10405c8          ADD      r5,r4,#0xc8
0004b4  f8456027          STR      r6,[r5,r7,LSL #2]
0004b8  e015              B        |L1.1254|
                  |L1.1210|
;;;446                }
;;;447                else
;;;448                {
;;;449                    //set brake action as low level for odd channel
;;;450                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) &= ~PWM_BRKCTL0_1_BRKAODD_Msk;
0004ba  0846              LSRS     r6,r0,#1
0004bc  f10405c8          ADD      r5,r4,#0xc8
0004c0  f8555026          LDR      r5,[r5,r6,LSL #2]
0004c4  f4252640          BIC      r6,r5,#0xc0000
0004c8  0847              LSRS     r7,r0,#1
0004ca  f10405c8          ADD      r5,r4,#0xc8
0004ce  f8456027          STR      r6,[r5,r7,LSL #2]
;;;451                    *(__IO uint32_t *)(&((pwm)->BRKCTL0_1) + (i >> 1)) |= ((2UL) << PWM_BRKCTL0_1_BRKAODD_Pos);
0004d2  0846              LSRS     r6,r0,#1
0004d4  f8555026          LDR      r5,[r5,r6,LSL #2]
0004d8  f4452600          ORR      r6,r5,#0x80000
0004dc  0847              LSRS     r7,r0,#1
0004de  f10405c8          ADD      r5,r4,#0xc8
0004e2  f8456027          STR      r6,[r5,r7,LSL #2]
                  |L1.1254|
0004e6  1c40              ADDS     r0,r0,#1              ;406
                  |L1.1256|
0004e8  2806              CMP      r0,#6                 ;406
0004ea  f4ffaf4d          BCC      |L1.904|
;;;452                }
;;;453            }
;;;454        }
;;;455    
;;;456    }
0004ee  bdf0              POP      {r4-r7,pc}
;;;457    
                          ENDP

                  PWM_EnableCapture PROC
;;;467     */
;;;468    void PWM_EnableCapture(PWM_T *pwm, uint32_t u32ChannelMask)
0004f0  f8d02200          LDR      r2,[r0,#0x200]
;;;469    {
;;;470        (pwm)->CAPINEN |= u32ChannelMask;
0004f4  430a              ORRS     r2,r2,r1
0004f6  f8c02200          STR      r2,[r0,#0x200]
;;;471        (pwm)->CAPCTL |= u32ChannelMask;
0004fa  f8d02204          LDR      r2,[r0,#0x204]
0004fe  430a              ORRS     r2,r2,r1
000500  f8c02204          STR      r2,[r0,#0x204]
;;;472    }
000504  4770              BX       lr
;;;473    
                          ENDP

                  PWM_DisableCapture PROC
;;;483     */
;;;484    void PWM_DisableCapture(PWM_T *pwm, uint32_t u32ChannelMask)
000506  f8d02200          LDR      r2,[r0,#0x200]
;;;485    {
;;;486        (pwm)->CAPINEN &= ~u32ChannelMask;
00050a  438a              BICS     r2,r2,r1
00050c  f8c02200          STR      r2,[r0,#0x200]
;;;487        (pwm)->CAPCTL &= ~u32ChannelMask;
000510  f8d02204          LDR      r2,[r0,#0x204]
000514  438a              BICS     r2,r2,r1
000516  f8c02204          STR      r2,[r0,#0x204]
;;;488    }
00051a  4770              BX       lr
;;;489    
                          ENDP

                  PWM_EnableOutput PROC
;;;499     */
;;;500    void PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask)
00051c  f8d020d8          LDR      r2,[r0,#0xd8]
;;;501    {
;;;502        (pwm)->POEN |= u32ChannelMask;
000520  430a              ORRS     r2,r2,r1
000522  f8c020d8          STR      r2,[r0,#0xd8]
;;;503    }
000526  4770              BX       lr
;;;504    
                          ENDP

                  PWM_DisableOutput PROC
;;;514     */
;;;515    void PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask)
000528  f8d020d8          LDR      r2,[r0,#0xd8]
;;;516    {
;;;517        (pwm)->POEN &= ~u32ChannelMask;
00052c  438a              BICS     r2,r2,r1
00052e  f8c020d8          STR      r2,[r0,#0xd8]
;;;518    }
000532  4770              BX       lr
;;;519    
                          ENDP

                  PWM_EnablePDMA PROC
;;;534     */
;;;535    void PWM_EnablePDMA(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32RisingFirst, uint32_t u32Mode)
000534  b5f0              PUSH     {r4-r7,lr}
;;;536    {
;;;537        uint32_t u32IsOddCh;
;;;538        u32IsOddCh = u32ChannelNum % 2;
000536  f0010401          AND      r4,r1,#1
;;;539        (pwm)->PDMACTL = ((pwm)->PDMACTL & ~((PWM_PDMACTL_CHSEL0_1_Msk | PWM_PDMACTL_CAPORD0_1_Msk | PWM_PDMACTL_CAPMOD0_1_Msk) << ((u32ChannelNum >> 1) * 8))) | \
00053a  f8d0523c          LDR      r5,[r0,#0x23c]
00053e  084e              LSRS     r6,r1,#1
000540  00f7              LSLS     r7,r6,#3
000542  261e              MOVS     r6,#0x1e
000544  40be              LSLS     r6,r6,r7
000546  43b5              BICS     r5,r5,r6
000548  0126              LSLS     r6,r4,#4
00054a  ea4606c2          ORR      r6,r6,r2,LSL #3
00054e  431e              ORRS     r6,r6,r3
000550  f0460601          ORR      r6,r6,#1
000554  084f              LSRS     r7,r1,#1
000556  00ff              LSLS     r7,r7,#3
000558  40be              LSLS     r6,r6,r7
00055a  4335              ORRS     r5,r5,r6
00055c  f8c0523c          STR      r5,[r0,#0x23c]
;;;540                         (((u32IsOddCh << PWM_PDMACTL_CHSEL0_1_Pos) | (u32RisingFirst << PWM_PDMACTL_CAPORD0_1_Pos) | \
;;;541                           u32Mode | PWM_PDMACTL_CHEN0_1_Msk) << ((u32ChannelNum >> 1) * 8));
;;;542    }
000560  bdf0              POP      {r4-r7,pc}
;;;543    
                          ENDP

                  PWM_DisablePDMA PROC
;;;552     */
;;;553    void PWM_DisablePDMA(PWM_T *pwm, uint32_t u32ChannelNum)
000562  b510              PUSH     {r4,lr}
;;;554    {
;;;555        (pwm)->PDMACTL &= ~(PWM_PDMACTL_CHEN0_1_Msk << ((u32ChannelNum >> 1) * 8));
000564  f8d0223c          LDR      r2,[r0,#0x23c]
000568  084b              LSRS     r3,r1,#1
00056a  00dc              LSLS     r4,r3,#3
00056c  2301              MOVS     r3,#1
00056e  40a3              LSLS     r3,r3,r4
000570  439a              BICS     r2,r2,r3
000572  f8c0223c          STR      r2,[r0,#0x23c]
;;;556    }
000576  bd10              POP      {r4,pc}
;;;557    
                          ENDP

                  PWM_EnableDeadZone PROC
;;;569     */
;;;570    void PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration)
000578  b530              PUSH     {r4,r5,lr}
;;;571    {
;;;572        // every two channels share the same setting
;;;573        *(__IO uint32_t *)(&((pwm)->DTCTL0_1) + (u32ChannelNum >> 1)) &= ~PWM_DTCTL0_1_DTCNT_Msk;
00057a  084c              LSRS     r4,r1,#1
00057c  f1000370          ADD      r3,r0,#0x70
000580  f8533024          LDR      r3,[r3,r4,LSL #2]
000584  0b1c              LSRS     r4,r3,#12
000586  0324              LSLS     r4,r4,#12
000588  084d              LSRS     r5,r1,#1
00058a  f1000370          ADD      r3,r0,#0x70
00058e  f8434025          STR      r4,[r3,r5,LSL #2]
;;;574        *(__IO uint32_t *)(&((pwm)->DTCTL0_1) + (u32ChannelNum >> 1)) |= PWM_DTCTL0_1_DTEN_Msk | u32Duration;
000592  084c              LSRS     r4,r1,#1
000594  f8533024          LDR      r3,[r3,r4,LSL #2]
000598  f4423480          ORR      r4,r2,#0x10000
00059c  4323              ORRS     r3,r3,r4
00059e  084d              LSRS     r5,r1,#1
0005a0  f1000470          ADD      r4,r0,#0x70
0005a4  f8443025          STR      r3,[r4,r5,LSL #2]
;;;575    }
0005a8  bd30              POP      {r4,r5,pc}
;;;576    
                          ENDP

                  PWM_DisableDeadZone PROC
;;;586     */
;;;587    void PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum)
0005aa  b510              PUSH     {r4,lr}
;;;588    {
;;;589        // every two channels shares the same setting
;;;590        *(__IO uint32_t *)(&((pwm)->DTCTL0_1) + (u32ChannelNum >> 1)) &= ~PWM_DTCTL0_1_DTEN_Msk;
0005ac  084b              LSRS     r3,r1,#1
0005ae  f1000270          ADD      r2,r0,#0x70
0005b2  f8522023          LDR      r2,[r2,r3,LSL #2]
0005b6  f4223380          BIC      r3,r2,#0x10000
0005ba  084c              LSRS     r4,r1,#1
0005bc  f1000270          ADD      r2,r0,#0x70
0005c0  f8423024          STR      r3,[r2,r4,LSL #2]
;;;591    }
0005c4  bd10              POP      {r4,pc}
;;;592    
                          ENDP

                  PWM_EnableCaptureInt PROC
;;;604     */
;;;605    void PWM_EnableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
0005c6  b510              PUSH     {r4,lr}
;;;606    {
;;;607        (pwm)->CAPIEN |= (u32Edge << u32ChannelNum);
0005c8  f8d03250          LDR      r3,[r0,#0x250]
0005cc  fa02f401          LSL      r4,r2,r1
0005d0  4323              ORRS     r3,r3,r4
0005d2  f8c03250          STR      r3,[r0,#0x250]
;;;608    }
0005d6  bd10              POP      {r4,pc}
;;;609    
                          ENDP

                  PWM_DisableCaptureInt PROC
;;;621     */
;;;622    void PWM_DisableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
0005d8  b510              PUSH     {r4,lr}
;;;623    {
;;;624        (pwm)->CAPIEN &= ~(u32Edge << u32ChannelNum);
0005da  f8d03250          LDR      r3,[r0,#0x250]
0005de  fa02f401          LSL      r4,r2,r1
0005e2  43a3              BICS     r3,r3,r4
0005e4  f8c03250          STR      r3,[r0,#0x250]
;;;625    }
0005e8  bd10              POP      {r4,pc}
;;;626    
                          ENDP

                  PWM_ClearCaptureIntFlag PROC
;;;638     */
;;;639    void PWM_ClearCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
0005ea  fa02f301          LSL      r3,r2,r1
;;;640    {
;;;641        (pwm)->CAPIF = (u32Edge << u32ChannelNum);
0005ee  f8c03254          STR      r3,[r0,#0x254]
;;;642    }
0005f2  4770              BX       lr
;;;643    
                          ENDP

                  PWM_GetCaptureIntFlag PROC
;;;655     */
;;;656    uint32_t PWM_GetCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
0005f4  b510              PUSH     {r4,lr}
;;;657    {
0005f6  4602              MOV      r2,r0
;;;658        return (((((pwm)->CAPIF & (PWM_CAPIF_CFLIF0_Msk << u32ChannelNum)) ? 1 : 0) << 1) | \
0005f8  f8d20254          LDR      r0,[r2,#0x254]
0005fc  2301              MOVS     r3,#1
0005fe  408b              LSLS     r3,r3,r1
000600  4018              ANDS     r0,r0,r3
000602  b108              CBZ      r0,|L1.1544|
;;;659                (((pwm)->CAPIF & (PWM_CAPIF_CRLIF0_Msk << u32ChannelNum)) ? 1 : 0));
000604  2401              MOVS     r4,#1
000606  e000              B        |L1.1546|
                  |L1.1544|
000608  2400              MOVS     r4,#0
                  |L1.1546|
00060a  f8d20254          LDR      r0,[r2,#0x254]
00060e  f44f7380          MOV      r3,#0x100
000612  408b              LSLS     r3,r3,r1
000614  4018              ANDS     r0,r0,r3
000616  b108              CBZ      r0,|L1.1564|
000618  2001              MOVS     r0,#1                 ;658
00061a  e000              B        |L1.1566|
                  |L1.1564|
00061c  2000              MOVS     r0,#0                 ;658
                  |L1.1566|
00061e  ea440040          ORR      r0,r4,r0,LSL #1       ;658
;;;660    }
000622  bd10              POP      {r4,pc}
;;;661    /**
                          ENDP

                  PWM_EnableDutyInt PROC
;;;672     */
;;;673    void PWM_EnableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType)
000624  b510              PUSH     {r4,lr}
;;;674    {
;;;675        (pwm)->INTEN0 |= (u32IntDutyType << u32ChannelNum);
000626  f8d030e0          LDR      r3,[r0,#0xe0]
00062a  fa02f401          LSL      r4,r2,r1
00062e  4323              ORRS     r3,r3,r4
000630  f8c030e0          STR      r3,[r0,#0xe0]
;;;676    }
000634  bd10              POP      {r4,pc}
;;;677    
                          ENDP

                  PWM_DisableDutyInt PROC
;;;686     */
;;;687    void PWM_DisableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum)
000636  f8d020e0          LDR      r2,[r0,#0xe0]
;;;688    {
;;;689        (pwm)->INTEN0 &= ~((PWM_DUTY_INT_DOWN_COUNT_MATCH_CMP | PWM_DUTY_INT_UP_COUNT_MATCH_CMP) << u32ChannelNum);
00063a  4bcf              LDR      r3,|L1.2424|
00063c  408b              LSLS     r3,r3,r1
00063e  439a              BICS     r2,r2,r3
000640  f8c020e0          STR      r2,[r0,#0xe0]
;;;690    }
000644  4770              BX       lr
;;;691    
                          ENDP

                  PWM_ClearDutyIntFlag PROC
;;;700     */
;;;701    void PWM_ClearDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000646  4acc              LDR      r2,|L1.2424|
;;;702    {
;;;703        (pwm)->INTSTS0 = (PWM_INTSTS0_CMPUIF0_Msk | PWM_INTSTS0_CMPDIF0_Msk) << u32ChannelNum;
000648  408a              LSLS     r2,r2,r1
00064a  f8c020e8          STR      r2,[r0,#0xe8]
;;;704    }
00064e  4770              BX       lr
;;;705    
                          ENDP

                  PWM_GetDutyIntFlag PROC
;;;716     */
;;;717    uint32_t PWM_GetDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000650  4602              MOV      r2,r0
;;;718    {
;;;719        return ((((pwm)->INTSTS0 & ((PWM_INTSTS0_CMPDIF0_Msk | PWM_INTSTS0_CMPUIF0_Msk) << u32ChannelNum))) ? 1 : 0);
000652  f8d200e8          LDR      r0,[r2,#0xe8]
000656  4bc8              LDR      r3,|L1.2424|
000658  408b              LSLS     r3,r3,r1
00065a  4018              ANDS     r0,r0,r3
00065c  b108              CBZ      r0,|L1.1634|
00065e  2001              MOVS     r0,#1
                  |L1.1632|
;;;720    }
000660  4770              BX       lr
                  |L1.1634|
000662  2000              MOVS     r0,#0                 ;719
000664  e7fc              B        |L1.1632|
;;;721    
                          ENDP

                  PWM_EnableFaultBrakeInt PROC
;;;732     */
;;;733    void PWM_EnableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource)
000666  f8d020e4          LDR      r2,[r0,#0xe4]
;;;734    {
;;;735        (pwm)->INTEN1 |= (0x7 << u32BrakeSource);
00066a  2307              MOVS     r3,#7
00066c  408b              LSLS     r3,r3,r1
00066e  431a              ORRS     r2,r2,r3
000670  f8c020e4          STR      r2,[r0,#0xe4]
;;;736    }
000674  4770              BX       lr
;;;737    
                          ENDP

                  PWM_DisableFaultBrakeInt PROC
;;;748     */
;;;749    void PWM_DisableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource)
000676  f8d020e4          LDR      r2,[r0,#0xe4]
;;;750    {
;;;751        (pwm)->INTEN1 &= ~(0x7 << u32BrakeSource);
00067a  2307              MOVS     r3,#7
00067c  408b              LSLS     r3,r3,r1
00067e  439a              BICS     r2,r2,r3
000680  f8c020e4          STR      r2,[r0,#0xe4]
;;;752    }
000684  4770              BX       lr
;;;753    
                          ENDP

                  PWM_ClearFaultBrakeIntFlag PROC
;;;763     */
;;;764    void PWM_ClearFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource)
000686  223f              MOVS     r2,#0x3f
;;;765    {
;;;766        (pwm)->INTSTS1 = (0x3f << u32BrakeSource);
000688  408a              LSLS     r2,r2,r1
00068a  f8c020ec          STR      r2,[r0,#0xec]
;;;767    }
00068e  4770              BX       lr
;;;768    
                          ENDP

                  PWM_GetFaultBrakeIntFlag PROC
;;;779     */
;;;780    uint32_t PWM_GetFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource)
000690  4602              MOV      r2,r0
;;;781    {
;;;782        return (((pwm)->INTSTS1 & (0x3f << u32BrakeSource)) ? 1 : 0);
000692  f8d200ec          LDR      r0,[r2,#0xec]
000696  233f              MOVS     r3,#0x3f
000698  408b              LSLS     r3,r3,r1
00069a  4018              ANDS     r0,r0,r3
00069c  b108              CBZ      r0,|L1.1698|
00069e  2001              MOVS     r0,#1
                  |L1.1696|
;;;783    }
0006a0  4770              BX       lr
                  |L1.1698|
0006a2  2000              MOVS     r0,#0                 ;782
0006a4  e7fc              B        |L1.1696|
;;;784    
                          ENDP

                  PWM_EnablePeriodInt PROC
;;;794     */
;;;795    void PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType)
0006a6  b510              PUSH     {r4,lr}
;;;796    {
;;;797        (pwm)->INTEN0 |= (PWM_INTEN0_PIEN0_Msk << u32ChannelNum);
0006a8  f8d030e0          LDR      r3,[r0,#0xe0]
0006ac  f44f7480          MOV      r4,#0x100
0006b0  408c              LSLS     r4,r4,r1
0006b2  4323              ORRS     r3,r3,r4
0006b4  f8c030e0          STR      r3,[r0,#0xe0]
;;;798    }
0006b8  bd10              POP      {r4,pc}
;;;799    
                          ENDP

                  PWM_DisablePeriodInt PROC
;;;808     */
;;;809    void PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum)
0006ba  f8d020e0          LDR      r2,[r0,#0xe0]
;;;810    {
;;;811        (pwm)->INTEN0 &= ~(PWM_INTEN0_PIEN0_Msk << u32ChannelNum);
0006be  f44f7380          MOV      r3,#0x100
0006c2  408b              LSLS     r3,r3,r1
0006c4  439a              BICS     r2,r2,r3
0006c6  f8c020e0          STR      r2,[r0,#0xe0]
;;;812    }
0006ca  4770              BX       lr
;;;813    
                          ENDP

                  PWM_ClearPeriodIntFlag PROC
;;;822     */
;;;823    void PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
0006cc  f44f7280          MOV      r2,#0x100
;;;824    {
;;;825        (pwm)->INTSTS0 = (PWM_INTSTS0_PIF0_Msk << u32ChannelNum);
0006d0  408a              LSLS     r2,r2,r1
0006d2  f8c020e8          STR      r2,[r0,#0xe8]
;;;826    }
0006d6  4770              BX       lr
;;;827    
                          ENDP

                  PWM_GetPeriodIntFlag PROC
;;;838     */
;;;839    uint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
0006d8  4602              MOV      r2,r0
;;;840    {
;;;841        return ((((pwm)->INTSTS0 & (PWM_INTSTS0_PIF0_Msk << u32ChannelNum))) ? 1 : 0);
0006da  f8d200e8          LDR      r0,[r2,#0xe8]
0006de  f44f7380          MOV      r3,#0x100
0006e2  408b              LSLS     r3,r3,r1
0006e4  4018              ANDS     r0,r0,r3
0006e6  b108              CBZ      r0,|L1.1772|
0006e8  2001              MOVS     r0,#1
                  |L1.1770|
;;;842    }
0006ea  4770              BX       lr
                  |L1.1772|
0006ec  2000              MOVS     r0,#0                 ;841
0006ee  e7fc              B        |L1.1770|
;;;843    
                          ENDP

                  PWM_EnableZeroInt PROC
;;;852     */
;;;853    void PWM_EnableZeroInt(PWM_T *pwm, uint32_t u32ChannelNum)
0006f0  f8d020e0          LDR      r2,[r0,#0xe0]
;;;854    {
;;;855        (pwm)->INTEN0 |= (PWM_INTEN0_ZIEN0_Msk << u32ChannelNum);
0006f4  2301              MOVS     r3,#1
0006f6  408b              LSLS     r3,r3,r1
0006f8  431a              ORRS     r2,r2,r3
0006fa  f8c020e0          STR      r2,[r0,#0xe0]
;;;856    }
0006fe  4770              BX       lr
;;;857    
                          ENDP

                  PWM_DisableZeroInt PROC
;;;866     */
;;;867    void PWM_DisableZeroInt(PWM_T *pwm, uint32_t u32ChannelNum)
000700  f8d020e0          LDR      r2,[r0,#0xe0]
;;;868    {
;;;869        (pwm)->INTEN0 &= ~(PWM_INTEN0_ZIEN0_Msk << u32ChannelNum);
000704  2301              MOVS     r3,#1
000706  408b              LSLS     r3,r3,r1
000708  439a              BICS     r2,r2,r3
00070a  f8c020e0          STR      r2,[r0,#0xe0]
;;;870    }
00070e  4770              BX       lr
;;;871    
                          ENDP

                  PWM_ClearZeroIntFlag PROC
;;;880     */
;;;881    void PWM_ClearZeroIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000710  2201              MOVS     r2,#1
;;;882    {
;;;883        (pwm)->INTSTS0 = (PWM_INTSTS0_ZIF0_Msk << u32ChannelNum);
000712  408a              LSLS     r2,r2,r1
000714  f8c020e8          STR      r2,[r0,#0xe8]
;;;884    }
000718  4770              BX       lr
;;;885    
                          ENDP

                  PWM_GetZeroIntFlag PROC
;;;896     */
;;;897    uint32_t PWM_GetZeroIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
00071a  4602              MOV      r2,r0
;;;898    {
;;;899        return ((((pwm)->INTSTS0 & (PWM_INTSTS0_ZIF0_Msk << u32ChannelNum))) ? 1 : 0);
00071c  f8d200e8          LDR      r0,[r2,#0xe8]
000720  2301              MOVS     r3,#1
000722  408b              LSLS     r3,r3,r1
000724  4018              ANDS     r0,r0,r3
000726  b108              CBZ      r0,|L1.1836|
000728  2001              MOVS     r0,#1
                  |L1.1834|
;;;900    }
00072a  4770              BX       lr
                  |L1.1836|
00072c  2000              MOVS     r0,#0                 ;899
00072e  e7fc              B        |L1.1834|
;;;901    
                          ENDP

                  PWM_EnableAcc PROC
;;;921     */
;;;922    void PWM_EnableAcc(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntFlagCnt, uint32_t u32IntAccSrc)
000730  b570              PUSH     {r4-r6,lr}
;;;923    {
;;;924        (pwm)->IFA = ((pwm)->IFA & ~((PWM_IFA_IFCNT0_1_Msk | PWM_IFA_IFSEL0_1_Msk) << ((u32ChannelNum >> 1) * 8))) | \
000732  f8d040f0          LDR      r4,[r0,#0xf0]
000736  084d              LSRS     r5,r1,#1
000738  00ee              LSLS     r6,r5,#3
00073a  257f              MOVS     r5,#0x7f
00073c  40b5              LSLS     r5,r5,r6
00073e  43ac              BICS     r4,r4,r5
000740  2580              MOVS     r5,#0x80
000742  ea451503          ORR      r5,r5,r3,LSL #4
000746  4315              ORRS     r5,r5,r2
000748  084e              LSRS     r6,r1,#1
00074a  00f6              LSLS     r6,r6,#3
00074c  40b5              LSLS     r5,r5,r6
00074e  432c              ORRS     r4,r4,r5
000750  f8c040f0          STR      r4,[r0,#0xf0]
;;;925                     ((PWM_IFA_IFAEN0_1_Msk | (u32IntAccSrc << PWM_IFA_IFSEL0_1_Pos) | u32IntFlagCnt) << ((u32ChannelNum >> 1) * 8));
;;;926    }
000754  bd70              POP      {r4-r6,pc}
;;;927    
                          ENDP

                  PWM_DisableAcc PROC
;;;937     */
;;;938    void PWM_DisableAcc(PWM_T *pwm, uint32_t u32ChannelNum)
000756  b510              PUSH     {r4,lr}
;;;939    {
;;;940        (pwm)->IFA = (pwm)->IFA & ~(PWM_IFA_IFAEN0_1_Msk << ((u32ChannelNum >> 1) * 8));
000758  f8d020f0          LDR      r2,[r0,#0xf0]
00075c  084b              LSRS     r3,r1,#1
00075e  00dc              LSLS     r4,r3,#3
000760  2380              MOVS     r3,#0x80
000762  40a3              LSLS     r3,r3,r4
000764  439a              BICS     r2,r2,r3
000766  f8c020f0          STR      r2,[r0,#0xf0]
;;;941    }
00076a  bd10              POP      {r4,pc}
;;;942    
                          ENDP

                  PWM_EnableAccInt PROC
;;;952     */
;;;953    void PWM_EnableAccInt(PWM_T *pwm, uint32_t u32ChannelNum)
00076c  b510              PUSH     {r4,lr}
;;;954    {
;;;955        (pwm)->INTEN0 |= (PWM_INTEN0_IFAIEN0_1_Msk << ((u32ChannelNum >> 1) * 8));
00076e  f8d020e0          LDR      r2,[r0,#0xe0]
000772  084b              LSRS     r3,r1,#1
000774  00dc              LSLS     r4,r3,#3
000776  2380              MOVS     r3,#0x80
000778  40a3              LSLS     r3,r3,r4
00077a  431a              ORRS     r2,r2,r3
00077c  f8c020e0          STR      r2,[r0,#0xe0]
;;;956    }
000780  bd10              POP      {r4,pc}
;;;957    
                          ENDP

                  PWM_DisableAccInt PROC
;;;967     */
;;;968    void PWM_DisableAccInt(PWM_T *pwm, uint32_t u32ChannelNum)
000782  b510              PUSH     {r4,lr}
;;;969    {
;;;970        (pwm)->INTEN0 &= ~(PWM_INTEN0_IFAIEN0_1_Msk << ((u32ChannelNum >> 1) * 8));
000784  f8d020e0          LDR      r2,[r0,#0xe0]
000788  084b              LSRS     r3,r1,#1
00078a  00dc              LSLS     r4,r3,#3
00078c  2380              MOVS     r3,#0x80
00078e  40a3              LSLS     r3,r3,r4
000790  439a              BICS     r2,r2,r3
000792  f8c020e0          STR      r2,[r0,#0xe0]
;;;971    }
000796  bd10              POP      {r4,pc}
;;;972    
                          ENDP

                  PWM_ClearAccInt PROC
;;;982     */
;;;983    void PWM_ClearAccInt(PWM_T *pwm, uint32_t u32ChannelNum)
000798  084a              LSRS     r2,r1,#1
;;;984    {
;;;985        (pwm)->INTSTS0 = (PWM_INTSTS0_IFAIF0_1_Msk << ((u32ChannelNum >> 1) * 8));
00079a  00d3              LSLS     r3,r2,#3
00079c  2280              MOVS     r2,#0x80
00079e  409a              LSLS     r2,r2,r3
0007a0  f8c020e8          STR      r2,[r0,#0xe8]
;;;986    }
0007a4  4770              BX       lr
;;;987    
                          ENDP

                  PWM_GetAccInt PROC
;;;998     */
;;;999    uint32_t PWM_GetAccInt(PWM_T *pwm, uint32_t u32ChannelNum)
0007a6  b510              PUSH     {r4,lr}
;;;1000   {
0007a8  4602              MOV      r2,r0
;;;1001       return (((pwm)->INTSTS0 & (PWM_INTSTS0_IFAIF0_1_Msk << ((u32ChannelNum >> 1) * 8))) ? 1 : 0);
0007aa  f8d200e8          LDR      r0,[r2,#0xe8]
0007ae  084b              LSRS     r3,r1,#1
0007b0  00dc              LSLS     r4,r3,#3
0007b2  2380              MOVS     r3,#0x80
0007b4  40a3              LSLS     r3,r3,r4
0007b6  4018              ANDS     r0,r0,r3
0007b8  b108              CBZ      r0,|L1.1982|
0007ba  2001              MOVS     r0,#1
                  |L1.1980|
;;;1002   }
0007bc  bd10              POP      {r4,pc}
                  |L1.1982|
0007be  2000              MOVS     r0,#0                 ;1001
0007c0  e7fc              B        |L1.1980|
;;;1003   
                          ENDP

                  PWM_ClearFTDutyIntFlag PROC
;;;1012    */
;;;1013   void PWM_ClearFTDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
0007c2  084b              LSRS     r3,r1,#1
;;;1014   {
;;;1015       (pwm)->FTCI = ((PWM_FTCI_FTCMU0_Msk | PWM_FTCI_FTCMD0_Msk) << (u32ChannelNum >> 1));
0007c4  f2401201          MOV      r2,#0x101
0007c8  409a              LSLS     r2,r2,r3
0007ca  f8c0234c          STR      r2,[r0,#0x34c]
;;;1016   }
0007ce  4770              BX       lr
;;;1017   
                          ENDP

                  PWM_GetFTDutyIntFlag PROC
;;;1028    */
;;;1029   uint32_t PWM_GetFTDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
0007d0  b510              PUSH     {r4,lr}
;;;1030   {
0007d2  4602              MOV      r2,r0
;;;1031       return (((pwm)->FTCI & ((PWM_FTCI_FTCMU0_Msk | PWM_FTCI_FTCMD0_Msk) << (u32ChannelNum >> 1))) ? 1 : 0);
0007d4  f8d2034c          LDR      r0,[r2,#0x34c]
0007d8  084c              LSRS     r4,r1,#1
0007da  f2401301          MOV      r3,#0x101
0007de  40a3              LSLS     r3,r3,r4
0007e0  4018              ANDS     r0,r0,r3
0007e2  b108              CBZ      r0,|L1.2024|
0007e4  2001              MOVS     r0,#1
                  |L1.2022|
;;;1032   }
0007e6  bd10              POP      {r4,pc}
                  |L1.2024|
0007e8  2000              MOVS     r0,#0                 ;1031
0007ea  e7fc              B        |L1.2022|
;;;1033   
                          ENDP

                  PWM_EnableLoadMode PROC
;;;1046    */
;;;1047   void PWM_EnableLoadMode(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32LoadMode)
0007ec  b510              PUSH     {r4,lr}
;;;1048   {
;;;1049       (pwm)->CTL0 |= (u32LoadMode << u32ChannelNum);
0007ee  6803              LDR      r3,[r0,#0]
0007f0  fa02f401          LSL      r4,r2,r1
0007f4  4323              ORRS     r3,r3,r4
0007f6  6003              STR      r3,[r0,#0]
;;;1050   }
0007f8  bd10              POP      {r4,pc}
;;;1051   
                          ENDP

                  PWM_DisableLoadMode PROC
;;;1064    */
;;;1065   void PWM_DisableLoadMode(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32LoadMode)
0007fa  b510              PUSH     {r4,lr}
;;;1066   {
;;;1067       (pwm)->CTL0 &= ~(u32LoadMode << u32ChannelNum);
0007fc  6803              LDR      r3,[r0,#0]
0007fe  fa02f401          LSL      r4,r2,r1
000802  43a3              BICS     r3,r3,r4
000804  6003              STR      r3,[r0,#0]
;;;1068   }
000806  bd10              POP      {r4,pc}
;;;1069   
                          ENDP

                  PWM_ConfigSyncPhase PROC
;;;1088    */
;;;1089   void PWM_ConfigSyncPhase(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32SyncSrc, uint32_t u32Direction, uint32_t u32StartPhase)
000808  b5f0              PUSH     {r4-r7,lr}
;;;1090   {
00080a  9c05              LDR      r4,[sp,#0x14]
;;;1091       // every two channels shares the same setting
;;;1092       u32ChannelNum >>= 1;
00080c  0849              LSRS     r1,r1,#1
;;;1093       (pwm)->SYNC = (((pwm)->SYNC & ~((PWM_SYNC_SINSRC0_Msk << (u32ChannelNum << 1)) | (PWM_SYNC_PHSDIR0_Msk << u32ChannelNum))) | \
00080e  004e              LSLS     r6,r1,#1
000810  f44f7540          MOV      r5,#0x300
000814  40b5              LSLS     r5,r5,r6
000816  f04f7680          MOV      r6,#0x1000000
00081a  408e              LSLS     r6,r6,r1
00081c  4335              ORRS     r5,r5,r6
00081e  6886              LDR      r6,[r0,#8]
000820  ea260505          BIC      r5,r6,r5
000824  061e              LSLS     r6,r3,#24
000826  408e              LSLS     r6,r6,r1
000828  4335              ORRS     r5,r5,r6
00082a  0216              LSLS     r6,r2,#8
00082c  004f              LSLS     r7,r1,#1
00082e  40be              LSLS     r6,r6,r7
000830  4335              ORRS     r5,r5,r6
000832  6085              STR      r5,[r0,#8]
;;;1094                      (u32Direction << PWM_SYNC_PHSDIR0_Pos << u32ChannelNum) | (u32SyncSrc << PWM_SYNC_SINSRC0_Pos) << (u32ChannelNum << 1));
;;;1095       *(__IO uint32_t *)(&((pwm)->PHS0_1) + u32ChannelNum) = u32StartPhase;
000834  f1000580          ADD      r5,r0,#0x80
000838  f8454021          STR      r4,[r5,r1,LSL #2]
;;;1096   }
00083c  bdf0              POP      {r4-r7,pc}
;;;1097   
                          ENDP

                  PWM_EnableSyncPhase PROC
;;;1109    */
;;;1110   void PWM_EnableSyncPhase(PWM_T *pwm, uint32_t u32ChannelMask)
00083e  b530              PUSH     {r4,r5,lr}
;;;1111   {
000840  4602              MOV      r2,r0
;;;1112       uint32_t i;
;;;1113       for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000842  2000              MOVS     r0,#0
000844  e00a              B        |L1.2140|
                  |L1.2118|
;;;1114       {
;;;1115           if(u32ChannelMask & (1 << i))
000846  2301              MOVS     r3,#1
000848  4083              LSLS     r3,r3,r0
00084a  400b              ANDS     r3,r3,r1
00084c  b12b              CBZ      r3,|L1.2138|
;;;1116           {
;;;1117               (pwm)->SYNC |= (PWM_SYNC_PHSEN0_Msk << (i >> 1));
00084e  6893              LDR      r3,[r2,#8]
000850  0845              LSRS     r5,r0,#1
000852  2401              MOVS     r4,#1
000854  40ac              LSLS     r4,r4,r5
000856  4323              ORRS     r3,r3,r4
000858  6093              STR      r3,[r2,#8]
                  |L1.2138|
00085a  1c40              ADDS     r0,r0,#1              ;1113
                  |L1.2140|
00085c  2806              CMP      r0,#6                 ;1113
00085e  d3f2              BCC      |L1.2118|
;;;1118           }
;;;1119       }
;;;1120   }
000860  bd30              POP      {r4,r5,pc}
;;;1121   
                          ENDP

                  PWM_DisableSyncPhase PROC
;;;1132    */
;;;1133   void PWM_DisableSyncPhase(PWM_T *pwm, uint32_t u32ChannelMask)
000862  b530              PUSH     {r4,r5,lr}
;;;1134   {
000864  4602              MOV      r2,r0
;;;1135       uint32_t i;
;;;1136       for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000866  2000              MOVS     r0,#0
000868  e00a              B        |L1.2176|
                  |L1.2154|
;;;1137       {
;;;1138           if(u32ChannelMask & (1 << i))
00086a  2301              MOVS     r3,#1
00086c  4083              LSLS     r3,r3,r0
00086e  400b              ANDS     r3,r3,r1
000870  b12b              CBZ      r3,|L1.2174|
;;;1139           {
;;;1140               (pwm)->SYNC &= ~(PWM_SYNC_PHSEN0_Msk << (i >> 1));
000872  6893              LDR      r3,[r2,#8]
000874  0845              LSRS     r5,r0,#1
000876  2401              MOVS     r4,#1
000878  40ac              LSLS     r4,r4,r5
00087a  43a3              BICS     r3,r3,r4
00087c  6093              STR      r3,[r2,#8]
                  |L1.2174|
00087e  1c40              ADDS     r0,r0,#1              ;1136
                  |L1.2176|
000880  2806              CMP      r0,#6                 ;1136
000882  d3f2              BCC      |L1.2154|
;;;1141           }
;;;1142       }
;;;1143   }
000884  bd30              POP      {r4,r5,pc}
;;;1144   
                          ENDP

                  PWM_EnableSyncNoiseFilter PROC
;;;1163    */
;;;1164   void PWM_EnableSyncNoiseFilter(PWM_T *pwm, uint32_t u32ClkCnt, uint32_t u32ClkDivSel)
000886  b510              PUSH     {r4,lr}
;;;1165   {
;;;1166       (pwm)->SYNC = ((pwm)->SYNC & ~(PWM_SYNC_SFLTCNT_Msk | PWM_SYNC_SFLTCSEL_Msk)) | \
000888  050b              LSLS     r3,r1,#20
00088a  ea434342          ORR      r3,r3,r2,LSL #17
00088e  f4433380          ORR      r3,r3,#0x10000
000892  6884              LDR      r4,[r0,#8]
000894  f42404fc          BIC      r4,r4,#0x7e0000
000898  4323              ORRS     r3,r3,r4
00089a  6083              STR      r3,[r0,#8]
;;;1167                     ((u32ClkCnt << PWM_SYNC_SFLTCNT_Pos) | (u32ClkDivSel << PWM_SYNC_SFLTCSEL_Pos) | PWM_SYNC_SNFLTEN_Msk);
;;;1168   }
00089c  bd10              POP      {r4,pc}
;;;1169   
                          ENDP

                  PWM_DisableSyncNoiseFilter PROC
;;;1177    */
;;;1178   void PWM_DisableSyncNoiseFilter(PWM_T *pwm)
00089e  6881              LDR      r1,[r0,#8]
;;;1179   {
;;;1180       (pwm)->SYNC &= ~PWM_SYNC_SNFLTEN_Msk;
0008a0  f4213180          BIC      r1,r1,#0x10000
0008a4  6081              STR      r1,[r0,#8]
;;;1181   }
0008a6  4770              BX       lr
;;;1182   
                          ENDP

                  PWM_EnableSyncPinInverse PROC
;;;1190    */
;;;1191   void PWM_EnableSyncPinInverse(PWM_T *pwm)
0008a8  6881              LDR      r1,[r0,#8]
;;;1192   {
;;;1193       (pwm)->SYNC |= PWM_SYNC_SINPINV_Msk;
0008aa  f4410100          ORR      r1,r1,#0x800000
0008ae  6081              STR      r1,[r0,#8]
;;;1194   }
0008b0  4770              BX       lr
;;;1195   
                          ENDP

                  PWM_DisableSyncPinInverse PROC
;;;1203    */
;;;1204   void PWM_DisableSyncPinInverse(PWM_T *pwm)
0008b2  6881              LDR      r1,[r0,#8]
;;;1205   {
;;;1206       (pwm)->SYNC &= ~PWM_SYNC_SINPINV_Msk;
0008b4  f4210100          BIC      r1,r1,#0x800000
0008b8  6081              STR      r1,[r0,#8]
;;;1207   }
0008ba  4770              BX       lr
;;;1208   
                          ENDP

                  PWM_SetClockSource PROC
;;;1224    */
;;;1225   void PWM_SetClockSource(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32ClkSrcSel)
0008bc  b530              PUSH     {r4,r5,lr}
;;;1226   {
;;;1227       (pwm)->CLKSRC = (pwm)->CLKSRC & ~(PWM_CLKSRC_ECLKSRC0_Msk << ((u32ChannelNum >> 1) * PWM_CLKSRC_ECLKSRC2_Pos)) | \
0008be  6903              LDR      r3,[r0,#0x10]
0008c0  084c              LSRS     r4,r1,#1
0008c2  00e5              LSLS     r5,r4,#3
0008c4  2407              MOVS     r4,#7
0008c6  40ac              LSLS     r4,r4,r5
0008c8  43a3              BICS     r3,r3,r4
0008ca  084c              LSRS     r4,r1,#1
0008cc  00e4              LSLS     r4,r4,#3
0008ce  fa02f404          LSL      r4,r2,r4
0008d2  4323              ORRS     r3,r3,r4
0008d4  6103              STR      r3,[r0,#0x10]
;;;1228                       (u32ClkSrcSel << ((u32ChannelNum >> 1) * PWM_CLKSRC_ECLKSRC2_Pos));
;;;1229   }
0008d6  bd30              POP      {r4,r5,pc}
;;;1230   
                          ENDP

                  PWM_EnableBrakeNoiseFilter PROC
;;;1249    */
;;;1250   void PWM_EnableBrakeNoiseFilter(PWM_T *pwm, uint32_t u32BrakePinNum, uint32_t u32ClkCnt, uint32_t u32ClkDivSel)
0008d8  b570              PUSH     {r4-r6,lr}
;;;1251   {
;;;1252       (pwm)->BNF = ((pwm)->BNF & ~((PWM_BNF_BRK0FCNT_Msk | PWM_BNF_BRK0NFSEL_Msk) << (u32BrakePinNum * PWM_BNF_BRK1NFEN_Pos))) | \
0008da  f8d040c0          LDR      r4,[r0,#0xc0]
0008de  00ce              LSLS     r6,r1,#3
0008e0  257e              MOVS     r5,#0x7e
0008e2  40b5              LSLS     r5,r5,r6
0008e4  43ac              BICS     r4,r4,r5
0008e6  0115              LSLS     r5,r2,#4
0008e8  ea450543          ORR      r5,r5,r3,LSL #1
0008ec  1c6d              ADDS     r5,r5,#1
0008ee  00ce              LSLS     r6,r1,#3
0008f0  40b5              LSLS     r5,r5,r6
0008f2  432c              ORRS     r4,r4,r5
0008f4  f8c040c0          STR      r4,[r0,#0xc0]
;;;1253                    (((u32ClkCnt << PWM_BNF_BRK0FCNT_Pos) | (u32ClkDivSel << PWM_BNF_BRK0NFSEL_Pos) | PWM_BNF_BRK0NFEN_Msk) << (u32BrakePinNum * PWM_BNF_BRK1NFEN_Pos));
;;;1254   }
0008f8  bd70              POP      {r4-r6,pc}
;;;1255   
                          ENDP

                  PWM_DisableBrakeNoiseFilter PROC
;;;1264    */
;;;1265   void PWM_DisableBrakeNoiseFilter(PWM_T *pwm, uint32_t u32BrakePinNum)
0008fa  b510              PUSH     {r4,lr}
;;;1266   {
;;;1267       (pwm)->BNF &= ~(PWM_BNF_BRK0NFEN_Msk << (u32BrakePinNum * PWM_BNF_BRK1NFEN_Pos));
0008fc  f8d020c0          LDR      r2,[r0,#0xc0]
000900  00cc              LSLS     r4,r1,#3
000902  2301              MOVS     r3,#1
000904  40a3              LSLS     r3,r3,r4
000906  439a              BICS     r2,r2,r3
000908  f8c020c0          STR      r2,[r0,#0xc0]
;;;1268   }
00090c  bd10              POP      {r4,pc}
;;;1269   
                          ENDP

                  PWM_EnableBrakePinInverse PROC
;;;1278    */
;;;1279   void PWM_EnableBrakePinInverse(PWM_T *pwm, uint32_t u32BrakePinNum)
00090e  b510              PUSH     {r4,lr}
;;;1280   {
;;;1281       (pwm)->BNF |= (PWM_BNF_BRK0PINV_Msk << (u32BrakePinNum * PWM_BNF_BRK1NFEN_Pos));
000910  f8d020c0          LDR      r2,[r0,#0xc0]
000914  00cc              LSLS     r4,r1,#3
000916  2380              MOVS     r3,#0x80
000918  40a3              LSLS     r3,r3,r4
00091a  431a              ORRS     r2,r2,r3
00091c  f8c020c0          STR      r2,[r0,#0xc0]
;;;1282   }
000920  bd10              POP      {r4,pc}
;;;1283   
                          ENDP

                  PWM_DisableBrakePinInverse PROC
;;;1292    */
;;;1293   void PWM_DisableBrakePinInverse(PWM_T *pwm, uint32_t u32BrakePinNum)
000922  b510              PUSH     {r4,lr}
;;;1294   {
;;;1295       (pwm)->BNF &= ~(PWM_BNF_BRK0PINV_Msk << (u32BrakePinNum * PWM_BNF_BRK1NFEN_Pos));
000924  f8d020c0          LDR      r2,[r0,#0xc0]
000928  00cc              LSLS     r4,r1,#3
00092a  2380              MOVS     r3,#0x80
00092c  40a3              LSLS     r3,r3,r4
00092e  439a              BICS     r2,r2,r3
000930  f8c020c0          STR      r2,[r0,#0xc0]
;;;1296   }
000934  bd10              POP      {r4,pc}
;;;1297   
                          ENDP

                  PWM_SetBrakePinSource PROC
;;;1308    */
;;;1309   void PWM_SetBrakePinSource(PWM_T *pwm, uint32_t u32BrakePinNum, uint32_t u32SelAnotherModule)
000936  b530              PUSH     {r4,r5,lr}
;;;1310   {
;;;1311       (pwm)->BNF = ((pwm)->BNF & ~(PWM_BNF_BK0SRC_Msk << (u32BrakePinNum * 8))) | (u32SelAnotherModule << (PWM_BNF_BK0SRC_Pos + u32BrakePinNum * 8));
000938  f8d030c0          LDR      r3,[r0,#0xc0]
00093c  00cd              LSLS     r5,r1,#3
00093e  f44f3480          MOV      r4,#0x10000
000942  40ac              LSLS     r4,r4,r5
000944  43a3              BICS     r3,r3,r4
000946  2410              MOVS     r4,#0x10
000948  eb0404c1          ADD      r4,r4,r1,LSL #3
00094c  fa02f404          LSL      r4,r2,r4
000950  4323              ORRS     r3,r3,r4
000952  f8c030c0          STR      r3,[r0,#0xc0]
;;;1312   }
000956  bd30              POP      {r4,r5,pc}
;;;1313   
                          ENDP

                  PWM_GetWrapAroundFlag PROC
;;;1324    */
;;;1325   uint32_t PWM_GetWrapAroundFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000958  4602              MOV      r2,r0
;;;1326   {
;;;1327       return (((pwm)->STATUS & (PWM_STATUS_CNTMAXF0_Msk << u32ChannelNum)) ? 1 : 0);
00095a  f8d20120          LDR      r0,[r2,#0x120]
00095e  2301              MOVS     r3,#1
000960  408b              LSLS     r3,r3,r1
000962  4018              ANDS     r0,r0,r3
000964  b108              CBZ      r0,|L1.2410|
000966  2001              MOVS     r0,#1
                  |L1.2408|
;;;1328   }
000968  4770              BX       lr
                  |L1.2410|
00096a  2000              MOVS     r0,#0                 ;1327
00096c  e7fc              B        |L1.2408|
;;;1329   
                          ENDP

                  PWM_ClearWrapAroundFlag PROC
;;;1338    */
;;;1339   void PWM_ClearWrapAroundFlag(PWM_T *pwm, uint32_t u32ChannelNum)
00096e  2201              MOVS     r2,#1
;;;1340   {
;;;1341       (pwm)->STATUS = (PWM_STATUS_CNTMAXF0_Msk << u32ChannelNum);
000970  408a              LSLS     r2,r2,r1
000972  f8c02120          STR      r2,[r0,#0x120]
;;;1342   }
000976  4770              BX       lr
;;;1343   
                          ENDP

                  |L1.2424|
                          DCD      0x01010000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\pwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_c4896a9e____REV16|
#line 114 "..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_pwm_c_c4896a9e____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_c4896a9e____REVSH|
#line 128
|__asm___5_pwm_c_c4896a9e____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
