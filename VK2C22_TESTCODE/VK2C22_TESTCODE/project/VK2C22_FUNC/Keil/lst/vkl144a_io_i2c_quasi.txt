; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\vkl144a_io_i2c_quasi.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\vkl144a_io_i2c_quasi.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M451Series\Include -I..\..\..\Library\StdDriver\inc -I..\Bsp -I..\User -I..\lcd_driver -I..\exti_driver -I..\led_driver -I..\touch -I..\dotmatix_lcd -I..\KH -IC:\Users\Administator\Desktop\低功耗系列_VKL\VKL例程\VKL144A_TESTCODE\project\VKL144_FUNC\Keil\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -D__UVISION_VERSION=515 -D_RTE_ --omf_browse=.\obj\vkl144a_io_i2c_quasi.crf ..\lcd_driver\VKL144A_IO_I2C_QUASI.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Delay_nuS PROC
;;;35     *******************************************************************************/
;;;36     void Delay_nuS(unsigned int n)	   
000000  e007              B        |L1.18|
                  |L1.2|
;;;37     {
;;;38     	unsigned char i;
;;;39     	while(n--)
;;;40     	{
;;;41     		i=10;
000002  210a              MOVS     r1,#0xa
;;;42     		while(i--)
000004  e000              B        |L1.8|
                  |L1.6|
;;;43     		{//nop指令根据单片机做相应的修改
;;;44     			__nop();
000006  bf00              NOP      
                  |L1.8|
000008  000a              MOVS     r2,r1                 ;42
00000a  f1a10301          SUB      r3,r1,#1              ;42
00000e  b2d9              UXTB     r1,r3                 ;42
000010  d1f9              BNE      |L1.6|
                  |L1.18|
000012  0002              MOVS     r2,r0                 ;39
000014  f1a00001          SUB      r0,r0,#1              ;39
000018  d1f3              BNE      |L1.2|
;;;45     		}
;;;46     	}
;;;47     }
00001a  4770              BX       lr
;;;48     /*******************************************************************************
                          ENDP

                  Delay_nmS PROC
;;;54     *******************************************************************************/
;;;55     void Delay_nmS(unsigned long int n)
00001c  b510              PUSH     {r4,lr}
;;;56     {
00001e  4604              MOV      r4,r0
;;;57     	while(n--)
000020  e003              B        |L1.42|
                  |L1.34|
;;;58     	{
;;;59     		Delay_nuS(1000);
000022  f44f707a          MOV      r0,#0x3e8
000026  f7fffffe          BL       Delay_nuS
                  |L1.42|
00002a  0020              MOVS     r0,r4                 ;57
00002c  f1a40401          SUB      r4,r4,#1              ;57
000030  d1f7              BNE      |L1.34|
;;;60     	}
;;;61     }
000032  bd10              POP      {r4,pc}
;;;62     /*******************************************************************************
                          ENDP

                  VKL144A_I2CStart PROC
;;;68     *******************************************************************************/
;;;69     void VKL144A_I2CStart( void )
000034  b500              PUSH     {lr}
;;;70     {
;;;71       VKL144A_SCL_H();
000036  2001              MOVS     r0,#1
000038  49f6              LDR      r1,|L1.1044|
00003a  6008              STR      r0,[r1,#0]
;;;72       VKL144A_SDA_H();
00003c  49f5              LDR      r1,|L1.1044|
00003e  3928              SUBS     r1,r1,#0x28
000040  6008              STR      r0,[r1,#0]
;;;73       Delay_nuS(VKL144A_CLK);
000042  2005              MOVS     r0,#5
000044  f7fffffe          BL       Delay_nuS
;;;74       VKL144A_SDA_L();
000048  2000              MOVS     r0,#0
00004a  49f2              LDR      r1,|L1.1044|
00004c  3928              SUBS     r1,r1,#0x28
00004e  6008              STR      r0,[r1,#0]
;;;75       Delay_nuS(VKL144A_CLK);
000050  2005              MOVS     r0,#5
000052  f7fffffe          BL       Delay_nuS
;;;76     }
000056  bd00              POP      {pc}
;;;77     /*******************************************************************************
                          ENDP

                  VKL144A_I2CStop PROC
;;;83     *******************************************************************************/
;;;84     void VKL144A_I2CStop( void )
000058  b500              PUSH     {lr}
;;;85     {
;;;86       VKL144A_SCL_H();
00005a  2001              MOVS     r0,#1
00005c  49ed              LDR      r1,|L1.1044|
00005e  6008              STR      r0,[r1,#0]
;;;87       VKL144A_SDA_L();
000060  2000              MOVS     r0,#0
000062  49ec              LDR      r1,|L1.1044|
000064  3928              SUBS     r1,r1,#0x28
000066  6008              STR      r0,[r1,#0]
;;;88       Delay_nuS(VKL144A_CLK);
000068  2005              MOVS     r0,#5
00006a  f7fffffe          BL       Delay_nuS
;;;89       VKL144A_SDA_H();
00006e  2001              MOVS     r0,#1
000070  49e8              LDR      r1,|L1.1044|
000072  3928              SUBS     r1,r1,#0x28
000074  6008              STR      r0,[r1,#0]
;;;90       Delay_nuS(VKL144A_CLK);
000076  2005              MOVS     r0,#5
000078  f7fffffe          BL       Delay_nuS
;;;91     }
00007c  bd00              POP      {pc}
;;;92     /*******************************************************************************
                          ENDP

                  VKL144A_I2CSlaveAck PROC
;;;98     *******************************************************************************/
;;;99     unsigned char VKL144A_I2CSlaveAck( void )
00007e  b530              PUSH     {r4,r5,lr}
;;;100    {
;;;101      unsigned int TimeOut;
;;;102      unsigned char RetValue;
;;;103    	
;;;104      VKL144A_SCL_L();
000080  2000              MOVS     r0,#0
000082  49e4              LDR      r1,|L1.1044|
000084  6008              STR      r0,[r1,#0]
;;;105      Delay_nuS(VKL144A_CLK);
000086  2005              MOVS     r0,#5
000088  f7fffffe          BL       Delay_nuS
;;;106      VKL144A_SCL_H();//第9个SCL时钟上升沿
00008c  2001              MOVS     r0,#1
00008e  49e1              LDR      r1,|L1.1044|
000090  6008              STR      r0,[r1,#0]
;;;107      TimeOut = 10000;
000092  f2427510          MOV      r5,#0x2710
;;;108      while( TimeOut-- > 0 )
000096  e007              B        |L1.168|
                  |L1.152|
;;;109      {
;;;110        if( VKL144A_GET_SDA()!=0 )//读取ack
000098  48de              LDR      r0,|L1.1044|
00009a  3828              SUBS     r0,r0,#0x28
00009c  6800              LDR      r0,[r0,#0]
00009e  b108              CBZ      r0,|L1.164|
;;;111        {
;;;112          RetValue = 1;
0000a0  2401              MOVS     r4,#1
0000a2  e001              B        |L1.168|
                  |L1.164|
;;;113        }
;;;114        else
;;;115        {
;;;116          RetValue = 0;
0000a4  2400              MOVS     r4,#0
;;;117          break;
0000a6  e003              B        |L1.176|
                  |L1.168|
0000a8  0028              MOVS     r0,r5                 ;108
0000aa  f1a50501          SUB      r5,r5,#1              ;108
0000ae  d1f3              BNE      |L1.152|
                  |L1.176|
0000b0  bf00              NOP      
;;;118        }
;;;119      } 
;;;120    	VKL144A_SCL_L(); //下一个时序可能为命令,数据或者STOP信号。
0000b2  2000              MOVS     r0,#0
0000b4  49d7              LDR      r1,|L1.1044|
0000b6  6008              STR      r0,[r1,#0]
;;;121      
;;;122      return RetValue;
0000b8  4620              MOV      r0,r4
;;;123    }
0000ba  bd30              POP      {r4,r5,pc}
;;;124    /*******************************************************************************
                          ENDP

                  VKL144A_I2CSendAck PROC
;;;130    *******************************************************************************/
;;;131    void VKL144A_I2CSendAck( void )
0000bc  b500              PUSH     {lr}
;;;132    {
;;;133      VKL144A_SCL_L();
0000be  2000              MOVS     r0,#0
0000c0  49d4              LDR      r1,|L1.1044|
0000c2  6008              STR      r0,[r1,#0]
;;;134      VKL144A_SDA_L();
0000c4  49d3              LDR      r1,|L1.1044|
0000c6  3928              SUBS     r1,r1,#0x28
0000c8  6008              STR      r0,[r1,#0]
;;;135      Delay_nuS(VKL144A_CLK*2);
0000ca  200a              MOVS     r0,#0xa
0000cc  f7fffffe          BL       Delay_nuS
;;;136      VKL144A_SCL_H();
0000d0  2001              MOVS     r0,#1
0000d2  49d0              LDR      r1,|L1.1044|
0000d4  6008              STR      r0,[r1,#0]
;;;137      Delay_nuS(VKL144A_CLK*2);
0000d6  200a              MOVS     r0,#0xa
0000d8  f7fffffe          BL       Delay_nuS
;;;138      VKL144A_SCL_L();
0000dc  2000              MOVS     r0,#0
0000de  49cd              LDR      r1,|L1.1044|
0000e0  6008              STR      r0,[r1,#0]
;;;139      VKL144A_SDA_H();
0000e2  2001              MOVS     r0,#1
0000e4  49cb              LDR      r1,|L1.1044|
0000e6  3928              SUBS     r1,r1,#0x28
0000e8  6008              STR      r0,[r1,#0]
;;;140    }
0000ea  bd00              POP      {pc}
;;;141    /*******************************************************************************
                          ENDP

                  VKL144A_I2CSendNAck PROC
;;;147    *******************************************************************************/
;;;148    void VKL144A_I2CSendNAck( void )
0000ec  b500              PUSH     {lr}
;;;149    {
;;;150      VKL144A_SCL_L();
0000ee  2000              MOVS     r0,#0
0000f0  49c8              LDR      r1,|L1.1044|
0000f2  6008              STR      r0,[r1,#0]
;;;151      VKL144A_SDA_H();
0000f4  2001              MOVS     r0,#1
0000f6  49c7              LDR      r1,|L1.1044|
0000f8  3928              SUBS     r1,r1,#0x28
0000fa  6008              STR      r0,[r1,#0]
;;;152      Delay_nuS(VKL144A_CLK);
0000fc  2005              MOVS     r0,#5
0000fe  f7fffffe          BL       Delay_nuS
;;;153      VKL144A_SCL_H();
000102  2001              MOVS     r0,#1
000104  49c3              LDR      r1,|L1.1044|
000106  6008              STR      r0,[r1,#0]
;;;154      Delay_nuS(VKL144A_CLK);
000108  2005              MOVS     r0,#5
00010a  f7fffffe          BL       Delay_nuS
;;;155    }
00010e  bd00              POP      {pc}
;;;156    /*******************************************************************************
                          ENDP

                  VKL144A_I2CWRCmd PROC
;;;162    *******************************************************************************/
;;;163    void VKL144A_I2CWRCmd( unsigned char cmd )
000110  b530              PUSH     {r4,r5,lr}
;;;164    {
000112  4604              MOV      r4,r0
;;;165    	unsigned char i=8;
000114  2508              MOVS     r5,#8
;;;166    	
;;;167    	while (i--)
000116  e019              B        |L1.332|
                  |L1.280|
;;;168    	{ 
;;;169    		VKL144A_SCL_L();
000118  2000              MOVS     r0,#0
00011a  49be              LDR      r1,|L1.1044|
00011c  6008              STR      r0,[r1,#0]
;;;170    		if(cmd&0x80)
00011e  f0040080          AND      r0,r4,#0x80
000122  b120              CBZ      r0,|L1.302|
;;;171    			VKL144A_SDA_H();
000124  2001              MOVS     r0,#1
000126  49bb              LDR      r1,|L1.1044|
000128  3928              SUBS     r1,r1,#0x28
00012a  6008              STR      r0,[r1,#0]
00012c  e003              B        |L1.310|
                  |L1.302|
;;;172    		else
;;;173    			VKL144A_SDA_L();
00012e  2000              MOVS     r0,#0
000130  49b8              LDR      r1,|L1.1044|
000132  3928              SUBS     r1,r1,#0x28
000134  6008              STR      r0,[r1,#0]
                  |L1.310|
;;;174    		cmd<<=1; 
000136  0660              LSLS     r0,r4,#25
000138  0e04              LSRS     r4,r0,#24
;;;175    		Delay_nuS(VKL144A_CLK);
00013a  2005              MOVS     r0,#5
00013c  f7fffffe          BL       Delay_nuS
;;;176    		VKL144A_SCL_H();     
000140  2001              MOVS     r0,#1
000142  49b4              LDR      r1,|L1.1044|
000144  6008              STR      r0,[r1,#0]
;;;177    		Delay_nuS(VKL144A_CLK);
000146  2005              MOVS     r0,#5
000148  f7fffffe          BL       Delay_nuS
                  |L1.332|
00014c  0028              MOVS     r0,r5                 ;167
00014e  f1a50101          SUB      r1,r5,#1              ;167
000152  b2cd              UXTB     r5,r1                 ;167
000154  d1e0              BNE      |L1.280|
;;;178    	}
;;;179    }
000156  bd30              POP      {r4,r5,pc}
;;;180    /*******************************************************************************
                          ENDP

                  VKL144A_I2CWRDat PROC
;;;186    *******************************************************************************/
;;;187    void VKL144A_I2CWRDat( unsigned char dat )
000158  b530              PUSH     {r4,r5,lr}
;;;188    {
00015a  4604              MOV      r4,r0
;;;189    	unsigned char i=8;
00015c  2508              MOVS     r5,#8
;;;190    	while (i--)
00015e  e018              B        |L1.402|
                  |L1.352|
;;;191    	{ 
;;;192    		VKL144A_SCL_L();
000160  2000              MOVS     r0,#0
000162  49ac              LDR      r1,|L1.1044|
000164  6008              STR      r0,[r1,#0]
;;;193    		if(dat&0x01)
000166  f0040001          AND      r0,r4,#1
00016a  b120              CBZ      r0,|L1.374|
;;;194    			VKL144A_SDA_H();
00016c  2001              MOVS     r0,#1
00016e  49a9              LDR      r1,|L1.1044|
000170  3928              SUBS     r1,r1,#0x28
000172  6008              STR      r0,[r1,#0]
000174  e003              B        |L1.382|
                  |L1.374|
;;;195    		else
;;;196    			VKL144A_SDA_L();
000176  2000              MOVS     r0,#0
000178  49a6              LDR      r1,|L1.1044|
00017a  3928              SUBS     r1,r1,#0x28
00017c  6008              STR      r0,[r1,#0]
                  |L1.382|
;;;197    		dat>>=1; 
00017e  1064              ASRS     r4,r4,#1
;;;198    		Delay_nuS(VKL144A_CLK);
000180  2005              MOVS     r0,#5
000182  f7fffffe          BL       Delay_nuS
;;;199    		VKL144A_SCL_H();     
000186  2001              MOVS     r0,#1
000188  49a2              LDR      r1,|L1.1044|
00018a  6008              STR      r0,[r1,#0]
;;;200    		Delay_nuS(VKL144A_CLK);
00018c  2005              MOVS     r0,#5
00018e  f7fffffe          BL       Delay_nuS
                  |L1.402|
000192  0028              MOVS     r0,r5                 ;190
000194  f1a50101          SUB      r1,r5,#1              ;190
000198  b2cd              UXTB     r5,r1                 ;190
00019a  d1e1              BNE      |L1.352|
;;;201    	}
;;;202    }
00019c  bd30              POP      {r4,r5,pc}
;;;203    
                          ENDP

                  VKL144A_I2CRDDat PROC
;;;210    *******************************************************************************/
;;;211    unsigned char VKL144A_I2CRDDat( void )
00019e  b530              PUSH     {r4,r5,lr}
;;;212    {
;;;213    	unsigned char i,RetValue;
;;;214    	
;;;215    	RetValue=0;	
0001a0  2400              MOVS     r4,#0
;;;216      for( i=0; i<8; i++ )
0001a2  2500              MOVS     r5,#0
0001a4  e014              B        |L1.464|
                  |L1.422|
;;;217      {
;;;218    		RetValue>>=1; 
0001a6  1064              ASRS     r4,r4,#1
;;;219    		VKL144A_SCL_L();     
0001a8  2000              MOVS     r0,#0
0001aa  499a              LDR      r1,|L1.1044|
0001ac  6008              STR      r0,[r1,#0]
;;;220    		Delay_nuS(VKL144A_CLK);
0001ae  2005              MOVS     r0,#5
0001b0  f7fffffe          BL       Delay_nuS
;;;221    		VKL144A_SCL_H();
0001b4  2001              MOVS     r0,#1
0001b6  4997              LDR      r1,|L1.1044|
0001b8  6008              STR      r0,[r1,#0]
;;;222    		Delay_nuS(VKL144A_CLK);
0001ba  2005              MOVS     r0,#5
0001bc  f7fffffe          BL       Delay_nuS
;;;223    		if( VKL144A_GET_SDA()!=0 )
0001c0  4894              LDR      r0,|L1.1044|
0001c2  3828              SUBS     r0,r0,#0x28
0001c4  6800              LDR      r0,[r0,#0]
0001c6  b108              CBZ      r0,|L1.460|
;;;224    			RetValue|=0x80;
0001c8  f0440480          ORR      r4,r4,#0x80
                  |L1.460|
0001cc  1c68              ADDS     r0,r5,#1              ;216
0001ce  b2c5              UXTB     r5,r0                 ;216
                  |L1.464|
0001d0  2d08              CMP      r5,#8                 ;216
0001d2  dbe8              BLT      |L1.422|
;;;225    	}
;;;226      
;;;227      return RetValue;
0001d4  4620              MOV      r0,r4
;;;228    }
0001d6  bd30              POP      {r4,r5,pc}
;;;229    /*******************************************************************************
                          ENDP

                  WriteCmdVKL144A PROC
;;;235    *******************************************************************************/
;;;236    unsigned char  WriteCmdVKL144A(unsigned char cmd)
0001d8  b510              PUSH     {r4,lr}
;;;237    {
0001da  4604              MOV      r4,r0
;;;238    	//START信号	
;;;239    	VKL144A_I2CStart(); 									
0001dc  f7fffffe          BL       VKL144A_I2CStart
;;;240    	//SLAVE地址
;;;241    	VKL144A_I2CWRCmd(VKL144A_ADDRWR); 	
0001e0  207c              MOVS     r0,#0x7c
0001e2  f7fffffe          BL       VKL144A_I2CWRCmd
;;;242    	if( 1 == VKL144A_I2CSlaveAck() )
0001e6  f7fffffe          BL       VKL144A_I2CSlaveAck
0001ea  2801              CMP      r0,#1
0001ec  d103              BNE      |L1.502|
;;;243    	{
;;;244    		VKL144A_I2CStop();													
0001ee  f7fffffe          BL       VKL144A_I2CStop
;;;245    		return 0;										
0001f2  2000              MOVS     r0,#0
                  |L1.500|
;;;246    	}
;;;247    	
;;;248    	VKL144A_I2CWRCmd(cmd); 						
;;;249    	if( 1 == VKL144A_I2CSlaveAck() )
;;;250    	{
;;;251    		VKL144A_I2CStop();													
;;;252    		return 0;
;;;253    	}
;;;254    	//STOP信号
;;;255    	 VKL144A_I2CStop();											
;;;256    	 return 0;    
;;;257    }
0001f4  bd10              POP      {r4,pc}
                  |L1.502|
0001f6  4620              MOV      r0,r4                 ;248
0001f8  f7fffffe          BL       VKL144A_I2CWRCmd
0001fc  f7fffffe          BL       VKL144A_I2CSlaveAck
000200  2801              CMP      r0,#1                 ;249
000202  d103              BNE      |L1.524|
000204  f7fffffe          BL       VKL144A_I2CStop
000208  2000              MOVS     r0,#0                 ;252
00020a  e7f3              B        |L1.500|
                  |L1.524|
00020c  f7fffffe          BL       VKL144A_I2CStop
000210  2000              MOVS     r0,#0                 ;256
000212  e7ef              B        |L1.500|
;;;258    /*******************************************************************************
                          ENDP

                  WritenDataVKL144A PROC
;;;266    *******************************************************************************/
;;;267    unsigned char  WritenDataVKL144A(unsigned char Addr,unsigned char *Databuf,unsigned char Cnt)
000214  b5f0              PUSH     {r4-r7,lr}
;;;268    {
000216  4604              MOV      r4,r0
000218  460d              MOV      r5,r1
00021a  4617              MOV      r7,r2
;;;269    	unsigned char n;
;;;270    	
;;;271    	//START信号	
;;;272    	VKL144A_I2CStart(); 									
00021c  f7fffffe          BL       VKL144A_I2CStart
;;;273    	//SLAVE地址
;;;274    	VKL144A_I2CWRCmd(VKL144A_ADDRWR); 	
000220  207c              MOVS     r0,#0x7c
000222  f7fffffe          BL       VKL144A_I2CWRCmd
;;;275    	if( 1 == VKL144A_I2CSlaveAck() )
000226  f7fffffe          BL       VKL144A_I2CSlaveAck
00022a  2801              CMP      r0,#1
00022c  d103              BNE      |L1.566|
;;;276    	{
;;;277    		VKL144A_I2CStop();													
00022e  f7fffffe          BL       VKL144A_I2CStop
;;;278    		return 0;										
000232  2000              MOVS     r0,#0
                  |L1.564|
;;;279    	}
;;;280    	//显示RAM起始地址
;;;281    	if(Addr>0x1f)													//选择内部时钟（OSCI脚）VKL144A_ADDRWR5 bit0一定要清0
;;;282    		VKL144A_I2CWRCmd(VKL144A_ADDR5_1); 	//选择外部时钟（OSCI脚）VKL144A_ADDRWR5 bit0一定要置1
;;;283    	else                               
;;;284    		VKL144A_I2CWRCmd(VKL144A_ADDR5_0); 
;;;285    	if( 1 == VKL144A_I2CSlaveAck() )
;;;286    	{
;;;287    		VKL144A_I2CStop();													
;;;288    		return 0; 
;;;289    	}
;;;290    	VKL144A_I2CWRCmd(Addr&0x1f); 						
;;;291    	if( 1 == VKL144A_I2CSlaveAck() )
;;;292    	{
;;;293    		VKL144A_I2CStop();													
;;;294    		return 0;
;;;295    	}
;;;296    	//发送Cnt个数据到显示RAM
;;;297    	for(n=0;n<Cnt;n++)
;;;298    	{ 
;;;299    		VKL144A_I2CWRDat(*Databuf++);
;;;300    		if( VKL144A_I2CSlaveAck()==1 )
;;;301    		{
;;;302    			VKL144A_I2CStop();													
;;;303    			return 0;
;;;304    		}
;;;305    	}
;;;306    	//STOP信号
;;;307    	 VKL144A_I2CStop();											
;;;308    	 return 0;    
;;;309    }
000234  bdf0              POP      {r4-r7,pc}
                  |L1.566|
000236  2c1f              CMP      r4,#0x1f              ;281
000238  dd03              BLE      |L1.578|
00023a  20ec              MOVS     r0,#0xec              ;282
00023c  f7fffffe          BL       VKL144A_I2CWRCmd
000240  e002              B        |L1.584|
                  |L1.578|
000242  20e8              MOVS     r0,#0xe8              ;284
000244  f7fffffe          BL       VKL144A_I2CWRCmd
                  |L1.584|
000248  f7fffffe          BL       VKL144A_I2CSlaveAck
00024c  2801              CMP      r0,#1                 ;285
00024e  d103              BNE      |L1.600|
000250  f7fffffe          BL       VKL144A_I2CStop
000254  2000              MOVS     r0,#0                 ;288
000256  e7ed              B        |L1.564|
                  |L1.600|
000258  f004001f          AND      r0,r4,#0x1f           ;290
00025c  f7fffffe          BL       VKL144A_I2CWRCmd
000260  f7fffffe          BL       VKL144A_I2CSlaveAck
000264  2801              CMP      r0,#1                 ;291
000266  d103              BNE      |L1.624|
000268  f7fffffe          BL       VKL144A_I2CStop
00026c  2000              MOVS     r0,#0                 ;294
00026e  e7e1              B        |L1.564|
                  |L1.624|
000270  2600              MOVS     r6,#0                 ;297
000272  e00d              B        |L1.656|
                  |L1.628|
000274  f8150b01          LDRB     r0,[r5],#1            ;299
000278  f7fffffe          BL       VKL144A_I2CWRDat
00027c  f7fffffe          BL       VKL144A_I2CSlaveAck
000280  2801              CMP      r0,#1                 ;300
000282  d103              BNE      |L1.652|
000284  f7fffffe          BL       VKL144A_I2CStop
000288  2000              MOVS     r0,#0                 ;303
00028a  e7d3              B        |L1.564|
                  |L1.652|
00028c  1c70              ADDS     r0,r6,#1              ;297
00028e  b2c6              UXTB     r6,r0                 ;297
                  |L1.656|
000290  42be              CMP      r6,r7                 ;297
000292  dbef              BLT      |L1.628|
000294  f7fffffe          BL       VKL144A_I2CStop
000298  2000              MOVS     r0,#0                 ;308
00029a  e7cb              B        |L1.564|
;;;310    
                          ENDP

                  ReadnDataVKL144A PROC
;;;319    *******************************************************************************/
;;;320    unsigned char  ReadnDataVKL144A(unsigned char Addr,unsigned char *Databuf,unsigned char Cnt)
00029c  b5f0              PUSH     {r4-r7,lr}
;;;321    {
00029e  4605              MOV      r5,r0
0002a0  460c              MOV      r4,r1
0002a2  4617              MOV      r7,r2
;;;322    	unsigned char n;
;;;323    	
;;;324    	//START信号	
;;;325    	VKL144A_I2CStart(); 									
0002a4  f7fffffe          BL       VKL144A_I2CStart
;;;326    	//SLAVE地址写
;;;327    	VKL144A_I2CWRCmd(VKL144A_ADDRWR); 	
0002a8  207c              MOVS     r0,#0x7c
0002aa  f7fffffe          BL       VKL144A_I2CWRCmd
;;;328    	if( 1 == VKL144A_I2CSlaveAck() )
0002ae  f7fffffe          BL       VKL144A_I2CSlaveAck
0002b2  2801              CMP      r0,#1
0002b4  d103              BNE      |L1.702|
;;;329    	{
;;;330    		VKL144A_I2CStop();													
0002b6  f7fffffe          BL       VKL144A_I2CStop
;;;331    		return 0;										
0002ba  2000              MOVS     r0,#0
                  |L1.700|
;;;332    	}
;;;333    	//显示RAM起始地址
;;;334    	if(Addr>0x1f)													//选择内部时钟（OSCI脚）VKL144A_ADDRWR5 bit0一定要清0
;;;335    		VKL144A_I2CWRCmd(VKL144A_ADDR5_1); 	//选择外部时钟（OSCI脚）VKL144A_ADDRWR5 bit0一定要置1
;;;336    	else                               
;;;337    		VKL144A_I2CWRCmd(VKL144A_ADDR5_0); 
;;;338    	if( 1 == VKL144A_I2CSlaveAck() )
;;;339    	{
;;;340    		VKL144A_I2CStop();													
;;;341    		return 0; 
;;;342    	}
;;;343    	VKL144A_I2CWRCmd(Addr&0x1f); 						
;;;344    	if( 1 == VKL144A_I2CSlaveAck() )
;;;345    	{
;;;346    		VKL144A_I2CStop();													
;;;347    		return 0;
;;;348    	}
;;;349    	//STOP信号
;;;350    	 VKL144A_I2CStop();	
;;;351    	//START信号	
;;;352    	VKL144A_I2CStart(); 									
;;;353    	//SLAVE地址读
;;;354    	VKL144A_I2CWRCmd(VKL144A_ADDRRD); 	
;;;355    	if( 1 == VKL144A_I2CSlaveAck() )
;;;356    	{
;;;357    		VKL144A_I2CStop();													
;;;358    		return 0;										
;;;359    	}	
;;;360    	//读Cnt个数据到显示RAM
;;;361    	for(n=0;n<Cnt-1;n++)
;;;362    	{ 
;;;363    		*Databuf++=VKL144A_I2CRDDat();
;;;364    		VKL144A_I2CSendAck();
;;;365    	}
;;;366    	*Databuf++=VKL144A_I2CRDDat();
;;;367    	VKL144A_I2CSendNAck();
;;;368    	//STOP信号
;;;369    	 VKL144A_I2CStop();											
;;;370    	 return 0;    
;;;371    }
0002bc  bdf0              POP      {r4-r7,pc}
                  |L1.702|
0002be  2d1f              CMP      r5,#0x1f              ;334
0002c0  dd03              BLE      |L1.714|
0002c2  20ec              MOVS     r0,#0xec              ;335
0002c4  f7fffffe          BL       VKL144A_I2CWRCmd
0002c8  e002              B        |L1.720|
                  |L1.714|
0002ca  20e8              MOVS     r0,#0xe8              ;337
0002cc  f7fffffe          BL       VKL144A_I2CWRCmd
                  |L1.720|
0002d0  f7fffffe          BL       VKL144A_I2CSlaveAck
0002d4  2801              CMP      r0,#1                 ;338
0002d6  d103              BNE      |L1.736|
0002d8  f7fffffe          BL       VKL144A_I2CStop
0002dc  2000              MOVS     r0,#0                 ;341
0002de  e7ed              B        |L1.700|
                  |L1.736|
0002e0  f005001f          AND      r0,r5,#0x1f           ;343
0002e4  f7fffffe          BL       VKL144A_I2CWRCmd
0002e8  f7fffffe          BL       VKL144A_I2CSlaveAck
0002ec  2801              CMP      r0,#1                 ;344
0002ee  d103              BNE      |L1.760|
0002f0  f7fffffe          BL       VKL144A_I2CStop
0002f4  2000              MOVS     r0,#0                 ;347
0002f6  e7e1              B        |L1.700|
                  |L1.760|
0002f8  f7fffffe          BL       VKL144A_I2CStop
0002fc  f7fffffe          BL       VKL144A_I2CStart
000300  207d              MOVS     r0,#0x7d              ;354
000302  f7fffffe          BL       VKL144A_I2CWRCmd
000306  f7fffffe          BL       VKL144A_I2CSlaveAck
00030a  2801              CMP      r0,#1                 ;355
00030c  d103              BNE      |L1.790|
00030e  f7fffffe          BL       VKL144A_I2CStop
000312  2000              MOVS     r0,#0                 ;358
000314  e7d2              B        |L1.700|
                  |L1.790|
000316  2600              MOVS     r6,#0                 ;361
000318  e007              B        |L1.810|
                  |L1.794|
00031a  f7fffffe          BL       VKL144A_I2CRDDat
00031e  f8040b01          STRB     r0,[r4],#1            ;363
000322  f7fffffe          BL       VKL144A_I2CSendAck
000326  1c70              ADDS     r0,r6,#1              ;361
000328  b2c6              UXTB     r6,r0                 ;361
                  |L1.810|
00032a  1e78              SUBS     r0,r7,#1              ;361
00032c  42b0              CMP      r0,r6                 ;361
00032e  dcf4              BGT      |L1.794|
000330  f7fffffe          BL       VKL144A_I2CRDDat
000334  f8040b01          STRB     r0,[r4],#1            ;366
000338  f7fffffe          BL       VKL144A_I2CSendNAck
00033c  f7fffffe          BL       VKL144A_I2CStop
000340  2000              MOVS     r0,#0                 ;370
000342  e7bb              B        |L1.700|
;;;372    /*******************************************************************************
                          ENDP

                  VKL144A_DisAll PROC
;;;379    *******************************************************************************/
;;;380    void VKL144A_DisAll(unsigned char dat)
000344  b530              PUSH     {r4,r5,lr}
;;;381    {
000346  4605              MOV      r5,r0
;;;382    	unsigned char segi;
;;;383    	
;;;384    	for(segi=0;segi<18;segi++)
000348  2400              MOVS     r4,#0
00034a  e003              B        |L1.852|
                  |L1.844|
;;;385    	{
;;;386    		VKL144A_dispram[segi]=dat;
00034c  4832              LDR      r0,|L1.1048|
00034e  5505              STRB     r5,[r0,r4]
000350  1c60              ADDS     r0,r4,#1              ;384
000352  b2c4              UXTB     r4,r0                 ;384
                  |L1.852|
000354  2c12              CMP      r4,#0x12              ;384
000356  dbf9              BLT      |L1.844|
;;;387    	}
;;;388    	WritenDataVKL144A(0,VKL144A_dispram,18);	//这里送8bit数据对应2个SEG，每4bit数据地址加1，每8位数据1个ACK
000358  2212              MOVS     r2,#0x12
00035a  492f              LDR      r1,|L1.1048|
00035c  2000              MOVS     r0,#0
00035e  f7fffffe          BL       WritenDataVKL144A
;;;389    }
000362  bd30              POP      {r4,r5,pc}
;;;390    /*******************************************************************************
                          ENDP

                  VKL144A_DisDotOn PROC
;;;397    *******************************************************************************/
;;;398    void VKL144A_DisDotOn(unsigned char seg,unsigned char com)
000364  b5f8              PUSH     {r3-r7,lr}
;;;399    {
000366  4604              MOV      r4,r0
000368  460d              MOV      r5,r1
;;;400    	unsigned char addrbyte,addrbit,tempdat;
;;;401    	
;;;402    	//计算com/seg对应的显示RAM地址和bit
;;;403    	addrbyte=seg/2*2;
00036a  4620              MOV      r0,r4
00036c  eb0471d0          ADD      r1,r4,r0,LSR #31
000370  1049              ASRS     r1,r1,#1
000372  0649              LSLS     r1,r1,#25
000374  0e0f              LSRS     r7,r1,#24
;;;404    	if((seg%2)==0)
000376  eb0471d0          ADD      r1,r4,r0,LSR #31
00037a  1049              ASRS     r1,r1,#1
00037c  eba40141          SUB      r1,r4,r1,LSL #1
000380  b919              CBNZ     r1,|L1.906|
;;;405    		addrbit=(1<<com);
000382  2001              MOVS     r0,#1
000384  40a8              LSLS     r0,r0,r5
000386  b2c6              UXTB     r6,r0
000388  e003              B        |L1.914|
                  |L1.906|
;;;406    	else
;;;407    		addrbit=(1<<(4+com));
00038a  1d28              ADDS     r0,r5,#4
00038c  2101              MOVS     r1,#1
00038e  4081              LSLS     r1,r1,r0
000390  b2ce              UXTB     r6,r1
                  |L1.914|
;;;408    	tempdat=VKL144A_dispram[seg/2]|addrbit;
000392  4620              MOV      r0,r4
000394  eb0471d0          ADD      r1,r4,r0,LSR #31
000398  1049              ASRS     r1,r1,#1
00039a  4a1f              LDR      r2,|L1.1048|
00039c  5c51              LDRB     r1,[r2,r1]
00039e  4331              ORRS     r1,r1,r6
0003a0  9100              STR      r1,[sp,#0]
;;;409    	VKL144A_dispram[seg/2]=tempdat;
0003a2  f89d1000          LDRB     r1,[sp,#0]
0003a6  eb0472d0          ADD      r2,r4,r0,LSR #31
0003aa  1052              ASRS     r2,r2,#1
0003ac  4b1a              LDR      r3,|L1.1048|
0003ae  5499              STRB     r1,[r3,r2]
;;;410    	WritenDataVKL144A(addrbyte,&tempdat,1);		//这里送8bit数据对应2个SEG，seg/com对应的bit置1，其余7bit不改变
0003b0  2201              MOVS     r2,#1
0003b2  4669              MOV      r1,sp
0003b4  4638              MOV      r0,r7
0003b6  f7fffffe          BL       WritenDataVKL144A
;;;411    }
0003ba  bdf8              POP      {r3-r7,pc}
;;;412    /*******************************************************************************
                          ENDP

                  VKL144A_DisDotOff PROC
;;;419    *******************************************************************************/
;;;420    void VKL144A_DisDotOff(unsigned char seg,unsigned char com)
0003bc  b5f8              PUSH     {r3-r7,lr}
;;;421    {
0003be  4604              MOV      r4,r0
0003c0  460d              MOV      r5,r1
;;;422    	unsigned char addrbyte,addrbit,tempdat;
;;;423    	
;;;424    	//计算com/seg对应的显示RAM地址和bit
;;;425    	addrbyte=seg/2*2;
0003c2  4620              MOV      r0,r4
0003c4  eb0471d0          ADD      r1,r4,r0,LSR #31
0003c8  1049              ASRS     r1,r1,#1
0003ca  0649              LSLS     r1,r1,#25
0003cc  0e0f              LSRS     r7,r1,#24
;;;426    	if((seg%2)==0)
0003ce  eb0471d0          ADD      r1,r4,r0,LSR #31
0003d2  1049              ASRS     r1,r1,#1
0003d4  eba40141          SUB      r1,r4,r1,LSL #1
0003d8  b919              CBNZ     r1,|L1.994|
;;;427    		addrbit=(1<<com);
0003da  2001              MOVS     r0,#1
0003dc  40a8              LSLS     r0,r0,r5
0003de  b2c6              UXTB     r6,r0
0003e0  e003              B        |L1.1002|
                  |L1.994|
;;;428    	else
;;;429    		addrbit=(1<<(4+com));
0003e2  1d28              ADDS     r0,r5,#4
0003e4  2101              MOVS     r1,#1
0003e6  4081              LSLS     r1,r1,r0
0003e8  b2ce              UXTB     r6,r1
                  |L1.1002|
;;;430    	tempdat=VKL144A_dispram[seg/2]&(~addrbit);
0003ea  4620              MOV      r0,r4
0003ec  eb0471d0          ADD      r1,r4,r0,LSR #31
0003f0  1049              ASRS     r1,r1,#1
0003f2  4a09              LDR      r2,|L1.1048|
0003f4  5c51              LDRB     r1,[r2,r1]
0003f6  43b1              BICS     r1,r1,r6
0003f8  9100              STR      r1,[sp,#0]
;;;431    	VKL144A_dispram[seg/2]=tempdat;
0003fa  f89d1000          LDRB     r1,[sp,#0]
0003fe  eb0472d0          ADD      r2,r4,r0,LSR #31
000402  1052              ASRS     r2,r2,#1
000404  4b04              LDR      r3,|L1.1048|
000406  5499              STRB     r1,[r3,r2]
;;;432    	WritenDataVKL144A(addrbyte,&tempdat,1);		//这里送8bit数据对应2个SEG，seg/com对应的bit清0，其余7bit不改变
000408  2201              MOVS     r2,#1
00040a  4669              MOV      r1,sp
00040c  4638              MOV      r0,r7
00040e  f7fffffe          BL       WritenDataVKL144A
;;;433    }
000412  bdf8              POP      {r3-r7,pc}
                  |L1.1044|
                          DCD      0x4000487c
                  |L1.1048|
                          DCD      VKL144A_dispram
                          ENDP

                  VKL144A_Enter_PowerOff PROC
;;;440    *******************************************************************************/
;;;441    unsigned char VKL144A_Enter_PowerOff(void)
00041c  b500              PUSH     {lr}
;;;442    {		
;;;443    	VKL144A_I2CStart();
00041e  f7fffffe          BL       VKL144A_I2CStart
;;;444    	VKL144A_I2CWRCmd(VKL144A_ADDRWR); 
000422  207c              MOVS     r0,#0x7c
000424  f7fffffe          BL       VKL144A_I2CWRCmd
;;;445    	if( 1 == VKL144A_I2CSlaveAck() )
000428  f7fffffe          BL       VKL144A_I2CSlaveAck
00042c  2801              CMP      r0,#1
00042e  d103              BNE      |L1.1080|
;;;446    	{
;;;447    		VKL144A_I2CStop();
000430  f7fffffe          BL       VKL144A_I2CStop
;;;448    		return 1; 
000434  2001              MOVS     r0,#1
                  |L1.1078|
;;;449    	}
;;;450    	VKL144A_I2CWRCmd(VKL144A_LCD_OFF);		//关显示
;;;451    	if( 1 == VKL144A_I2CSlaveAck() )
;;;452    	{
;;;453    		VKL144A_I2CStop();
;;;454    		return 1; 
;;;455    	}
;;;456    	VKL144A_I2CStop();
;;;457      return 0; 
;;;458    }
000436  bd00              POP      {pc}
                  |L1.1080|
000438  20c0              MOVS     r0,#0xc0              ;450
00043a  f7fffffe          BL       VKL144A_I2CWRCmd
00043e  f7fffffe          BL       VKL144A_I2CSlaveAck
000442  2801              CMP      r0,#1                 ;451
000444  d103              BNE      |L1.1102|
000446  f7fffffe          BL       VKL144A_I2CStop
00044a  2001              MOVS     r0,#1                 ;454
00044c  e7f3              B        |L1.1078|
                  |L1.1102|
00044e  f7fffffe          BL       VKL144A_I2CStop
000452  2000              MOVS     r0,#0                 ;457
000454  e7ef              B        |L1.1078|
;;;459    /*******************************************************************************
                          ENDP

                  VKL144A_InitSequence PROC
;;;481    *******************************************************************************/
;;;482    unsigned char VKL144A_InitSequence(void)
000456  b500              PUSH     {lr}
;;;483    {			
;;;484      //上电初始化时序（参考数据手册上电复位时序图和参数）	
;;;485    	//上电100uS后初始化
;;;486      Delay_nuS(100);
000458  2064              MOVS     r0,#0x64
00045a  f7fffffe          BL       Delay_nuS
;;;487    	//STOP信号
;;;488    	VKL144A_I2CStop();
00045e  f7fffffe          BL       VKL144A_I2CStop
;;;489    	//START信号
;;;490    	VKL144A_I2CStart();
000462  f7fffffe          BL       VKL144A_I2CStart
;;;491    	//发送SLAVE地址(0x7C)
;;;492    	VKL144A_I2CWRCmd(VKL144A_ADDRWR); 
000466  207c              MOVS     r0,#0x7c
000468  f7fffffe          BL       VKL144A_I2CWRCmd
;;;493    	if( 1 == VKL144A_I2CSlaveAck() )
00046c  f7fffffe          BL       VKL144A_I2CSlaveAck
000470  2801              CMP      r0,#1
000472  d103              BNE      |L1.1148|
;;;494    	{
;;;495    		VKL144A_I2CStop();	
000474  f7fffffe          BL       VKL144A_I2CStop
;;;496    		return 1;
000478  2001              MOVS     r0,#1
                  |L1.1146|
;;;497    	}
;;;498    	//系统设置命令(软复位)
;;;499    	VKL144A_I2CWRCmd(VKL144A_SOFTRST);
;;;500    	if( 1 == VKL144A_I2CSlaveAck() )
;;;501    	{
;;;502    		VKL144A_I2CStop();	
;;;503    		return 1;
;;;504    	}
;;;505    	//显示控制命令(设置帧频，功耗模式和驱动方式)，电流为实测样品值，仅供参考
;;;506    	//VKL144A_I2CWRCmd(VKL144A_FR80HZ|VKL144A_SRNOR|VKL144A_LINER);  	//上电默认 	VDD=5V:18.2uA  	VDD=3.3V:13uA
;;;507    	VKL144A_I2CWRCmd(VKL144A_FR53HZ|VKL144A_SRPM1|VKL144A_FRAMER);  //最省电 		VDD=5V:9.1uA  VDD=3.3V:6.8uA
;;;508    	//VKL144A_I2CWRCmd(VKL144A_FR80HZ|VKL144A_SRHP|VKL144A_LINER);  	//电流最大 			VDD=5V:20uA  	VDD=3.3V:15uA 
;;;509    	if( 1 == VKL144A_I2CSlaveAck() )
;;;510    	{
;;;511    		VKL144A_I2CStop();	
;;;512    		return 1;
;;;513    	}
;;;514      //模式设置命令
;;;515    	VKL144A_I2CWRCmd(VKL144A_BIAS_1_3|VKL144A_LCD_ON);		//1/3bias,打开显示 
;;;516    	//VKL144A_I2CWRCmd(VKL144A_BIAS_1_2|VKL144A_LCD_ON);		//1/2bias,打开显示 
;;;517    	if( 1 == VKL144A_I2CSlaveAck() )
;;;518    	{
;;;519    		VKL144A_I2CStop();	
;;;520    		return 1;
;;;521    	}
;;;522    	//STOP信号
;;;523    	VKL144A_I2CStop();	
;;;524    		
;;;525      return  0; 
;;;526    }
00047a  bd00              POP      {pc}
                  |L1.1148|
00047c  20ea              MOVS     r0,#0xea              ;499
00047e  f7fffffe          BL       VKL144A_I2CWRCmd
000482  f7fffffe          BL       VKL144A_I2CSlaveAck
000486  2801              CMP      r0,#1                 ;500
000488  d103              BNE      |L1.1170|
00048a  f7fffffe          BL       VKL144A_I2CStop
00048e  2001              MOVS     r0,#1                 ;503
000490  e7f3              B        |L1.1146|
                  |L1.1170|
000492  20bc              MOVS     r0,#0xbc              ;507
000494  f7fffffe          BL       VKL144A_I2CWRCmd
000498  f7fffffe          BL       VKL144A_I2CSlaveAck
00049c  2801              CMP      r0,#1                 ;509
00049e  d103              BNE      |L1.1192|
0004a0  f7fffffe          BL       VKL144A_I2CStop
0004a4  2001              MOVS     r0,#1                 ;512
0004a6  e7e8              B        |L1.1146|
                  |L1.1192|
0004a8  20c8              MOVS     r0,#0xc8              ;515
0004aa  f7fffffe          BL       VKL144A_I2CWRCmd
0004ae  f7fffffe          BL       VKL144A_I2CSlaveAck
0004b2  2801              CMP      r0,#1                 ;517
0004b4  d103              BNE      |L1.1214|
0004b6  f7fffffe          BL       VKL144A_I2CStop
0004ba  2001              MOVS     r0,#1                 ;520
0004bc  e7dd              B        |L1.1146|
                  |L1.1214|
0004be  f7fffffe          BL       VKL144A_I2CStop
0004c2  2000              MOVS     r0,#0                 ;525
0004c4  e7d9              B        |L1.1146|
;;;527    /*******************************************************************************
                          ENDP

                  VKL144A_Exit_PowerOff PROC
;;;465    *******************************************************************************/
;;;466    unsigned char VKL144A_Exit_PowerOff(void)
0004c6  b510              PUSH     {r4,lr}
;;;467    {	
;;;468    	unsigned char errorflag; 
;;;469    	
;;;470    	//退出掉电模式重新初始化时序
;;;471    	errorflag=VKL144A_InitSequence();
0004c8  f7fffffe          BL       VKL144A_InitSequence
0004cc  4604              MOV      r4,r0
;;;472    	
;;;473      return(errorflag);
0004ce  4620              MOV      r0,r4
;;;474    }
0004d0  bd10              POP      {r4,pc}
;;;475    /*******************************************************************************
                          ENDP

                  VKL144A_Lowlevel_Init PROC
;;;533    *******************************************************************************/
;;;534    void VKL144A_Lowlevel_Init(void)
0004d2  b510              PUSH     {r4,lr}
;;;535    {
;;;536    	//通信线电平不同，建议加电平转换电路
;;;537    	//此函数根据客户单片机做相应的修改	
;;;538    	GPIO_SetMode(VKL144A_SCL_PORT, VKL144A_SCL_PIN, GPIO_MODE_OUTPUT);
0004d4  2201              MOVS     r2,#1
0004d6  03d1              LSLS     r1,r2,#15
0004d8  4864              LDR      r0,|L1.1644|
0004da  f7fffffe          BL       GPIO_SetMode
;;;539    	GPIO_SetMode(VKL144A_SDA_PORT, VKL144A_SDA_PIN, GPIO_MODE_QUASI);
0004de  2203              MOVS     r2,#3
0004e0  2120              MOVS     r1,#0x20
0004e2  4862              LDR      r0,|L1.1644|
0004e4  f7fffffe          BL       GPIO_SetMode
;;;540    	
;;;541      //I2C总线空闲为高电平	
;;;542    	VKL144A_SCL_H();  
0004e8  2001              MOVS     r0,#1
0004ea  4961              LDR      r1,|L1.1648|
0004ec  6008              STR      r0,[r1,#0]
;;;543    	VKL144A_SDA_H(); 	
0004ee  4960              LDR      r1,|L1.1648|
0004f0  3928              SUBS     r1,r1,#0x28
0004f2  6008              STR      r0,[r1,#0]
;;;544    }
0004f4  bd10              POP      {r4,pc}
;;;545    /*******************************************************************************
                          ENDP

                  VKL144A_Init PROC
;;;551    *******************************************************************************/
;;;552    void VKL144A_Init(void)
0004f6  b510              PUSH     {r4,lr}
;;;553    {	
;;;554    	//管脚配置根据客户单片机做相应的修改
;;;555    	VKL144A_Lowlevel_Init();
0004f8  f7fffffe          BL       VKL144A_Lowlevel_Init
;;;556    	//初始化时序
;;;557    	VKL144A_InitSequence();
0004fc  f7fffffe          BL       VKL144A_InitSequence
;;;558    }
000500  bd10              POP      {r4,pc}
;;;559    /*******************************************************************************
                          ENDP

                  VKL144A_Main PROC
;;;565    *******************************************************************************/
;;;566    void VKL144A_Main(void)
000502  f7fffffe          BL       VKL144A_Init
;;;567    {	
;;;568    	VKL144A_Init();
;;;569    	
;;;570    	//选择外部时钟(OSCI脚)频率为32KHz(根据实际帧频修正这个频率)
;;;571    	//WriteCmdVKL144A(VKL144A_EXTCLK); //设置显示地址时VKL144A_ADDRWR5的bit0一定要置1
;;;572    	
;;;573    	//整体闪烁命令
;;;574    	//WriteCmdVKL144A(VKL144A_BLKCTL_05HZ); //闪烁频率0.5Hz
;;;575    	//WriteCmdVKL144A(VKL144A_BLKCTL_1HZ); 	//闪烁频率1Hz
;;;576    	WriteCmdVKL144A(VKL144A_BLKCTL_2HZ); 	//闪烁频率2Hz
000506  20f3              MOVS     r0,#0xf3
000508  f7fffffe          BL       WriteCmdVKL144A
;;;577    	//WriteCmdVKL144A(VKL144A_BLKCTL_OFF);	//闪烁关闭
;;;578    	
;;;579    	//全屏强制开命令
;;;580    	WriteCmdVKL144A(VKL144A_APCTL_ALLON2);	
00050c  20fe              MOVS     r0,#0xfe
00050e  f7fffffe          BL       WriteCmdVKL144A
;;;581    	Delay_nmS(3000);					//延时
000512  f64030b8          MOV      r0,#0xbb8
000516  f7fffffe          BL       Delay_nmS
;;;582    	//全屏强制关命令
;;;583    	WriteCmdVKL144A(VKL144A_APCTL_ALLOFF1);
00051a  20fd              MOVS     r0,#0xfd
00051c  f7fffffe          BL       WriteCmdVKL144A
;;;584    	Delay_nmS(1000);					//延时
000520  f44f707a          MOV      r0,#0x3e8
000524  f7fffffe          BL       Delay_nmS
;;;585    	
;;;586    	//全屏强制取消,恢复正常
;;;587    	WriteCmdVKL144A(VKL144A_APCTL_NORMAL);
000528  20fc              MOVS     r0,#0xfc
00052a  f7fffffe          BL       WriteCmdVKL144A
;;;588    	WriteCmdVKL144A(VKL144A_BLKCTL_OFF);	//闪烁关闭
00052e  20f0              MOVS     r0,#0xf0
000530  f7fffffe          BL       WriteCmdVKL144A
;;;589    	
;;;590    	VKL144A_DisAll(0x00);
000534  2000              MOVS     r0,#0
000536  f7fffffe          BL       VKL144A_DisAll
;;;591    	while(1)
00053a  e096              B        |L1.1642|
                  |L1.1340|
;;;592    	{		
;;;593    		//LCD全显
;;;594    		VKL144A_DisAll(0xFF);			
00053c  20ff              MOVS     r0,#0xff
00053e  f7fffffe          BL       VKL144A_DisAll
;;;595    		Delay_nmS(3000);					//延时
000542  f64030b8          MOV      r0,#0xbb8
000546  f7fffffe          BL       Delay_nmS
;;;596    		
;;;597    		//LCD全关
;;;598    		VKL144A_DisAll(0x00);			
00054a  2000              MOVS     r0,#0
00054c  f7fffffe          BL       VKL144A_DisAll
;;;599    		Delay_nmS(3000);					//延时
000550  f64030b8          MOV      r0,#0xbb8
000554  f7fffffe          BL       Delay_nmS
;;;600    	
;;;601    		//LCD半显
;;;602    		VKL144A_DisAll(0x55);			
000558  2055              MOVS     r0,#0x55
00055a  f7fffffe          BL       VKL144A_DisAll
;;;603    		ReadnDataVKL144A(0,VKL144A_readbuf,18);	//读回RAM数据
00055e  2212              MOVS     r2,#0x12
000560  4944              LDR      r1,|L1.1652|
000562  2000              MOVS     r0,#0
000564  f7fffffe          BL       ReadnDataVKL144A
;;;604    		Delay_nmS(1500);					//延时
000568  f24050dc          MOV      r0,#0x5dc
00056c  f7fffffe          BL       Delay_nmS
;;;605    		VKL144A_DisAll(0xAA);			
000570  20aa              MOVS     r0,#0xaa
000572  f7fffffe          BL       VKL144A_DisAll
;;;606    		ReadnDataVKL144A(0,VKL144A_readbuf,18);	//读回RAM数据
000576  2212              MOVS     r2,#0x12
000578  493e              LDR      r1,|L1.1652|
00057a  2000              MOVS     r0,#0
00057c  f7fffffe          BL       ReadnDataVKL144A
;;;607    		Delay_nmS(1500);					//延时
000580  f24050dc          MOV      r0,#0x5dc
000584  f7fffffe          BL       Delay_nmS
;;;608    		
;;;609    		//掉电
;;;610    		VKL144A_DisAll(0x00);			//LCD全关		
000588  2000              MOVS     r0,#0
00058a  f7fffffe          BL       VKL144A_DisAll
;;;611    		VKL144A_Enter_PowerOff();	//进入掉电模式
00058e  f7fffffe          BL       VKL144A_Enter_PowerOff
;;;612    		Delay_nmS(5000);					//延时5S		
000592  f2413088          MOV      r0,#0x1388
000596  f7fffffe          BL       Delay_nmS
;;;613    		VKL144A_Exit_PowerOff();	//退出掉电模式
00059a  f7fffffe          BL       VKL144A_Exit_PowerOff
;;;614    				
;;;615    		//LCD单点点亮
;;;616    		VKL144A_DisAll(0x00);			//LCD全关
00059e  2000              MOVS     r0,#0
0005a0  f7fffffe          BL       VKL144A_DisAll
;;;617    		Delay_nmS(500);						//延时
0005a4  f44f70fa          MOV      r0,#0x1f4
0005a8  f7fffffe          BL       Delay_nmS
;;;618    		for(VKL144A_segi=0;VKL144A_segi<36;VKL144A_segi++)//seg0-35
0005ac  2000              MOVS     r0,#0
0005ae  4932              LDR      r1,|L1.1656|
0005b0  7008              STRB     r0,[r1,#0]
0005b2  e021              B        |L1.1528|
                  |L1.1460|
;;;619    		{
;;;620    			for(VKL144A_comi=0;VKL144A_comi<4;VKL144A_comi++)//com0-3
0005b4  2000              MOVS     r0,#0
0005b6  4931              LDR      r1,|L1.1660|
0005b8  7008              STRB     r0,[r1,#0]
0005ba  e014              B        |L1.1510|
                  |L1.1468|
;;;621    			{
;;;622    				VKL144A_DisDotOn(VKL144A_segi,VKL144A_comi);		//LCD单点点亮
0005bc  482f              LDR      r0,|L1.1660|
0005be  7801              LDRB     r1,[r0,#0]  ; VKL144A_comi
0005c0  482d              LDR      r0,|L1.1656|
0005c2  7800              LDRB     r0,[r0,#0]  ; VKL144A_segi
0005c4  f7fffffe          BL       VKL144A_DisDotOn
;;;623    				Delay_nmS(300);				//延时
0005c8  f44f7096          MOV      r0,#0x12c
0005cc  f7fffffe          BL       Delay_nmS
;;;624    				VKL144A_DisDotOff(VKL144A_segi,VKL144A_comi);		//此行配合单点点亮函数实现单点点亮，屏蔽此行顺序点亮
0005d0  482a              LDR      r0,|L1.1660|
0005d2  7801              LDRB     r1,[r0,#0]  ; VKL144A_comi
0005d4  4828              LDR      r0,|L1.1656|
0005d6  7800              LDRB     r0,[r0,#0]  ; VKL144A_segi
0005d8  f7fffffe          BL       VKL144A_DisDotOff
0005dc  4827              LDR      r0,|L1.1660|
0005de  7800              LDRB     r0,[r0,#0]            ;620  ; VKL144A_comi
0005e0  1c40              ADDS     r0,r0,#1              ;620
0005e2  4926              LDR      r1,|L1.1660|
0005e4  7008              STRB     r0,[r1,#0]            ;620
                  |L1.1510|
0005e6  4825              LDR      r0,|L1.1660|
0005e8  7800              LDRB     r0,[r0,#0]            ;620  ; VKL144A_comi
0005ea  2804              CMP      r0,#4                 ;620
0005ec  dbe6              BLT      |L1.1468|
0005ee  4822              LDR      r0,|L1.1656|
0005f0  7800              LDRB     r0,[r0,#0]            ;618  ; VKL144A_segi
0005f2  1c40              ADDS     r0,r0,#1              ;618
0005f4  4920              LDR      r1,|L1.1656|
0005f6  7008              STRB     r0,[r1,#0]            ;618
                  |L1.1528|
0005f8  481f              LDR      r0,|L1.1656|
0005fa  7800              LDRB     r0,[r0,#0]            ;618  ; VKL144A_segi
0005fc  2824              CMP      r0,#0x24              ;618
0005fe  dbd9              BLT      |L1.1460|
;;;625    			}
;;;626    		}
;;;627    		
;;;628    		//LCD单点关闭
;;;629    		VKL144A_DisAll(0xff);			//LCD全显
000600  20ff              MOVS     r0,#0xff
000602  f7fffffe          BL       VKL144A_DisAll
;;;630    		Delay_nmS(500);						//延时
000606  f44f70fa          MOV      r0,#0x1f4
00060a  f7fffffe          BL       Delay_nmS
;;;631    		for(VKL144A_segi=0;VKL144A_segi<36;VKL144A_segi++)//seg0-35
00060e  2000              MOVS     r0,#0
000610  4919              LDR      r1,|L1.1656|
000612  7008              STRB     r0,[r1,#0]
000614  e021              B        |L1.1626|
                  |L1.1558|
;;;632    		{
;;;633    			for(VKL144A_comi=0;VKL144A_comi<4;VKL144A_comi++)//com0-3
000616  2000              MOVS     r0,#0
000618  4918              LDR      r1,|L1.1660|
00061a  7008              STRB     r0,[r1,#0]
00061c  e014              B        |L1.1608|
                  |L1.1566|
;;;634    			{
;;;635    				VKL144A_DisDotOff(VKL144A_segi,VKL144A_comi);		//LCD单点关闭
00061e  4817              LDR      r0,|L1.1660|
000620  7801              LDRB     r1,[r0,#0]  ; VKL144A_comi
000622  4815              LDR      r0,|L1.1656|
000624  7800              LDRB     r0,[r0,#0]  ; VKL144A_segi
000626  f7fffffe          BL       VKL144A_DisDotOff
;;;636    				Delay_nmS(300);				//延时
00062a  f44f7096          MOV      r0,#0x12c
00062e  f7fffffe          BL       Delay_nmS
;;;637    				VKL144A_DisDotOn(VKL144A_segi,VKL144A_comi);		//此行配合单点关闭函数实现单点关闭，屏蔽此行顺序关闭
000632  4812              LDR      r0,|L1.1660|
000634  7801              LDRB     r1,[r0,#0]  ; VKL144A_comi
000636  4810              LDR      r0,|L1.1656|
000638  7800              LDRB     r0,[r0,#0]  ; VKL144A_segi
00063a  f7fffffe          BL       VKL144A_DisDotOn
00063e  480f              LDR      r0,|L1.1660|
000640  7800              LDRB     r0,[r0,#0]            ;633  ; VKL144A_comi
000642  1c40              ADDS     r0,r0,#1              ;633
000644  490d              LDR      r1,|L1.1660|
000646  7008              STRB     r0,[r1,#0]            ;633
                  |L1.1608|
000648  480c              LDR      r0,|L1.1660|
00064a  7800              LDRB     r0,[r0,#0]            ;633  ; VKL144A_comi
00064c  2804              CMP      r0,#4                 ;633
00064e  dbe6              BLT      |L1.1566|
000650  4809              LDR      r0,|L1.1656|
000652  7800              LDRB     r0,[r0,#0]            ;631  ; VKL144A_segi
000654  1c40              ADDS     r0,r0,#1              ;631
000656  4908              LDR      r1,|L1.1656|
000658  7008              STRB     r0,[r1,#0]            ;631
                  |L1.1626|
00065a  4807              LDR      r0,|L1.1656|
00065c  7800              LDRB     r0,[r0,#0]            ;631  ; VKL144A_segi
00065e  2824              CMP      r0,#0x24              ;631
000660  dbd9              BLT      |L1.1558|
;;;638    			}
;;;639    		}		
;;;640    		Delay_nmS(1000);					//延时
000662  f44f707a          MOV      r0,#0x3e8
000666  f7fffffe          BL       Delay_nmS
                  |L1.1642|
00066a  e767              B        |L1.1340|
;;;641    	}
;;;642    }
;;;643    /************************END OF FILE****/
                          ENDP

                  |L1.1644|
                          DCD      0x40004040
                  |L1.1648|
                          DCD      0x4000487c
                  |L1.1652|
                          DCD      VKL144A_readbuf
                  |L1.1656|
                          DCD      VKL144A_segi
                  |L1.1660|
                          DCD      VKL144A_comi

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  VKL144A_dispram
                          %        18
                  VKL144A_readbuf
                          %        18

                          AREA ||.data||, DATA, ALIGN=0

                  VKL144A_segi
000000  00                DCB      0x00
                  VKL144A_comi
000001  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\lcd_driver\\VKL144A_IO_I2C_QUASI.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_VKL144A_IO_I2C_QUASI_c_f70de489____REV16|
#line 114 "..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___22_VKL144A_IO_I2C_QUASI_c_f70de489____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_VKL144A_IO_I2C_QUASI_c_f70de489____REVSH|
#line 128
|__asm___22_VKL144A_IO_I2C_QUASI_c_f70de489____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
