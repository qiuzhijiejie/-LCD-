; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\vkl060_io_i2c_quasi.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\vkl060_io_i2c_quasi.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M451Series\Include -I..\..\..\Library\StdDriver\inc -I..\Bsp -I..\User -I..\lcd_driver -I..\exti_driver -I..\led_driver -I..\touch -I..\dotmatix_lcd -I..\KH -ID:\工作\A工程资料\LCD\低功耗系列_VKL\VKL例程\VKL060_TESTCODE\project\VKL060_FUNC\Keil\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -D__UVISION_VERSION=515 -D_RTE_ --omf_browse=.\obj\vkl060_io_i2c_quasi.crf ..\lcd_driver\VKL060_IO_I2C_QUASI.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Delay_nuS PROC
;;;35     *******************************************************************************/
;;;36     void Delay_nuS(unsigned int n)	   
000000  e007              B        |L1.18|
                  |L1.2|
;;;37     {
;;;38     	unsigned char i;
;;;39     	while(n--)
;;;40     	{
;;;41     		i=10;
000002  210a              MOVS     r1,#0xa
;;;42     		while(i--)
000004  e000              B        |L1.8|
                  |L1.6|
;;;43     		{//nop指令根据单片机做相应的修改
;;;44     			__nop();
000006  bf00              NOP      
                  |L1.8|
000008  000a              MOVS     r2,r1                 ;42
00000a  f1a10301          SUB      r3,r1,#1              ;42
00000e  b2d9              UXTB     r1,r3                 ;42
000010  d1f9              BNE      |L1.6|
                  |L1.18|
000012  0002              MOVS     r2,r0                 ;39
000014  f1a00001          SUB      r0,r0,#1              ;39
000018  d1f3              BNE      |L1.2|
;;;45     		}
;;;46     	}
;;;47     }
00001a  4770              BX       lr
;;;48     /*******************************************************************************
                          ENDP

                  Delay_nmS PROC
;;;54     *******************************************************************************/
;;;55     void Delay_nmS(unsigned long int n)
00001c  b510              PUSH     {r4,lr}
;;;56     {
00001e  4604              MOV      r4,r0
;;;57     	while(n--)
000020  e003              B        |L1.42|
                  |L1.34|
;;;58     	{
;;;59     		Delay_nuS(1000);
000022  f44f707a          MOV      r0,#0x3e8
000026  f7fffffe          BL       Delay_nuS
                  |L1.42|
00002a  0020              MOVS     r0,r4                 ;57
00002c  f1a40401          SUB      r4,r4,#1              ;57
000030  d1f7              BNE      |L1.34|
;;;60     	}
;;;61     }
000032  bd10              POP      {r4,pc}
;;;62     /*******************************************************************************
                          ENDP

                  VKL060_I2CStart PROC
;;;68     *******************************************************************************/
;;;69     void VKL060_I2CStart( void )
000034  b500              PUSH     {lr}
;;;70     {
;;;71       VKL060_SCL_H();
000036  2001              MOVS     r0,#1
000038  49fe              LDR      r1,|L1.1076|
00003a  6008              STR      r0,[r1,#0]
;;;72       VKL060_SDA_H();
00003c  49fd              LDR      r1,|L1.1076|
00003e  3928              SUBS     r1,r1,#0x28
000040  6008              STR      r0,[r1,#0]
;;;73       Delay_nuS(VKL060_CLK);
000042  2005              MOVS     r0,#5
000044  f7fffffe          BL       Delay_nuS
;;;74       VKL060_SDA_L();
000048  2000              MOVS     r0,#0
00004a  49fa              LDR      r1,|L1.1076|
00004c  3928              SUBS     r1,r1,#0x28
00004e  6008              STR      r0,[r1,#0]
;;;75       Delay_nuS(VKL060_CLK);
000050  2005              MOVS     r0,#5
000052  f7fffffe          BL       Delay_nuS
;;;76     }
000056  bd00              POP      {pc}
;;;77     /*******************************************************************************
                          ENDP

                  VKL060_I2CStop PROC
;;;83     *******************************************************************************/
;;;84     void VKL060_I2CStop( void )
000058  b500              PUSH     {lr}
;;;85     {
;;;86       VKL060_SCL_H();
00005a  2001              MOVS     r0,#1
00005c  49f5              LDR      r1,|L1.1076|
00005e  6008              STR      r0,[r1,#0]
;;;87       VKL060_SDA_L();
000060  2000              MOVS     r0,#0
000062  49f4              LDR      r1,|L1.1076|
000064  3928              SUBS     r1,r1,#0x28
000066  6008              STR      r0,[r1,#0]
;;;88       Delay_nuS(VKL060_CLK);
000068  2005              MOVS     r0,#5
00006a  f7fffffe          BL       Delay_nuS
;;;89       VKL060_SDA_H();
00006e  2001              MOVS     r0,#1
000070  49f0              LDR      r1,|L1.1076|
000072  3928              SUBS     r1,r1,#0x28
000074  6008              STR      r0,[r1,#0]
;;;90       Delay_nuS(VKL060_CLK);
000076  2005              MOVS     r0,#5
000078  f7fffffe          BL       Delay_nuS
;;;91     }
00007c  bd00              POP      {pc}
;;;92     /*******************************************************************************
                          ENDP

                  VKL060_I2CSlaveAck PROC
;;;98     *******************************************************************************/
;;;99     unsigned char VKL060_I2CSlaveAck( void )
00007e  b530              PUSH     {r4,r5,lr}
;;;100    {
;;;101      unsigned int TimeOut;
;;;102      unsigned char RetValue;
;;;103    	
;;;104      VKL060_SCL_L();
000080  2000              MOVS     r0,#0
000082  49ec              LDR      r1,|L1.1076|
000084  6008              STR      r0,[r1,#0]
;;;105      Delay_nuS(VKL060_CLK);
000086  2005              MOVS     r0,#5
000088  f7fffffe          BL       Delay_nuS
;;;106      VKL060_SCL_H();//第9个SCL时钟上升沿
00008c  2001              MOVS     r0,#1
00008e  49e9              LDR      r1,|L1.1076|
000090  6008              STR      r0,[r1,#0]
;;;107      TimeOut = 10000;
000092  f2427510          MOV      r5,#0x2710
;;;108      while( TimeOut-- > 0 )
000096  e007              B        |L1.168|
                  |L1.152|
;;;109      {
;;;110        if( VKL060_GET_SDA()!=0 )//读取ack
000098  48e6              LDR      r0,|L1.1076|
00009a  3828              SUBS     r0,r0,#0x28
00009c  6800              LDR      r0,[r0,#0]
00009e  b108              CBZ      r0,|L1.164|
;;;111        {
;;;112          RetValue = 1;
0000a0  2401              MOVS     r4,#1
0000a2  e001              B        |L1.168|
                  |L1.164|
;;;113        }
;;;114        else
;;;115        {
;;;116          RetValue = 0;
0000a4  2400              MOVS     r4,#0
;;;117          break;
0000a6  e003              B        |L1.176|
                  |L1.168|
0000a8  0028              MOVS     r0,r5                 ;108
0000aa  f1a50501          SUB      r5,r5,#1              ;108
0000ae  d1f3              BNE      |L1.152|
                  |L1.176|
0000b0  bf00              NOP      
;;;118        }
;;;119      } 
;;;120    	VKL060_SCL_L(); //下一个时序可能为命令,数据或者STOP信号。
0000b2  2000              MOVS     r0,#0
0000b4  49df              LDR      r1,|L1.1076|
0000b6  6008              STR      r0,[r1,#0]
;;;121      
;;;122      return RetValue;
0000b8  4620              MOV      r0,r4
;;;123    }
0000ba  bd30              POP      {r4,r5,pc}
;;;124    /*******************************************************************************
                          ENDP

                  VKL060_I2CSendAck PROC
;;;130    *******************************************************************************/
;;;131    void VKL060_I2CSendAck( void )
0000bc  b500              PUSH     {lr}
;;;132    {
;;;133      VKL060_SCL_L();
0000be  2000              MOVS     r0,#0
0000c0  49dc              LDR      r1,|L1.1076|
0000c2  6008              STR      r0,[r1,#0]
;;;134      VKL060_SDA_L();
0000c4  49db              LDR      r1,|L1.1076|
0000c6  3928              SUBS     r1,r1,#0x28
0000c8  6008              STR      r0,[r1,#0]
;;;135      Delay_nuS(VKL060_CLK*2);
0000ca  200a              MOVS     r0,#0xa
0000cc  f7fffffe          BL       Delay_nuS
;;;136      VKL060_SCL_H();
0000d0  2001              MOVS     r0,#1
0000d2  49d8              LDR      r1,|L1.1076|
0000d4  6008              STR      r0,[r1,#0]
;;;137      Delay_nuS(VKL060_CLK*2);
0000d6  200a              MOVS     r0,#0xa
0000d8  f7fffffe          BL       Delay_nuS
;;;138      VKL060_SCL_L();
0000dc  2000              MOVS     r0,#0
0000de  49d5              LDR      r1,|L1.1076|
0000e0  6008              STR      r0,[r1,#0]
;;;139      VKL060_SDA_H();
0000e2  2001              MOVS     r0,#1
0000e4  49d3              LDR      r1,|L1.1076|
0000e6  3928              SUBS     r1,r1,#0x28
0000e8  6008              STR      r0,[r1,#0]
;;;140    }
0000ea  bd00              POP      {pc}
;;;141    /*******************************************************************************
                          ENDP

                  VKL060_I2CSendNAck PROC
;;;147    *******************************************************************************/
;;;148    void VKL060_I2CSendNAck( void )
0000ec  b500              PUSH     {lr}
;;;149    {
;;;150      VKL060_SCL_L();
0000ee  2000              MOVS     r0,#0
0000f0  49d0              LDR      r1,|L1.1076|
0000f2  6008              STR      r0,[r1,#0]
;;;151      VKL060_SDA_H();
0000f4  2001              MOVS     r0,#1
0000f6  49cf              LDR      r1,|L1.1076|
0000f8  3928              SUBS     r1,r1,#0x28
0000fa  6008              STR      r0,[r1,#0]
;;;152      Delay_nuS(VKL060_CLK);
0000fc  2005              MOVS     r0,#5
0000fe  f7fffffe          BL       Delay_nuS
;;;153      VKL060_SCL_H();
000102  2001              MOVS     r0,#1
000104  49cb              LDR      r1,|L1.1076|
000106  6008              STR      r0,[r1,#0]
;;;154      Delay_nuS(VKL060_CLK);
000108  2005              MOVS     r0,#5
00010a  f7fffffe          BL       Delay_nuS
;;;155    }
00010e  bd00              POP      {pc}
;;;156    /*******************************************************************************
                          ENDP

                  VKL060_I2CWRCmd PROC
;;;162    *******************************************************************************/
;;;163    void VKL060_I2CWRCmd( unsigned char cmd )
000110  b530              PUSH     {r4,r5,lr}
;;;164    {
000112  4604              MOV      r4,r0
;;;165    	unsigned char i=8;
000114  2508              MOVS     r5,#8
;;;166    	
;;;167    	while (i--)
000116  e019              B        |L1.332|
                  |L1.280|
;;;168    	{ 
;;;169    		VKL060_SCL_L();
000118  2000              MOVS     r0,#0
00011a  49c6              LDR      r1,|L1.1076|
00011c  6008              STR      r0,[r1,#0]
;;;170    		if(cmd&0x80)
00011e  f0040080          AND      r0,r4,#0x80
000122  b120              CBZ      r0,|L1.302|
;;;171    			VKL060_SDA_H();
000124  2001              MOVS     r0,#1
000126  49c3              LDR      r1,|L1.1076|
000128  3928              SUBS     r1,r1,#0x28
00012a  6008              STR      r0,[r1,#0]
00012c  e003              B        |L1.310|
                  |L1.302|
;;;172    		else
;;;173    			VKL060_SDA_L();
00012e  2000              MOVS     r0,#0
000130  49c0              LDR      r1,|L1.1076|
000132  3928              SUBS     r1,r1,#0x28
000134  6008              STR      r0,[r1,#0]
                  |L1.310|
;;;174    		cmd<<=1; 
000136  0660              LSLS     r0,r4,#25
000138  0e04              LSRS     r4,r0,#24
;;;175    		Delay_nuS(VKL060_CLK);
00013a  2005              MOVS     r0,#5
00013c  f7fffffe          BL       Delay_nuS
;;;176    		VKL060_SCL_H();     
000140  2001              MOVS     r0,#1
000142  49bc              LDR      r1,|L1.1076|
000144  6008              STR      r0,[r1,#0]
;;;177    		Delay_nuS(VKL060_CLK);
000146  2005              MOVS     r0,#5
000148  f7fffffe          BL       Delay_nuS
                  |L1.332|
00014c  0028              MOVS     r0,r5                 ;167
00014e  f1a50101          SUB      r1,r5,#1              ;167
000152  b2cd              UXTB     r5,r1                 ;167
000154  d1e0              BNE      |L1.280|
;;;178    	}
;;;179    }
000156  bd30              POP      {r4,r5,pc}
;;;180    /*******************************************************************************
                          ENDP

                  VKL060_I2CWRDat PROC
;;;186    *******************************************************************************/
;;;187    void VKL060_I2CWRDat( unsigned char dat )
000158  b530              PUSH     {r4,r5,lr}
;;;188    {
00015a  4604              MOV      r4,r0
;;;189    	unsigned char i=8;
00015c  2508              MOVS     r5,#8
;;;190    	while (i--)
00015e  e018              B        |L1.402|
                  |L1.352|
;;;191    	{ 
;;;192    		VKL060_SCL_L();
000160  2000              MOVS     r0,#0
000162  49b4              LDR      r1,|L1.1076|
000164  6008              STR      r0,[r1,#0]
;;;193    		if(dat&0x01)
000166  f0040001          AND      r0,r4,#1
00016a  b120              CBZ      r0,|L1.374|
;;;194    			VKL060_SDA_H();
00016c  2001              MOVS     r0,#1
00016e  49b1              LDR      r1,|L1.1076|
000170  3928              SUBS     r1,r1,#0x28
000172  6008              STR      r0,[r1,#0]
000174  e003              B        |L1.382|
                  |L1.374|
;;;195    		else
;;;196    			VKL060_SDA_L();
000176  2000              MOVS     r0,#0
000178  49ae              LDR      r1,|L1.1076|
00017a  3928              SUBS     r1,r1,#0x28
00017c  6008              STR      r0,[r1,#0]
                  |L1.382|
;;;197    		dat>>=1; 
00017e  1064              ASRS     r4,r4,#1
;;;198    		Delay_nuS(VKL060_CLK);
000180  2005              MOVS     r0,#5
000182  f7fffffe          BL       Delay_nuS
;;;199    		VKL060_SCL_H();     
000186  2001              MOVS     r0,#1
000188  49aa              LDR      r1,|L1.1076|
00018a  6008              STR      r0,[r1,#0]
;;;200    		Delay_nuS(VKL060_CLK);
00018c  2005              MOVS     r0,#5
00018e  f7fffffe          BL       Delay_nuS
                  |L1.402|
000192  0028              MOVS     r0,r5                 ;190
000194  f1a50101          SUB      r1,r5,#1              ;190
000198  b2cd              UXTB     r5,r1                 ;190
00019a  d1e1              BNE      |L1.352|
;;;201    	}
;;;202    }
00019c  bd30              POP      {r4,r5,pc}
;;;203    
                          ENDP

                  VKL060_I2CRDDat PROC
;;;210    *******************************************************************************/
;;;211    unsigned char VKL060_I2CRDDat( void )
00019e  b530              PUSH     {r4,r5,lr}
;;;212    {
;;;213    	unsigned char i,RetValue;
;;;214    	
;;;215    	RetValue=0;	
0001a0  2400              MOVS     r4,#0
;;;216      for( i=0; i<8; i++ )
0001a2  2500              MOVS     r5,#0
0001a4  e014              B        |L1.464|
                  |L1.422|
;;;217      {
;;;218    		RetValue>>=1; 
0001a6  1064              ASRS     r4,r4,#1
;;;219    		VKL060_SCL_L();     
0001a8  2000              MOVS     r0,#0
0001aa  49a2              LDR      r1,|L1.1076|
0001ac  6008              STR      r0,[r1,#0]
;;;220    		Delay_nuS(VKL060_CLK);
0001ae  2005              MOVS     r0,#5
0001b0  f7fffffe          BL       Delay_nuS
;;;221    		VKL060_SCL_H();
0001b4  2001              MOVS     r0,#1
0001b6  499f              LDR      r1,|L1.1076|
0001b8  6008              STR      r0,[r1,#0]
;;;222    		Delay_nuS(VKL060_CLK);
0001ba  2005              MOVS     r0,#5
0001bc  f7fffffe          BL       Delay_nuS
;;;223    		if( VKL060_GET_SDA()!=0 )
0001c0  489c              LDR      r0,|L1.1076|
0001c2  3828              SUBS     r0,r0,#0x28
0001c4  6800              LDR      r0,[r0,#0]
0001c6  b108              CBZ      r0,|L1.460|
;;;224    			RetValue|=0x80;
0001c8  f0440480          ORR      r4,r4,#0x80
                  |L1.460|
0001cc  1c68              ADDS     r0,r5,#1              ;216
0001ce  b2c5              UXTB     r5,r0                 ;216
                  |L1.464|
0001d0  2d08              CMP      r5,#8                 ;216
0001d2  dbe8              BLT      |L1.422|
;;;225    	}
;;;226      
;;;227      return RetValue;
0001d4  4620              MOV      r0,r4
;;;228    }
0001d6  bd30              POP      {r4,r5,pc}
;;;229    /*******************************************************************************
                          ENDP

                  WriteCmdVKL060 PROC
;;;235    *******************************************************************************/
;;;236    unsigned char  WriteCmdVKL060(unsigned char cmd)
0001d8  b510              PUSH     {r4,lr}
;;;237    {
0001da  4604              MOV      r4,r0
;;;238    	//START信号	
;;;239    	VKL060_I2CStart(); 									
0001dc  f7fffffe          BL       VKL060_I2CStart
;;;240    	//SLAVE地址
;;;241    	VKL060_I2CWRCmd(VKL060_ADDRWR); 	
0001e0  207c              MOVS     r0,#0x7c
0001e2  f7fffffe          BL       VKL060_I2CWRCmd
;;;242    	if( 1 == VKL060_I2CSlaveAck() )
0001e6  f7fffffe          BL       VKL060_I2CSlaveAck
0001ea  2801              CMP      r0,#1
0001ec  d103              BNE      |L1.502|
;;;243    	{
;;;244    		VKL060_I2CStop();													
0001ee  f7fffffe          BL       VKL060_I2CStop
;;;245    		return 0;										
0001f2  2000              MOVS     r0,#0
                  |L1.500|
;;;246    	}
;;;247    	
;;;248    	VKL060_I2CWRCmd(cmd); 						
;;;249    	if( 1 == VKL060_I2CSlaveAck() )
;;;250    	{
;;;251    		VKL060_I2CStop();													
;;;252    		return 0;
;;;253    	}
;;;254    	//STOP信号
;;;255    	 VKL060_I2CStop();											
;;;256    	 return 0;    
;;;257    }
0001f4  bd10              POP      {r4,pc}
                  |L1.502|
0001f6  4620              MOV      r0,r4                 ;248
0001f8  f7fffffe          BL       VKL060_I2CWRCmd
0001fc  f7fffffe          BL       VKL060_I2CSlaveAck
000200  2801              CMP      r0,#1                 ;249
000202  d103              BNE      |L1.524|
000204  f7fffffe          BL       VKL060_I2CStop
000208  2000              MOVS     r0,#0                 ;252
00020a  e7f3              B        |L1.500|
                  |L1.524|
00020c  f7fffffe          BL       VKL060_I2CStop
000210  2000              MOVS     r0,#0                 ;256
000212  e7ef              B        |L1.500|
;;;258    /*******************************************************************************
                          ENDP

                  WritenDataVKL060 PROC
;;;266    *******************************************************************************/
;;;267    unsigned char  WritenDataVKL060(unsigned char Addr,unsigned char *Databuf,unsigned char Cnt)
000214  b5f0              PUSH     {r4-r7,lr}
;;;268    {
000216  4606              MOV      r6,r0
000218  460c              MOV      r4,r1
00021a  4617              MOV      r7,r2
;;;269    	unsigned char n;
;;;270    	
;;;271    	//START信号	
;;;272    	VKL060_I2CStart(); 									
00021c  f7fffffe          BL       VKL060_I2CStart
;;;273    	//SLAVE地址
;;;274    	VKL060_I2CWRCmd(VKL060_ADDRWR); 	
000220  207c              MOVS     r0,#0x7c
000222  f7fffffe          BL       VKL060_I2CWRCmd
;;;275    	if( 1 == VKL060_I2CSlaveAck() )
000226  f7fffffe          BL       VKL060_I2CSlaveAck
00022a  2801              CMP      r0,#1
00022c  d103              BNE      |L1.566|
;;;276    	{
;;;277    		VKL060_I2CStop();													
00022e  f7fffffe          BL       VKL060_I2CStop
;;;278    		return 0;										
000232  2000              MOVS     r0,#0
                  |L1.564|
;;;279    	}
;;;280    	//显示RAM起始地址                            
;;;281    	VKL060_I2CWRCmd(VKL060_ADDR5_0); 
;;;282    	if( 1 == VKL060_I2CSlaveAck() )
;;;283    	{
;;;284    		VKL060_I2CStop();													
;;;285    		return 0; 
;;;286    	}
;;;287    	VKL060_I2CWRCmd(Addr&0x1f); 						
;;;288    	if( 1 == VKL060_I2CSlaveAck() )
;;;289    	{
;;;290    		VKL060_I2CStop();													
;;;291    		return 0;
;;;292    	}
;;;293    	//发送Cnt个数据到显示RAM
;;;294    	for(n=0;n<Cnt;n++)
;;;295    	{ 
;;;296    		VKL060_I2CWRDat(*Databuf++);
;;;297    		if( VKL060_I2CSlaveAck()==1 )
;;;298    		{
;;;299    			VKL060_I2CStop();													
;;;300    			return 0;
;;;301    		}
;;;302    	}
;;;303    	//STOP信号
;;;304    	 VKL060_I2CStop();											
;;;305    	 return 0;    
;;;306    }
000234  bdf0              POP      {r4-r7,pc}
                  |L1.566|
000236  20e8              MOVS     r0,#0xe8              ;281
000238  f7fffffe          BL       VKL060_I2CWRCmd
00023c  f7fffffe          BL       VKL060_I2CSlaveAck
000240  2801              CMP      r0,#1                 ;282
000242  d103              BNE      |L1.588|
000244  f7fffffe          BL       VKL060_I2CStop
000248  2000              MOVS     r0,#0                 ;285
00024a  e7f3              B        |L1.564|
                  |L1.588|
00024c  f006001f          AND      r0,r6,#0x1f           ;287
000250  f7fffffe          BL       VKL060_I2CWRCmd
000254  f7fffffe          BL       VKL060_I2CSlaveAck
000258  2801              CMP      r0,#1                 ;288
00025a  d103              BNE      |L1.612|
00025c  f7fffffe          BL       VKL060_I2CStop
000260  2000              MOVS     r0,#0                 ;291
000262  e7e7              B        |L1.564|
                  |L1.612|
000264  2500              MOVS     r5,#0                 ;294
000266  e00d              B        |L1.644|
                  |L1.616|
000268  f8140b01          LDRB     r0,[r4],#1            ;296
00026c  f7fffffe          BL       VKL060_I2CWRDat
000270  f7fffffe          BL       VKL060_I2CSlaveAck
000274  2801              CMP      r0,#1                 ;297
000276  d103              BNE      |L1.640|
000278  f7fffffe          BL       VKL060_I2CStop
00027c  2000              MOVS     r0,#0                 ;300
00027e  e7d9              B        |L1.564|
                  |L1.640|
000280  1c68              ADDS     r0,r5,#1              ;294
000282  b2c5              UXTB     r5,r0                 ;294
                  |L1.644|
000284  42bd              CMP      r5,r7                 ;294
000286  dbef              BLT      |L1.616|
000288  f7fffffe          BL       VKL060_I2CStop
00028c  2000              MOVS     r0,#0                 ;305
00028e  e7d1              B        |L1.564|
;;;307    
                          ENDP

                  ReadnDataVKL060 PROC
;;;316    *******************************************************************************/
;;;317    unsigned char  ReadnDataVKL060(unsigned char Addr,unsigned char *Databuf,unsigned char Cnt)
000290  b5f0              PUSH     {r4-r7,lr}
;;;318    {
000292  4606              MOV      r6,r0
000294  460c              MOV      r4,r1
000296  4617              MOV      r7,r2
;;;319    	unsigned char n;
;;;320    	
;;;321    	//START信号	
;;;322    	VKL060_I2CStart(); 									
000298  f7fffffe          BL       VKL060_I2CStart
;;;323    	//SLAVE地址写
;;;324    	VKL060_I2CWRCmd(VKL060_ADDRWR); 	
00029c  207c              MOVS     r0,#0x7c
00029e  f7fffffe          BL       VKL060_I2CWRCmd
;;;325    	if( 1 == VKL060_I2CSlaveAck() )
0002a2  f7fffffe          BL       VKL060_I2CSlaveAck
0002a6  2801              CMP      r0,#1
0002a8  d103              BNE      |L1.690|
;;;326    	{
;;;327    		VKL060_I2CStop();													
0002aa  f7fffffe          BL       VKL060_I2CStop
;;;328    		return 0;										
0002ae  2000              MOVS     r0,#0
                  |L1.688|
;;;329    	}
;;;330    	//显示RAM起始地址                            
;;;331    	VKL060_I2CWRCmd(VKL060_ADDR5_0); 
;;;332    	if( 1 == VKL060_I2CSlaveAck() )
;;;333    	{
;;;334    		VKL060_I2CStop();													
;;;335    		return 0; 
;;;336    	}
;;;337    	VKL060_I2CWRCmd(Addr&0x1f); 						
;;;338    	if( 1 == VKL060_I2CSlaveAck() )
;;;339    	{
;;;340    		VKL060_I2CStop();													
;;;341    		return 0;
;;;342    	}
;;;343    	//STOP信号
;;;344    	 VKL060_I2CStop();	
;;;345    	//START信号	
;;;346    	VKL060_I2CStart(); 									
;;;347    	//SLAVE地址读
;;;348    	VKL060_I2CWRCmd(VKL060_ADDRRD); 	
;;;349    	if( 1 == VKL060_I2CSlaveAck() )
;;;350    	{
;;;351    		VKL060_I2CStop();													
;;;352    		return 0;										
;;;353    	}	
;;;354    	//读Cnt个数据到显示RAM
;;;355    	for(n=0;n<Cnt-1;n++)
;;;356    	{ 
;;;357    		*Databuf++=VKL060_I2CRDDat();
;;;358    		VKL060_I2CSendAck();
;;;359    	}
;;;360    	*Databuf++=VKL060_I2CRDDat();
;;;361    	VKL060_I2CSendNAck();
;;;362    	//STOP信号
;;;363    	 VKL060_I2CStop();											
;;;364    	 return 0;    
;;;365    }
0002b0  bdf0              POP      {r4-r7,pc}
                  |L1.690|
0002b2  20e8              MOVS     r0,#0xe8              ;331
0002b4  f7fffffe          BL       VKL060_I2CWRCmd
0002b8  f7fffffe          BL       VKL060_I2CSlaveAck
0002bc  2801              CMP      r0,#1                 ;332
0002be  d103              BNE      |L1.712|
0002c0  f7fffffe          BL       VKL060_I2CStop
0002c4  2000              MOVS     r0,#0                 ;335
0002c6  e7f3              B        |L1.688|
                  |L1.712|
0002c8  f006001f          AND      r0,r6,#0x1f           ;337
0002cc  f7fffffe          BL       VKL060_I2CWRCmd
0002d0  f7fffffe          BL       VKL060_I2CSlaveAck
0002d4  2801              CMP      r0,#1                 ;338
0002d6  d103              BNE      |L1.736|
0002d8  f7fffffe          BL       VKL060_I2CStop
0002dc  2000              MOVS     r0,#0                 ;341
0002de  e7e7              B        |L1.688|
                  |L1.736|
0002e0  f7fffffe          BL       VKL060_I2CStop
0002e4  f7fffffe          BL       VKL060_I2CStart
0002e8  207d              MOVS     r0,#0x7d              ;348
0002ea  f7fffffe          BL       VKL060_I2CWRCmd
0002ee  f7fffffe          BL       VKL060_I2CSlaveAck
0002f2  2801              CMP      r0,#1                 ;349
0002f4  d103              BNE      |L1.766|
0002f6  f7fffffe          BL       VKL060_I2CStop
0002fa  2000              MOVS     r0,#0                 ;352
0002fc  e7d8              B        |L1.688|
                  |L1.766|
0002fe  2500              MOVS     r5,#0                 ;355
000300  e007              B        |L1.786|
                  |L1.770|
000302  f7fffffe          BL       VKL060_I2CRDDat
000306  f8040b01          STRB     r0,[r4],#1            ;357
00030a  f7fffffe          BL       VKL060_I2CSendAck
00030e  1c68              ADDS     r0,r5,#1              ;355
000310  b2c5              UXTB     r5,r0                 ;355
                  |L1.786|
000312  1e78              SUBS     r0,r7,#1              ;355
000314  42a8              CMP      r0,r5                 ;355
000316  dcf4              BGT      |L1.770|
000318  f7fffffe          BL       VKL060_I2CRDDat
00031c  f8040b01          STRB     r0,[r4],#1            ;360
000320  f7fffffe          BL       VKL060_I2CSendNAck
000324  f7fffffe          BL       VKL060_I2CStop
000328  2000              MOVS     r0,#0                 ;364
00032a  e7c1              B        |L1.688|
;;;366    /*******************************************************************************
                          ENDP

                  VKL060_DisAll PROC
;;;373    *******************************************************************************/
;;;374    void VKL060_DisAll(unsigned char dat)
00032c  b53c              PUSH     {r2-r5,lr}
;;;375    {
00032e  4605              MOV      r5,r0
;;;376    	unsigned char segi;
;;;377    	unsigned char dispram[8];
;;;378    	
;;;379    	for(segi=0;segi<8;segi++)
000330  2400              MOVS     r4,#0
000332  e003              B        |L1.828|
                  |L1.820|
;;;380    	{
;;;381    		VKL060_dispram[segi]=dat;
000334  4840              LDR      r0,|L1.1080|
000336  5505              STRB     r5,[r0,r4]
000338  1c60              ADDS     r0,r4,#1              ;379
00033a  b2c4              UXTB     r4,r0                 ;379
                  |L1.828|
00033c  2c08              CMP      r4,#8                 ;379
00033e  dbf9              BLT      |L1.820|
;;;382    	}
;;;383    	dispram[7]&=0x0f;//多出来的半个字节缓冲清0
000340  f89d0007          LDRB     r0,[sp,#7]
000344  f000000f          AND      r0,r0,#0xf
000348  f88d0007          STRB     r0,[sp,#7]
;;;384    	WritenDataVKL060(11,VKL060_dispram,8);	//这里送8bit数据对应2个SEG，每4bit数据地址加1，每8位数据1个ACK
00034c  2208              MOVS     r2,#8
00034e  493a              LDR      r1,|L1.1080|
000350  200b              MOVS     r0,#0xb
000352  f7fffffe          BL       WritenDataVKL060
;;;385    }
000356  bd3c              POP      {r2-r5,pc}
;;;386    /*******************************************************************************
                          ENDP

                  VKL060_DisDotOn PROC
;;;393    *******************************************************************************/
;;;394    void VKL060_DisDotOn(unsigned char seg,unsigned char com)
000358  b5f8              PUSH     {r3-r7,lr}
;;;395    {
00035a  4604              MOV      r4,r0
00035c  460d              MOV      r5,r1
;;;396    	unsigned char addrbyte,addrbit,tempdat;
;;;397    	
;;;398    	//计算com/seg对应的显示RAM地址和bit
;;;399    	addrbyte=seg/2*2;
00035e  4620              MOV      r0,r4
000360  eb0471d0          ADD      r1,r4,r0,LSR #31
000364  1049              ASRS     r1,r1,#1
000366  0649              LSLS     r1,r1,#25
000368  0e0f              LSRS     r7,r1,#24
;;;400    	if((seg%2)==0)
00036a  eb0471d0          ADD      r1,r4,r0,LSR #31
00036e  1049              ASRS     r1,r1,#1
000370  eba40141          SUB      r1,r4,r1,LSL #1
000374  b919              CBNZ     r1,|L1.894|
;;;401    		addrbit=(1<<com);
000376  2001              MOVS     r0,#1
000378  40a8              LSLS     r0,r0,r5
00037a  b2c6              UXTB     r6,r0
00037c  e003              B        |L1.902|
                  |L1.894|
;;;402    	else
;;;403    		addrbit=(1<<(4+com));
00037e  1d28              ADDS     r0,r5,#4
000380  2101              MOVS     r1,#1
000382  4081              LSLS     r1,r1,r0
000384  b2ce              UXTB     r6,r1
                  |L1.902|
;;;404    	tempdat=addrbit;
000386  9600              STR      r6,[sp,#0]
;;;405    	WritenDataVKL060(addrbyte,&tempdat,1);		//这里送8bit数据对应2个SEG，seg/com对应的bit置1，其余7bit不改变
000388  2201              MOVS     r2,#1
00038a  4669              MOV      r1,sp
00038c  4638              MOV      r0,r7
00038e  f7fffffe          BL       WritenDataVKL060
;;;406    }
000392  bdf8              POP      {r3-r7,pc}
;;;407    /*******************************************************************************
                          ENDP

                  VKL060_DisDotOff PROC
;;;414    *******************************************************************************/
;;;415    void VKL060_DisDotOff(unsigned char seg,unsigned char com)
000394  b5f8              PUSH     {r3-r7,lr}
;;;416    {
000396  4604              MOV      r4,r0
000398  460d              MOV      r5,r1
;;;417    	unsigned char addrbyte,addrbit,tempdat;
;;;418    	
;;;419    	//计算com/seg对应的显示RAM地址和bit
;;;420    	addrbyte=seg/2*2;
00039a  4620              MOV      r0,r4
00039c  eb0471d0          ADD      r1,r4,r0,LSR #31
0003a0  1049              ASRS     r1,r1,#1
0003a2  0649              LSLS     r1,r1,#25
0003a4  0e0f              LSRS     r7,r1,#24
;;;421    	if((seg%2)==0)
0003a6  eb0471d0          ADD      r1,r4,r0,LSR #31
0003aa  1049              ASRS     r1,r1,#1
0003ac  eba40141          SUB      r1,r4,r1,LSL #1
0003b0  b919              CBNZ     r1,|L1.954|
;;;422    		addrbit=(1<<com);
0003b2  2001              MOVS     r0,#1
0003b4  40a8              LSLS     r0,r0,r5
0003b6  b2c6              UXTB     r6,r0
0003b8  e003              B        |L1.962|
                  |L1.954|
;;;423    	else
;;;424    		addrbit=(1<<(4+com));
0003ba  1d28              ADDS     r0,r5,#4
0003bc  2101              MOVS     r1,#1
0003be  4081              LSLS     r1,r1,r0
0003c0  b2ce              UXTB     r6,r1
                  |L1.962|
;;;425    	tempdat=~addrbit;
0003c2  43f0              MVNS     r0,r6
0003c4  b2c0              UXTB     r0,r0
0003c6  9000              STR      r0,[sp,#0]
;;;426    	WritenDataVKL060(addrbyte,&tempdat,1);		//这里送8bit数据对应2个SEG，seg/com对应的bit清0，其余7bit不改变
0003c8  2201              MOVS     r2,#1
0003ca  4669              MOV      r1,sp
0003cc  4638              MOV      r0,r7
0003ce  f7fffffe          BL       WritenDataVKL060
;;;427    }
0003d2  bdf8              POP      {r3-r7,pc}
;;;428    /*******************************************************************************
                          ENDP

                  VKL060_Enter_PowerOff PROC
;;;434    *******************************************************************************/
;;;435    unsigned char VKL060_Enter_PowerOff(void)
0003d4  b500              PUSH     {lr}
;;;436    {		
;;;437    	VKL060_I2CStart();
0003d6  f7fffffe          BL       VKL060_I2CStart
;;;438    	VKL060_I2CWRCmd(VKL060_ADDRWR); 
0003da  207c              MOVS     r0,#0x7c
0003dc  f7fffffe          BL       VKL060_I2CWRCmd
;;;439    	if( 1 == VKL060_I2CSlaveAck() )
0003e0  f7fffffe          BL       VKL060_I2CSlaveAck
0003e4  2801              CMP      r0,#1
0003e6  d103              BNE      |L1.1008|
;;;440    	{
;;;441    		VKL060_I2CStop();
0003e8  f7fffffe          BL       VKL060_I2CStop
;;;442    		return 1; 
0003ec  2001              MOVS     r0,#1
                  |L1.1006|
;;;443    	}
;;;444    	VKL060_I2CWRCmd(VKL060_LCD_OFF);		//关显示
;;;445    	if( 1 == VKL060_I2CSlaveAck() )
;;;446    	{
;;;447    		VKL060_I2CStop();
;;;448    		return 1; 
;;;449    	}
;;;450    	VKL060_I2CStop();
;;;451      return 0; 
;;;452    }
0003ee  bd00              POP      {pc}
                  |L1.1008|
0003f0  20c0              MOVS     r0,#0xc0              ;444
0003f2  f7fffffe          BL       VKL060_I2CWRCmd
0003f6  f7fffffe          BL       VKL060_I2CSlaveAck
0003fa  2801              CMP      r0,#1                 ;445
0003fc  d103              BNE      |L1.1030|
0003fe  f7fffffe          BL       VKL060_I2CStop
000402  2001              MOVS     r0,#1                 ;448
000404  e7f3              B        |L1.1006|
                  |L1.1030|
000406  f7fffffe          BL       VKL060_I2CStop
00040a  2000              MOVS     r0,#0                 ;451
00040c  e7ef              B        |L1.1006|
;;;453    /*******************************************************************************
                          ENDP

                  VKL060_InitSequence PROC
;;;475    *******************************************************************************/
;;;476    unsigned char VKL060_InitSequence(void)
00040e  b500              PUSH     {lr}
;;;477    {			
;;;478      //上电初始化时序（参考数据手册上电复位时序图和参数）	
;;;479    	//上电100uS后初始化
;;;480      Delay_nuS(100);
000410  2064              MOVS     r0,#0x64
000412  f7fffffe          BL       Delay_nuS
;;;481    	//STOP信号
;;;482    	VKL060_I2CStop();
000416  f7fffffe          BL       VKL060_I2CStop
;;;483    	//START信号
;;;484    	VKL060_I2CStart();
00041a  f7fffffe          BL       VKL060_I2CStart
;;;485    	//发送SLAVE地址(0x7C)
;;;486    	VKL060_I2CWRCmd(VKL060_ADDRWR); 
00041e  207c              MOVS     r0,#0x7c
000420  f7fffffe          BL       VKL060_I2CWRCmd
;;;487    	if( 1 == VKL060_I2CSlaveAck() )
000424  f7fffffe          BL       VKL060_I2CSlaveAck
000428  2801              CMP      r0,#1
00042a  d107              BNE      |L1.1084|
;;;488    	{
;;;489    		VKL060_I2CStop();	
00042c  f7fffffe          BL       VKL060_I2CStop
;;;490    		return 1;
000430  2001              MOVS     r0,#1
                  |L1.1074|
;;;491    	}
;;;492    	//系统设置命令(软复位)
;;;493    	VKL060_I2CWRCmd(VKL060_SOFTRST);
;;;494    	if( 1 == VKL060_I2CSlaveAck() )
;;;495    	{
;;;496    		VKL060_I2CStop();	
;;;497    		return 1;
;;;498    	}
;;;499    	//显示控制命令(设置帧频，功耗模式和驱动方式)，电流为实测样品值，仅供参考
;;;500    	//VKL060_I2CWRCmd(VKL060_FR80HZ|VKL060_SRNOR|VKL060_LINER);  	//上电默认 	VDD=5V:18.2uA  	VDD=3.3V:13uA
;;;501    	VKL060_I2CWRCmd(VKL060_FR53HZ|VKL060_SRPM1|VKL060_FRAMER);  //最省电 		VDD=5V:9.1uA  VDD=3.3V:6.8uA
;;;502    	//VKL060_I2CWRCmd(VKL060_FR80HZ|VKL060_SRHP|VKL060_LINER);  	//电流最大 			VDD=5V:20uA  	VDD=3.3V:15uA 
;;;503    	if( 1 == VKL060_I2CSlaveAck() )
;;;504    	{
;;;505    		VKL060_I2CStop();	
;;;506    		return 1;
;;;507    	}
;;;508      //模式设置命令
;;;509    	VKL060_I2CWRCmd(VKL060_BIAS_1_3|VKL060_LCD_ON);		//1/3bias,打开显示 
;;;510    	//VKL060_I2CWRCmd(VKL060_BIAS_1_2|VKL060_LCD_ON);		//1/2bias,打开显示 
;;;511    	if( 1 == VKL060_I2CSlaveAck() )
;;;512    	{
;;;513    		VKL060_I2CStop();	
;;;514    		return 1;
;;;515    	}
;;;516    	//STOP信号
;;;517    	VKL060_I2CStop();	
;;;518    		
;;;519      return  0; 
;;;520    }
000432  bd00              POP      {pc}
                  |L1.1076|
                          DCD      0x4000487c
                  |L1.1080|
                          DCD      VKL060_dispram
                  |L1.1084|
00043c  20ea              MOVS     r0,#0xea              ;493
00043e  f7fffffe          BL       VKL060_I2CWRCmd
000442  f7fffffe          BL       VKL060_I2CSlaveAck
000446  2801              CMP      r0,#1                 ;494
000448  d103              BNE      |L1.1106|
00044a  f7fffffe          BL       VKL060_I2CStop
00044e  2001              MOVS     r0,#1                 ;497
000450  e7ef              B        |L1.1074|
                  |L1.1106|
000452  20bc              MOVS     r0,#0xbc              ;501
000454  f7fffffe          BL       VKL060_I2CWRCmd
000458  f7fffffe          BL       VKL060_I2CSlaveAck
00045c  2801              CMP      r0,#1                 ;503
00045e  d103              BNE      |L1.1128|
000460  f7fffffe          BL       VKL060_I2CStop
000464  2001              MOVS     r0,#1                 ;506
000466  e7e4              B        |L1.1074|
                  |L1.1128|
000468  20c8              MOVS     r0,#0xc8              ;509
00046a  f7fffffe          BL       VKL060_I2CWRCmd
00046e  f7fffffe          BL       VKL060_I2CSlaveAck
000472  2801              CMP      r0,#1                 ;511
000474  d103              BNE      |L1.1150|
000476  f7fffffe          BL       VKL060_I2CStop
00047a  2001              MOVS     r0,#1                 ;514
00047c  e7d9              B        |L1.1074|
                  |L1.1150|
00047e  f7fffffe          BL       VKL060_I2CStop
000482  2000              MOVS     r0,#0                 ;519
000484  e7d5              B        |L1.1074|
;;;521    /*******************************************************************************
                          ENDP

                  VKL060_Exit_PowerOff PROC
;;;459    *******************************************************************************/
;;;460    unsigned char VKL060_Exit_PowerOff(void)
000486  b510              PUSH     {r4,lr}
;;;461    {	
;;;462    	unsigned char errorflag; 
;;;463    	
;;;464    	//退出掉电模式重新初始化时序
;;;465    	errorflag=VKL060_InitSequence();
000488  f7fffffe          BL       VKL060_InitSequence
00048c  4604              MOV      r4,r0
;;;466    	
;;;467      return(errorflag);
00048e  4620              MOV      r0,r4
;;;468    }
000490  bd10              POP      {r4,pc}
;;;469    /*******************************************************************************
                          ENDP

                  VKL060_Lowlevel_Init PROC
;;;527    *******************************************************************************/
;;;528    void VKL060_Lowlevel_Init(void)
000492  b510              PUSH     {r4,lr}
;;;529    {
;;;530    	//通信线电平不同，建议加电平转换电路
;;;531    	//此函数根据客户单片机做相应的修改	
;;;532    	GPIO_SetMode(VKL060_SCL_PORT, VKL060_SCL_PIN, GPIO_MODE_OUTPUT);
000494  2201              MOVS     r2,#1
000496  03d1              LSLS     r1,r2,#15
000498  4813              LDR      r0,|L1.1256|
00049a  f7fffffe          BL       GPIO_SetMode
;;;533    	GPIO_SetMode(VKL060_SDA_PORT, VKL060_SDA_PIN, GPIO_MODE_QUASI);
00049e  2203              MOVS     r2,#3
0004a0  2120              MOVS     r1,#0x20
0004a2  4811              LDR      r0,|L1.1256|
0004a4  f7fffffe          BL       GPIO_SetMode
;;;534    	
;;;535      //I2C总线空闲为高电平	
;;;536    	VKL060_SCL_H();  
0004a8  2001              MOVS     r0,#1
0004aa  4910              LDR      r1,|L1.1260|
0004ac  6008              STR      r0,[r1,#0]
;;;537    	VKL060_SDA_H(); 	
0004ae  490f              LDR      r1,|L1.1260|
0004b0  3928              SUBS     r1,r1,#0x28
0004b2  6008              STR      r0,[r1,#0]
;;;538    }
0004b4  bd10              POP      {r4,pc}
;;;539    /*******************************************************************************
                          ENDP

                  VKL060_Init PROC
;;;545    *******************************************************************************/
;;;546    void VKL060_Init(void)
0004b6  b510              PUSH     {r4,lr}
;;;547    {	
;;;548    	//管脚配置根据客户单片机做相应的修改
;;;549    	VKL060_Lowlevel_Init();
0004b8  f7fffffe          BL       VKL060_Lowlevel_Init
;;;550    	//初始化时序
;;;551    	VKL060_InitSequence();
0004bc  f7fffffe          BL       VKL060_InitSequence
;;;552    }
0004c0  bd10              POP      {r4,pc}
;;;553    /*******************************************************************************
                          ENDP

                  VKL060_Main PROC
;;;559    *******************************************************************************/
;;;560    void VKL060_Main(void)
0004c2  f7fffffe          BL       VKL060_Init
;;;561    {	
;;;562    	VKL060_Init();
;;;563    	while(1)
0004c6  e00d              B        |L1.1252|
                  |L1.1224|
;;;564    	{
;;;565    	  VKL060_DisAll(0xFF);
0004c8  20ff              MOVS     r0,#0xff
0004ca  f7fffffe          BL       VKL060_DisAll
;;;566    		Delay_nmS(1000);	
0004ce  f44f707a          MOV      r0,#0x3e8
0004d2  f7fffffe          BL       Delay_nmS
;;;567    		VKL060_DisAll(0x00);
0004d6  2000              MOVS     r0,#0
0004d8  f7fffffe          BL       VKL060_DisAll
;;;568    		Delay_nmS(1000);
0004dc  f44f707a          MOV      r0,#0x3e8
0004e0  f7fffffe          BL       Delay_nmS
                  |L1.1252|
0004e4  e7f0              B        |L1.1224|
;;;569    	}	
;;;570    	
;;;571    //	//选择外部时钟(OSCI脚)频率为32KHz(根据实际帧频修正这个频率)
;;;572    //	//WriteCmdVKL060(VKL060_EXTCLK); //设置显示地址时VKL060_ADDRWR5的bit0一定要置1
;;;573    //	
;;;574    //	//整体闪烁命令
;;;575    //	//WriteCmdVKL060(VKL060_BLKCTL_05HZ); //闪烁频率0.5Hz
;;;576    //	//WriteCmdVKL060(VKL060_BLKCTL_1HZ); 	//闪烁频率1Hz
;;;577    //	WriteCmdVKL060(VKL060_BLKCTL_2HZ); 	//闪烁频率2Hz
;;;578    //	//WriteCmdVKL060(VKL060_BLKCTL_OFF);	//闪烁关闭
;;;579    //	
;;;580    //	//全屏强制开命令
;;;581    //	WriteCmdVKL060(VKL060_APCTL_ALLON2);	
;;;582    //	Delay_nmS(3000);					//延时
;;;583    //	//全屏强制关命令
;;;584    //	WriteCmdVKL060(VKL060_APCTL_ALLOFF1);
;;;585    //	Delay_nmS(1000);					//延时
;;;586    //	
;;;587    //	//全屏强制取消,恢复正常
;;;588    //	WriteCmdVKL060(VKL060_APCTL_NORMAL);
;;;589    //	WriteCmdVKL060(VKL060_BLKCTL_OFF);	//闪烁关闭
;;;590    //	
;;;591    //	VKL060_DisAll(0x00);
;;;592    //	while(1)
;;;593    //	{		
;;;594    //		//LCD全显
;;;595    //		VKL060_DisAll(0xFF);			
;;;596    //		Delay_nmS(3000);					//延时
;;;597    //		
;;;598    //		//LCD全关
;;;599    //		VKL060_DisAll(0x00);			
;;;600    //		Delay_nmS(3000);					//延时
;;;601    //	
;;;602    //		//LCD半显
;;;603    //		VKL060_DisAll(0x55);			
;;;604    //		ReadnDataVKL060(0,VKL060_readbuf,16);	//读回RAM数据
;;;605    //		Delay_nmS(1500);					//延时
;;;606    //		VKL060_DisAll(0xAA);			
;;;607    //		ReadnDataVKL060(0,VKL060_readbuf,16);	//读回RAM数据
;;;608    //		Delay_nmS(1500);					//延时
;;;609    //		
;;;610    //		//掉电
;;;611    //		VKL060_DisAll(0x00);			//LCD全关		
;;;612    //		VKL060_Enter_PowerOff();	//进入掉电模式
;;;613    //		Delay_nmS(5000);					//延时5S		
;;;614    //		VKL060_Exit_PowerOff();	//退出掉电模式
;;;615    //				
;;;616    //		//LCD单点点亮
;;;617    //		VKL060_DisAll(0x00);			//LCD全关
;;;618    //		Delay_nmS(500);						//延时
;;;619    //		for(VKL060_segi=11;VKL060_segi<26;VKL060_segi++)//seg11-25
;;;620    //		{
;;;621    //			for(VKL060_comi=0;VKL060_comi<4;VKL060_comi++)//com0-3
;;;622    //			{
;;;623    //				VKL060_DisDotOn(VKL060_segi,VKL060_comi);		//LCD单点点亮
;;;624    //				Delay_nmS(300);				//延时
;;;625    //				VKL060_DisAll(0x00);	
;;;626    //			}
;;;627    //		}
;;;628    //		
;;;629    //		//LCD单点关闭
;;;630    //		VKL060_DisAll(0xff);			//LCD全显
;;;631    //		Delay_nmS(500);						//延时
;;;632    //		for(VKL060_segi=11;VKL060_segi<26;VKL060_segi++)//seg11-25
;;;633    //		{
;;;634    //			for(VKL060_comi=0;VKL060_comi<4;VKL060_comi++)//com0-3
;;;635    //			{
;;;636    //				VKL060_DisDotOff(VKL060_segi,VKL060_comi);		//LCD单点关闭
;;;637    //				Delay_nmS(300);				//延时
;;;638    //				VKL060_DisAll(0xff);	
;;;639    //			}
;;;640    //		}		
;;;641    //		Delay_nmS(1000);					//延时
;;;642    //	}
;;;643    }
;;;644    /************************END OF FILE****/
                          ENDP

0004e6  0000              DCW      0x0000
                  |L1.1256|
                          DCD      0x40004040
                  |L1.1260|
                          DCD      0x4000487c

                          AREA ||.data||, DATA, ALIGN=0

                  VKL060_dispram
                          %        8
                  VKL060_readbuf
                          %        8
                  VKL060_segi
000010  00                DCB      0x00
                  VKL060_comi
000011  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\lcd_driver\\VKL060_IO_I2C_QUASI.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_VKL060_IO_I2C_QUASI_c_f70de489____REV16|
#line 114 "..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___21_VKL060_IO_I2C_QUASI_c_f70de489____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_VKL060_IO_I2C_QUASI_c_f70de489____REVSH|
#line 128
|__asm___21_VKL060_IO_I2C_QUASI_c_f70de489____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
