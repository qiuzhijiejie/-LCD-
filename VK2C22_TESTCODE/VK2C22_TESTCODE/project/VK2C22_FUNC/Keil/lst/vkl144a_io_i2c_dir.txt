; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\vkl144a_io_i2c_dir.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\vkl144a_io_i2c_dir.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M451Series\Include -I..\..\..\Library\StdDriver\inc -I..\Bsp -I..\User -I..\lcd_driver -I..\exti_driver -I..\led_driver -I..\touch -I..\dotmatix_lcd -I..\KH -IC:\Users\Administator\Desktop\低功耗系列_VKL\VKL例程\VKL144A_TESTCODE\project\VKL144_FUNC\Keil\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -D__UVISION_VERSION=515 -D_RTE_ --omf_browse=.\obj\vkl144a_io_i2c_dir.crf ..\lcd_driver\VKL144A_IO_I2C_DIR.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Delay_nuS PROC
;;;35     *******************************************************************************/
;;;36     void Delay_nuS(unsigned int n)	   
000000  e007              B        |L1.18|
                  |L1.2|
;;;37     {
;;;38     	unsigned char i;
;;;39     	while(n--)
;;;40     	{
;;;41     		i=10;
000002  210a              MOVS     r1,#0xa
;;;42     		while(i--)
000004  e000              B        |L1.8|
                  |L1.6|
;;;43     		{//nop指令根据单片机做相应的修改
;;;44     			__nop();
000006  bf00              NOP      
                  |L1.8|
000008  000a              MOVS     r2,r1                 ;42
00000a  f1a10301          SUB      r3,r1,#1              ;42
00000e  b2d9              UXTB     r1,r3                 ;42
000010  d1f9              BNE      |L1.6|
                  |L1.18|
000012  0002              MOVS     r2,r0                 ;39
000014  f1a00001          SUB      r0,r0,#1              ;39
000018  d1f3              BNE      |L1.2|
;;;45     		}
;;;46     	}
;;;47     }
00001a  4770              BX       lr
;;;48     /*******************************************************************************
                          ENDP

                  Delay_nmS PROC
;;;54     *******************************************************************************/
;;;55     void Delay_nmS(unsigned long int n)
00001c  b510              PUSH     {r4,lr}
;;;56     {
00001e  4604              MOV      r4,r0
;;;57     	while(n--)
000020  e003              B        |L1.42|
                  |L1.34|
;;;58     	{
;;;59     		Delay_nuS(1000);
000022  f44f707a          MOV      r0,#0x3e8
000026  f7fffffe          BL       Delay_nuS
                  |L1.42|
00002a  0020              MOVS     r0,r4                 ;57
00002c  f1a40401          SUB      r4,r4,#1              ;57
000030  d1f7              BNE      |L1.34|
;;;60     	}
;;;61     }
000032  bd10              POP      {r4,pc}
;;;62     /*******************************************************************************
                          ENDP

                  VKL144A_I2CStart PROC
;;;68     *******************************************************************************/
;;;69     void VKL144A_I2CStart( void )
000034  b500              PUSH     {lr}
;;;70     {
;;;71       VKL144A_SCL_H();
000036  2001              MOVS     r0,#1
000038  49f9              LDR      r1,|L1.1056|
00003a  6008              STR      r0,[r1,#0]
;;;72       VKL144A_SDA_H();
00003c  49f8              LDR      r1,|L1.1056|
00003e  3928              SUBS     r1,r1,#0x28
000040  6008              STR      r0,[r1,#0]
;;;73       Delay_nuS(VKL144A_CLK);
000042  200a              MOVS     r0,#0xa
000044  f7fffffe          BL       Delay_nuS
;;;74       VKL144A_SDA_L();
000048  2000              MOVS     r0,#0
00004a  49f5              LDR      r1,|L1.1056|
00004c  3928              SUBS     r1,r1,#0x28
00004e  6008              STR      r0,[r1,#0]
;;;75       Delay_nuS(VKL144A_CLK);
000050  200a              MOVS     r0,#0xa
000052  f7fffffe          BL       Delay_nuS
;;;76     }
000056  bd00              POP      {pc}
;;;77     /*******************************************************************************
                          ENDP

                  VKL144A_I2CStop PROC
;;;83     *******************************************************************************/
;;;84     void VKL144A_I2CStop( void )
000058  b500              PUSH     {lr}
;;;85     {
;;;86       VKL144A_SCL_H();
00005a  2001              MOVS     r0,#1
00005c  49f0              LDR      r1,|L1.1056|
00005e  6008              STR      r0,[r1,#0]
;;;87       VKL144A_SDA_L();
000060  2000              MOVS     r0,#0
000062  49ef              LDR      r1,|L1.1056|
000064  3928              SUBS     r1,r1,#0x28
000066  6008              STR      r0,[r1,#0]
;;;88       Delay_nuS(VKL144A_CLK);
000068  200a              MOVS     r0,#0xa
00006a  f7fffffe          BL       Delay_nuS
;;;89       VKL144A_SDA_H();
00006e  2001              MOVS     r0,#1
000070  49eb              LDR      r1,|L1.1056|
000072  3928              SUBS     r1,r1,#0x28
000074  6008              STR      r0,[r1,#0]
;;;90       Delay_nuS(VKL144A_CLK);
000076  200a              MOVS     r0,#0xa
000078  f7fffffe          BL       Delay_nuS
;;;91     }
00007c  bd00              POP      {pc}
;;;92     /*******************************************************************************
                          ENDP

                  VKL144A_I2CSlaveAck PROC
;;;98     *******************************************************************************/
;;;99     unsigned char VKL144A_I2CSlaveAck( void )
00007e  b570              PUSH     {r4-r6,lr}
;;;100    {
;;;101      unsigned int TimeOut;
;;;102      unsigned char RetValue;
;;;103    	
;;;104    	VKL144_SET_SDA_IN();
000080  2200              MOVS     r2,#0
000082  2120              MOVS     r1,#0x20
000084  48e7              LDR      r0,|L1.1060|
000086  f7fffffe          BL       GPIO_SetMode
;;;105    	//VKL144A_SDA_H();	
;;;106    	VKL144A_SDA_L();	//SDA脚设为输入后，有些单片机需送1，有些单片机需送0
00008a  2000              MOVS     r0,#0
00008c  49e4              LDR      r1,|L1.1056|
00008e  3928              SUBS     r1,r1,#0x28
000090  6008              STR      r0,[r1,#0]
;;;107      VKL144A_SCL_L();
000092  49e3              LDR      r1,|L1.1056|
000094  6008              STR      r0,[r1,#0]
;;;108      Delay_nuS(VKL144A_CLK);
000096  200a              MOVS     r0,#0xa
000098  f7fffffe          BL       Delay_nuS
;;;109      VKL144A_SCL_H();//第9个SCL时钟上升沿
00009c  2001              MOVS     r0,#1
00009e  49e0              LDR      r1,|L1.1056|
0000a0  6008              STR      r0,[r1,#0]
;;;110      TimeOut = 10000;
0000a2  f2427510          MOV      r5,#0x2710
;;;111      while( TimeOut-- > 0 )
0000a6  e007              B        |L1.184|
                  |L1.168|
;;;112      {
;;;113        if( VKL144A_GET_SDA()!=0 )//读取ack
0000a8  48dd              LDR      r0,|L1.1056|
0000aa  3828              SUBS     r0,r0,#0x28
0000ac  6800              LDR      r0,[r0,#0]
0000ae  b108              CBZ      r0,|L1.180|
;;;114        {
;;;115          RetValue = 1;
0000b0  2401              MOVS     r4,#1
0000b2  e001              B        |L1.184|
                  |L1.180|
;;;116        }
;;;117        else
;;;118        {
;;;119          RetValue = 0;
0000b4  2400              MOVS     r4,#0
;;;120          break;
0000b6  e003              B        |L1.192|
                  |L1.184|
0000b8  0028              MOVS     r0,r5                 ;111
0000ba  f1a50501          SUB      r5,r5,#1              ;111
0000be  d1f3              BNE      |L1.168|
                  |L1.192|
0000c0  bf00              NOP      
;;;121        }
;;;122      } 
;;;123    	VKL144A_SCL_L(); //下一个时序可能为命令,数据或者STOP信号。
0000c2  2000              MOVS     r0,#0
0000c4  49d6              LDR      r1,|L1.1056|
0000c6  6008              STR      r0,[r1,#0]
;;;124      VKL144_SET_SDA_OUT();
0000c8  2201              MOVS     r2,#1
0000ca  2120              MOVS     r1,#0x20
0000cc  48d5              LDR      r0,|L1.1060|
0000ce  f7fffffe          BL       GPIO_SetMode
;;;125      return RetValue;
0000d2  4620              MOV      r0,r4
;;;126    }
0000d4  bd70              POP      {r4-r6,pc}
;;;127    /*******************************************************************************
                          ENDP

                  VKL144A_I2CSendAck PROC
;;;133    *******************************************************************************/
;;;134    void VKL144A_I2CSendAck( void )
0000d6  b500              PUSH     {lr}
;;;135    {
;;;136      VKL144A_SCL_L();
0000d8  2000              MOVS     r0,#0
0000da  49d1              LDR      r1,|L1.1056|
0000dc  6008              STR      r0,[r1,#0]
;;;137      VKL144A_SDA_L();
0000de  49d0              LDR      r1,|L1.1056|
0000e0  3928              SUBS     r1,r1,#0x28
0000e2  6008              STR      r0,[r1,#0]
;;;138      Delay_nuS(VKL144A_CLK*2);
0000e4  2014              MOVS     r0,#0x14
0000e6  f7fffffe          BL       Delay_nuS
;;;139      VKL144A_SCL_H();
0000ea  2001              MOVS     r0,#1
0000ec  49cc              LDR      r1,|L1.1056|
0000ee  6008              STR      r0,[r1,#0]
;;;140      Delay_nuS(VKL144A_CLK*2);
0000f0  2014              MOVS     r0,#0x14
0000f2  f7fffffe          BL       Delay_nuS
;;;141      VKL144A_SCL_L();
0000f6  2000              MOVS     r0,#0
0000f8  49c9              LDR      r1,|L1.1056|
0000fa  6008              STR      r0,[r1,#0]
;;;142      VKL144A_SDA_H();
0000fc  2001              MOVS     r0,#1
0000fe  49c8              LDR      r1,|L1.1056|
000100  3928              SUBS     r1,r1,#0x28
000102  6008              STR      r0,[r1,#0]
;;;143    }
000104  bd00              POP      {pc}
;;;144    /*******************************************************************************
                          ENDP

                  VKL144A_I2CSendNAck PROC
;;;150    *******************************************************************************/
;;;151    void VKL144A_I2CSendNAck( void )
000106  b500              PUSH     {lr}
;;;152    {
;;;153      VKL144A_SCL_L();
000108  2000              MOVS     r0,#0
00010a  49c5              LDR      r1,|L1.1056|
00010c  6008              STR      r0,[r1,#0]
;;;154      VKL144A_SDA_H();
00010e  2001              MOVS     r0,#1
000110  49c3              LDR      r1,|L1.1056|
000112  3928              SUBS     r1,r1,#0x28
000114  6008              STR      r0,[r1,#0]
;;;155      Delay_nuS(VKL144A_CLK);
000116  200a              MOVS     r0,#0xa
000118  f7fffffe          BL       Delay_nuS
;;;156      VKL144A_SCL_H();
00011c  2001              MOVS     r0,#1
00011e  49c0              LDR      r1,|L1.1056|
000120  6008              STR      r0,[r1,#0]
;;;157      Delay_nuS(VKL144A_CLK);
000122  200a              MOVS     r0,#0xa
000124  f7fffffe          BL       Delay_nuS
;;;158    }
000128  bd00              POP      {pc}
;;;159    /*******************************************************************************
                          ENDP

                  VKL144A_I2CWRCmd PROC
;;;165    *******************************************************************************/
;;;166    void VKL144A_I2CWRCmd( unsigned char cmd )
00012a  b530              PUSH     {r4,r5,lr}
;;;167    {
00012c  4604              MOV      r4,r0
;;;168    	unsigned char i=8;
00012e  2508              MOVS     r5,#8
;;;169    	
;;;170    	while (i--)
000130  e019              B        |L1.358|
                  |L1.306|
;;;171    	{ 
;;;172    		VKL144A_SCL_L();
000132  2000              MOVS     r0,#0
000134  49ba              LDR      r1,|L1.1056|
000136  6008              STR      r0,[r1,#0]
;;;173    		if(cmd&0x80)
000138  f0040080          AND      r0,r4,#0x80
00013c  b120              CBZ      r0,|L1.328|
;;;174    			VKL144A_SDA_H();
00013e  2001              MOVS     r0,#1
000140  49b7              LDR      r1,|L1.1056|
000142  3928              SUBS     r1,r1,#0x28
000144  6008              STR      r0,[r1,#0]
000146  e003              B        |L1.336|
                  |L1.328|
;;;175    		else
;;;176    			VKL144A_SDA_L();
000148  2000              MOVS     r0,#0
00014a  49b5              LDR      r1,|L1.1056|
00014c  3928              SUBS     r1,r1,#0x28
00014e  6008              STR      r0,[r1,#0]
                  |L1.336|
;;;177    		cmd<<=1; 
000150  0660              LSLS     r0,r4,#25
000152  0e04              LSRS     r4,r0,#24
;;;178    		Delay_nuS(VKL144A_CLK);
000154  200a              MOVS     r0,#0xa
000156  f7fffffe          BL       Delay_nuS
;;;179    		VKL144A_SCL_H();     
00015a  2001              MOVS     r0,#1
00015c  49b0              LDR      r1,|L1.1056|
00015e  6008              STR      r0,[r1,#0]
;;;180    		Delay_nuS(VKL144A_CLK);
000160  200a              MOVS     r0,#0xa
000162  f7fffffe          BL       Delay_nuS
                  |L1.358|
000166  0028              MOVS     r0,r5                 ;170
000168  f1a50101          SUB      r1,r5,#1              ;170
00016c  b2cd              UXTB     r5,r1                 ;170
00016e  d1e0              BNE      |L1.306|
;;;181    	}
;;;182    }
000170  bd30              POP      {r4,r5,pc}
;;;183    /*******************************************************************************
                          ENDP

                  VKL144A_I2CWRDat PROC
;;;189    *******************************************************************************/
;;;190    void VKL144A_I2CWRDat( unsigned char dat )
000172  b530              PUSH     {r4,r5,lr}
;;;191    {
000174  4604              MOV      r4,r0
;;;192    	unsigned char i=8;
000176  2508              MOVS     r5,#8
;;;193    	while (i--)
000178  e018              B        |L1.428|
                  |L1.378|
;;;194    	{ 
;;;195    		VKL144A_SCL_L();
00017a  2000              MOVS     r0,#0
00017c  49a8              LDR      r1,|L1.1056|
00017e  6008              STR      r0,[r1,#0]
;;;196    		if(dat&0x01)
000180  f0040001          AND      r0,r4,#1
000184  b120              CBZ      r0,|L1.400|
;;;197    			VKL144A_SDA_H();
000186  2001              MOVS     r0,#1
000188  49a5              LDR      r1,|L1.1056|
00018a  3928              SUBS     r1,r1,#0x28
00018c  6008              STR      r0,[r1,#0]
00018e  e003              B        |L1.408|
                  |L1.400|
;;;198    		else
;;;199    			VKL144A_SDA_L();
000190  2000              MOVS     r0,#0
000192  49a3              LDR      r1,|L1.1056|
000194  3928              SUBS     r1,r1,#0x28
000196  6008              STR      r0,[r1,#0]
                  |L1.408|
;;;200    		dat>>=1; 
000198  1064              ASRS     r4,r4,#1
;;;201    		Delay_nuS(VKL144A_CLK);
00019a  200a              MOVS     r0,#0xa
00019c  f7fffffe          BL       Delay_nuS
;;;202    		VKL144A_SCL_H();     
0001a0  2001              MOVS     r0,#1
0001a2  499f              LDR      r1,|L1.1056|
0001a4  6008              STR      r0,[r1,#0]
;;;203    		Delay_nuS(VKL144A_CLK);
0001a6  200a              MOVS     r0,#0xa
0001a8  f7fffffe          BL       Delay_nuS
                  |L1.428|
0001ac  0028              MOVS     r0,r5                 ;193
0001ae  f1a50101          SUB      r1,r5,#1              ;193
0001b2  b2cd              UXTB     r5,r1                 ;193
0001b4  d1e1              BNE      |L1.378|
;;;204    	}
;;;205    }
0001b6  bd30              POP      {r4,r5,pc}
;;;206    
                          ENDP

                  VKL144A_I2CRDDat PROC
;;;213    *******************************************************************************/
;;;214    unsigned char VKL144A_I2CRDDat( void )
0001b8  b570              PUSH     {r4-r6,lr}
;;;215    {
;;;216    	unsigned char i,RetValue;
;;;217    	
;;;218    	VKL144_SET_SDA_IN();
0001ba  2200              MOVS     r2,#0
0001bc  2120              MOVS     r1,#0x20
0001be  4899              LDR      r0,|L1.1060|
0001c0  f7fffffe          BL       GPIO_SetMode
;;;219    	//VKL144A_SDA_H();	
;;;220    	VKL144A_SDA_L();	//SDA脚设为输入后，有些单片机需送1，有些单片机需送0
0001c4  2000              MOVS     r0,#0
0001c6  4996              LDR      r1,|L1.1056|
0001c8  3928              SUBS     r1,r1,#0x28
0001ca  6008              STR      r0,[r1,#0]
;;;221    	RetValue=0;	
0001cc  2400              MOVS     r4,#0
;;;222      for( i=0; i<8; i++ )
0001ce  2500              MOVS     r5,#0
0001d0  e014              B        |L1.508|
                  |L1.466|
;;;223      {
;;;224    		RetValue>>=1; 
0001d2  1064              ASRS     r4,r4,#1
;;;225    		VKL144A_SCL_L();     
0001d4  2000              MOVS     r0,#0
0001d6  4992              LDR      r1,|L1.1056|
0001d8  6008              STR      r0,[r1,#0]
;;;226    		Delay_nuS(VKL144A_CLK);
0001da  200a              MOVS     r0,#0xa
0001dc  f7fffffe          BL       Delay_nuS
;;;227    		VKL144A_SCL_H();
0001e0  2001              MOVS     r0,#1
0001e2  498f              LDR      r1,|L1.1056|
0001e4  6008              STR      r0,[r1,#0]
;;;228    		Delay_nuS(VKL144A_CLK);
0001e6  200a              MOVS     r0,#0xa
0001e8  f7fffffe          BL       Delay_nuS
;;;229    		if( VKL144A_GET_SDA()!=0 )
0001ec  488c              LDR      r0,|L1.1056|
0001ee  3828              SUBS     r0,r0,#0x28
0001f0  6800              LDR      r0,[r0,#0]
0001f2  b108              CBZ      r0,|L1.504|
;;;230    			RetValue|=0x80;
0001f4  f0440480          ORR      r4,r4,#0x80
                  |L1.504|
0001f8  1c68              ADDS     r0,r5,#1              ;222
0001fa  b2c5              UXTB     r5,r0                 ;222
                  |L1.508|
0001fc  2d08              CMP      r5,#8                 ;222
0001fe  dbe8              BLT      |L1.466|
;;;231    	}
;;;232      VKL144_SET_SDA_OUT();
000200  2201              MOVS     r2,#1
000202  2120              MOVS     r1,#0x20
000204  4887              LDR      r0,|L1.1060|
000206  f7fffffe          BL       GPIO_SetMode
;;;233      return RetValue;
00020a  4620              MOV      r0,r4
;;;234    }
00020c  bd70              POP      {r4-r6,pc}
;;;235    /*******************************************************************************
                          ENDP

                  WriteCmdVKL144A PROC
;;;241    *******************************************************************************/
;;;242    unsigned char  WriteCmdVKL144A(unsigned char cmd)
00020e  b510              PUSH     {r4,lr}
;;;243    {
000210  4604              MOV      r4,r0
;;;244    	//START信号	
;;;245    	VKL144A_I2CStart(); 									
000212  f7fffffe          BL       VKL144A_I2CStart
;;;246    	//SLAVE地址
;;;247    	VKL144A_I2CWRCmd(VKL144A_ADDRWR); 	
000216  207c              MOVS     r0,#0x7c
000218  f7fffffe          BL       VKL144A_I2CWRCmd
;;;248    	if( 1 == VKL144A_I2CSlaveAck() )
00021c  f7fffffe          BL       VKL144A_I2CSlaveAck
000220  2801              CMP      r0,#1
000222  d103              BNE      |L1.556|
;;;249    	{
;;;250    		VKL144A_I2CStop();													
000224  f7fffffe          BL       VKL144A_I2CStop
;;;251    		return 0;										
000228  2000              MOVS     r0,#0
                  |L1.554|
;;;252    	}
;;;253    	
;;;254    	VKL144A_I2CWRCmd(cmd); 						
;;;255    	if( 1 == VKL144A_I2CSlaveAck() )
;;;256    	{
;;;257    		VKL144A_I2CStop();													
;;;258    		return 0;
;;;259    	}
;;;260    	//STOP信号
;;;261    	 VKL144A_I2CStop();											
;;;262    	 return 0;    
;;;263    }
00022a  bd10              POP      {r4,pc}
                  |L1.556|
00022c  4620              MOV      r0,r4                 ;254
00022e  f7fffffe          BL       VKL144A_I2CWRCmd
000232  f7fffffe          BL       VKL144A_I2CSlaveAck
000236  2801              CMP      r0,#1                 ;255
000238  d103              BNE      |L1.578|
00023a  f7fffffe          BL       VKL144A_I2CStop
00023e  2000              MOVS     r0,#0                 ;258
000240  e7f3              B        |L1.554|
                  |L1.578|
000242  f7fffffe          BL       VKL144A_I2CStop
000246  2000              MOVS     r0,#0                 ;262
000248  e7ef              B        |L1.554|
;;;264    /*******************************************************************************
                          ENDP

                  WritenDataVKL144A PROC
;;;272    *******************************************************************************/
;;;273    unsigned char  WritenDataVKL144A(unsigned char Addr,unsigned char *Databuf,unsigned char Cnt)
00024a  e92d41f0          PUSH     {r4-r8,lr}
;;;274    {
00024e  4604              MOV      r4,r0
000250  460d              MOV      r5,r1
000252  4617              MOV      r7,r2
;;;275    	unsigned char n;
;;;276    	
;;;277    	//START信号	
;;;278    	VKL144A_I2CStart(); 									
000254  f7fffffe          BL       VKL144A_I2CStart
;;;279    	//SLAVE地址
;;;280    	VKL144A_I2CWRCmd(VKL144A_ADDRWR); 	
000258  207c              MOVS     r0,#0x7c
00025a  f7fffffe          BL       VKL144A_I2CWRCmd
;;;281    	if( 1 == VKL144A_I2CSlaveAck() )
00025e  f7fffffe          BL       VKL144A_I2CSlaveAck
000262  2801              CMP      r0,#1
000264  d104              BNE      |L1.624|
;;;282    	{
;;;283    		VKL144A_I2CStop();													
000266  f7fffffe          BL       VKL144A_I2CStop
;;;284    		return 0;										
00026a  2000              MOVS     r0,#0
                  |L1.620|
;;;285    	}
;;;286    	//显示RAM起始地址
;;;287    	if(Addr>0x1f)													//选择内部时钟（OSCI脚）VKL144A_ADDRWR5 bit0一定要清0
;;;288    		VKL144A_I2CWRCmd(VKL144A_ADDR5_1); 	//选择外部时钟（OSCI脚）VKL144A_ADDRWR5 bit0一定要置1
;;;289    	else                               
;;;290    		VKL144A_I2CWRCmd(VKL144A_ADDR5_0); 
;;;291    	if( 1 == VKL144A_I2CSlaveAck() )
;;;292    	{
;;;293    		VKL144A_I2CStop();													
;;;294    		return 0; 
;;;295    	}
;;;296    	VKL144A_I2CWRCmd(Addr&0x1f); 						
;;;297    	if( 1 == VKL144A_I2CSlaveAck() )
;;;298    	{
;;;299    		VKL144A_I2CStop();													
;;;300    		return 0;
;;;301    	}
;;;302    	//发送Cnt个数据到显示RAM
;;;303    	for(n=0;n<Cnt;n++)
;;;304    	{ 
;;;305    		VKL144A_I2CWRDat(*Databuf++);
;;;306    		if( VKL144A_I2CSlaveAck()==1 )
;;;307    		{
;;;308    			VKL144A_I2CStop();													
;;;309    			return 0;
;;;310    		}
;;;311    	}
;;;312    	//STOP信号
;;;313    	 VKL144A_I2CStop();											
;;;314    	 return 0;    
;;;315    }
00026c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.624|
000270  2c1f              CMP      r4,#0x1f              ;287
000272  dd03              BLE      |L1.636|
000274  20ec              MOVS     r0,#0xec              ;288
000276  f7fffffe          BL       VKL144A_I2CWRCmd
00027a  e002              B        |L1.642|
                  |L1.636|
00027c  20e8              MOVS     r0,#0xe8              ;290
00027e  f7fffffe          BL       VKL144A_I2CWRCmd
                  |L1.642|
000282  f7fffffe          BL       VKL144A_I2CSlaveAck
000286  2801              CMP      r0,#1                 ;291
000288  d103              BNE      |L1.658|
00028a  f7fffffe          BL       VKL144A_I2CStop
00028e  2000              MOVS     r0,#0                 ;294
000290  e7ec              B        |L1.620|
                  |L1.658|
000292  f004001f          AND      r0,r4,#0x1f           ;296
000296  f7fffffe          BL       VKL144A_I2CWRCmd
00029a  f7fffffe          BL       VKL144A_I2CSlaveAck
00029e  2801              CMP      r0,#1                 ;297
0002a0  d103              BNE      |L1.682|
0002a2  f7fffffe          BL       VKL144A_I2CStop
0002a6  2000              MOVS     r0,#0                 ;300
0002a8  e7e0              B        |L1.620|
                  |L1.682|
0002aa  2600              MOVS     r6,#0                 ;303
0002ac  e00d              B        |L1.714|
                  |L1.686|
0002ae  f8150b01          LDRB     r0,[r5],#1            ;305
0002b2  f7fffffe          BL       VKL144A_I2CWRDat
0002b6  f7fffffe          BL       VKL144A_I2CSlaveAck
0002ba  2801              CMP      r0,#1                 ;306
0002bc  d103              BNE      |L1.710|
0002be  f7fffffe          BL       VKL144A_I2CStop
0002c2  2000              MOVS     r0,#0                 ;309
0002c4  e7d2              B        |L1.620|
                  |L1.710|
0002c6  1c70              ADDS     r0,r6,#1              ;303
0002c8  b2c6              UXTB     r6,r0                 ;303
                  |L1.714|
0002ca  42be              CMP      r6,r7                 ;303
0002cc  dbef              BLT      |L1.686|
0002ce  f7fffffe          BL       VKL144A_I2CStop
0002d2  2000              MOVS     r0,#0                 ;314
0002d4  e7ca              B        |L1.620|
;;;316    
                          ENDP

                  ReadnDataVKL144A PROC
;;;325    *******************************************************************************/
;;;326    unsigned char  ReadnDataVKL144A(unsigned char Addr,unsigned char *Databuf,unsigned char Cnt)
0002d6  e92d41f0          PUSH     {r4-r8,lr}
;;;327    {
0002da  4605              MOV      r5,r0
0002dc  460c              MOV      r4,r1
0002de  4617              MOV      r7,r2
;;;328    	unsigned char n;
;;;329    	
;;;330    	//START信号	
;;;331    	VKL144A_I2CStart(); 									
0002e0  f7fffffe          BL       VKL144A_I2CStart
;;;332    	//SLAVE地址写
;;;333    	VKL144A_I2CWRCmd(VKL144A_ADDRWR); 	
0002e4  207c              MOVS     r0,#0x7c
0002e6  f7fffffe          BL       VKL144A_I2CWRCmd
;;;334    	if( 1 == VKL144A_I2CSlaveAck() )
0002ea  f7fffffe          BL       VKL144A_I2CSlaveAck
0002ee  2801              CMP      r0,#1
0002f0  d104              BNE      |L1.764|
;;;335    	{
;;;336    		VKL144A_I2CStop();													
0002f2  f7fffffe          BL       VKL144A_I2CStop
;;;337    		return 0;										
0002f6  2000              MOVS     r0,#0
                  |L1.760|
;;;338    	}
;;;339    	//显示RAM起始地址
;;;340    	if(Addr>0x1f)													//选择内部时钟（OSCI脚）VKL144A_ADDRWR5 bit0一定要清0
;;;341    		VKL144A_I2CWRCmd(VKL144A_ADDR5_1); 	//选择外部时钟（OSCI脚）VKL144A_ADDRWR5 bit0一定要置1
;;;342    	else                               
;;;343    		VKL144A_I2CWRCmd(VKL144A_ADDR5_0); 
;;;344    	if( 1 == VKL144A_I2CSlaveAck() )
;;;345    	{
;;;346    		VKL144A_I2CStop();													
;;;347    		return 0; 
;;;348    	}
;;;349    	VKL144A_I2CWRCmd(Addr&0x1f); 						
;;;350    	if( 1 == VKL144A_I2CSlaveAck() )
;;;351    	{
;;;352    		VKL144A_I2CStop();													
;;;353    		return 0;
;;;354    	}
;;;355    	//STOP信号
;;;356    	 VKL144A_I2CStop();	
;;;357    	//START信号	
;;;358    	VKL144A_I2CStart(); 									
;;;359    	//SLAVE地址读
;;;360    	VKL144A_I2CWRCmd(VKL144A_ADDRRD); 	
;;;361    	if( 1 == VKL144A_I2CSlaveAck() )
;;;362    	{
;;;363    		VKL144A_I2CStop();													
;;;364    		return 0;										
;;;365    	}	
;;;366    	//读Cnt个数据到显示RAM
;;;367    	for(n=0;n<Cnt-1;n++)
;;;368    	{ 
;;;369    		*Databuf++=VKL144A_I2CRDDat();
;;;370    		VKL144A_I2CSendAck();
;;;371    	}
;;;372    	*Databuf++=VKL144A_I2CRDDat();
;;;373    	VKL144A_I2CSendNAck();
;;;374    	//STOP信号
;;;375    	 VKL144A_I2CStop();											
;;;376    	 return 0;    
;;;377    }
0002f8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.764|
0002fc  2d1f              CMP      r5,#0x1f              ;340
0002fe  dd03              BLE      |L1.776|
000300  20ec              MOVS     r0,#0xec              ;341
000302  f7fffffe          BL       VKL144A_I2CWRCmd
000306  e002              B        |L1.782|
                  |L1.776|
000308  20e8              MOVS     r0,#0xe8              ;343
00030a  f7fffffe          BL       VKL144A_I2CWRCmd
                  |L1.782|
00030e  f7fffffe          BL       VKL144A_I2CSlaveAck
000312  2801              CMP      r0,#1                 ;344
000314  d103              BNE      |L1.798|
000316  f7fffffe          BL       VKL144A_I2CStop
00031a  2000              MOVS     r0,#0                 ;347
00031c  e7ec              B        |L1.760|
                  |L1.798|
00031e  f005001f          AND      r0,r5,#0x1f           ;349
000322  f7fffffe          BL       VKL144A_I2CWRCmd
000326  f7fffffe          BL       VKL144A_I2CSlaveAck
00032a  2801              CMP      r0,#1                 ;350
00032c  d103              BNE      |L1.822|
00032e  f7fffffe          BL       VKL144A_I2CStop
000332  2000              MOVS     r0,#0                 ;353
000334  e7e0              B        |L1.760|
                  |L1.822|
000336  f7fffffe          BL       VKL144A_I2CStop
00033a  f7fffffe          BL       VKL144A_I2CStart
00033e  207d              MOVS     r0,#0x7d              ;360
000340  f7fffffe          BL       VKL144A_I2CWRCmd
000344  f7fffffe          BL       VKL144A_I2CSlaveAck
000348  2801              CMP      r0,#1                 ;361
00034a  d103              BNE      |L1.852|
00034c  f7fffffe          BL       VKL144A_I2CStop
000350  2000              MOVS     r0,#0                 ;364
000352  e7d1              B        |L1.760|
                  |L1.852|
000354  2600              MOVS     r6,#0                 ;367
000356  e007              B        |L1.872|
                  |L1.856|
000358  f7fffffe          BL       VKL144A_I2CRDDat
00035c  f8040b01          STRB     r0,[r4],#1            ;369
000360  f7fffffe          BL       VKL144A_I2CSendAck
000364  1c70              ADDS     r0,r6,#1              ;367
000366  b2c6              UXTB     r6,r0                 ;367
                  |L1.872|
000368  1e78              SUBS     r0,r7,#1              ;367
00036a  42b0              CMP      r0,r6                 ;367
00036c  dcf4              BGT      |L1.856|
00036e  f7fffffe          BL       VKL144A_I2CRDDat
000372  f8040b01          STRB     r0,[r4],#1            ;372
000376  f7fffffe          BL       VKL144A_I2CSendNAck
00037a  f7fffffe          BL       VKL144A_I2CStop
00037e  2000              MOVS     r0,#0                 ;376
000380  e7ba              B        |L1.760|
;;;378    /*******************************************************************************
                          ENDP

                  VKL144A_DisAll PROC
;;;385    *******************************************************************************/
;;;386    void VKL144A_DisAll(unsigned char dat)
000382  b570              PUSH     {r4-r6,lr}
;;;387    {
000384  4605              MOV      r5,r0
;;;388    	unsigned char segi;
;;;389    	
;;;390    	for(segi=0;segi<18;segi++)
000386  2400              MOVS     r4,#0
000388  e003              B        |L1.914|
                  |L1.906|
;;;391    	{
;;;392    		VKL144A_dispram[segi]=dat;
00038a  4827              LDR      r0,|L1.1064|
00038c  5505              STRB     r5,[r0,r4]
00038e  1c60              ADDS     r0,r4,#1              ;390
000390  b2c4              UXTB     r4,r0                 ;390
                  |L1.914|
000392  2c12              CMP      r4,#0x12              ;390
000394  dbf9              BLT      |L1.906|
;;;393    	}
;;;394    	WritenDataVKL144A(0,VKL144A_dispram,18);	//这里送8bit数据对应2个SEG，每4bit数据地址加1，每8位数据1个ACK
000396  2212              MOVS     r2,#0x12
000398  4923              LDR      r1,|L1.1064|
00039a  2000              MOVS     r0,#0
00039c  f7fffffe          BL       WritenDataVKL144A
;;;395    }
0003a0  bd70              POP      {r4-r6,pc}
;;;396    /*******************************************************************************
                          ENDP

                  VKL144A_DisDotOn PROC
;;;403    *******************************************************************************/
;;;404    void VKL144A_DisDotOn(unsigned char seg,unsigned char com)
0003a2  b5f8              PUSH     {r3-r7,lr}
;;;405    {
0003a4  4604              MOV      r4,r0
0003a6  460d              MOV      r5,r1
;;;406    	unsigned char addrbyte,addrbit,tempdat;
;;;407    	
;;;408    	//计算com/seg对应的显示RAM地址和bit
;;;409    	addrbyte=seg/2*2;
0003a8  4620              MOV      r0,r4
0003aa  eb0471d0          ADD      r1,r4,r0,LSR #31
0003ae  1049              ASRS     r1,r1,#1
0003b0  0649              LSLS     r1,r1,#25
0003b2  0e0f              LSRS     r7,r1,#24
;;;410    	if((seg%2)==0)
0003b4  eb0471d0          ADD      r1,r4,r0,LSR #31
0003b8  1049              ASRS     r1,r1,#1
0003ba  eba40141          SUB      r1,r4,r1,LSL #1
0003be  b919              CBNZ     r1,|L1.968|
;;;411    		addrbit=(1<<com);
0003c0  2001              MOVS     r0,#1
0003c2  40a8              LSLS     r0,r0,r5
0003c4  b2c6              UXTB     r6,r0
0003c6  e003              B        |L1.976|
                  |L1.968|
;;;412    	else
;;;413    		addrbit=(1<<(4+com));
0003c8  1d28              ADDS     r0,r5,#4
0003ca  2101              MOVS     r1,#1
0003cc  4081              LSLS     r1,r1,r0
0003ce  b2ce              UXTB     r6,r1
                  |L1.976|
;;;414    	tempdat=VKL144A_dispram[seg/2]|addrbit;
0003d0  4620              MOV      r0,r4
0003d2  eb0471d0          ADD      r1,r4,r0,LSR #31
0003d6  1049              ASRS     r1,r1,#1
0003d8  4a13              LDR      r2,|L1.1064|
0003da  5c51              LDRB     r1,[r2,r1]
0003dc  4331              ORRS     r1,r1,r6
0003de  9100              STR      r1,[sp,#0]
;;;415    	VKL144A_dispram[seg/2]=tempdat;
0003e0  f89d1000          LDRB     r1,[sp,#0]
0003e4  eb0472d0          ADD      r2,r4,r0,LSR #31
0003e8  1052              ASRS     r2,r2,#1
0003ea  4b0f              LDR      r3,|L1.1064|
0003ec  5499              STRB     r1,[r3,r2]
;;;416    	WritenDataVKL144A(addrbyte,&tempdat,1);		//这里送8bit数据对应2个SEG，seg/com对应的bit置1，其余7bit不改变
0003ee  2201              MOVS     r2,#1
0003f0  4669              MOV      r1,sp
0003f2  4638              MOV      r0,r7
0003f4  f7fffffe          BL       WritenDataVKL144A
;;;417    }
0003f8  bdf8              POP      {r3-r7,pc}
;;;418    /*******************************************************************************
                          ENDP

                  VKL144A_DisDotOff PROC
;;;425    *******************************************************************************/
;;;426    void VKL144A_DisDotOff(unsigned char seg,unsigned char com)
0003fa  b5f8              PUSH     {r3-r7,lr}
;;;427    {
0003fc  4604              MOV      r4,r0
0003fe  460d              MOV      r5,r1
;;;428    	unsigned char addrbyte,addrbit,tempdat;
;;;429    	
;;;430    	//计算com/seg对应的显示RAM地址和bit
;;;431    	addrbyte=seg/2*2;
000400  4620              MOV      r0,r4
000402  eb0471d0          ADD      r1,r4,r0,LSR #31
000406  1049              ASRS     r1,r1,#1
000408  0649              LSLS     r1,r1,#25
00040a  0e0f              LSRS     r7,r1,#24
;;;432    	if((seg%2)==0)
00040c  eb0471d0          ADD      r1,r4,r0,LSR #31
000410  1049              ASRS     r1,r1,#1
000412  eba40141          SUB      r1,r4,r1,LSL #1
000416  b949              CBNZ     r1,|L1.1068|
;;;433    		addrbit=(1<<com);
000418  2001              MOVS     r0,#1
00041a  40a8              LSLS     r0,r0,r5
00041c  b2c6              UXTB     r6,r0
00041e  e009              B        |L1.1076|
                  |L1.1056|
                          DCD      0x4000487c
                  |L1.1060|
                          DCD      0x40004040
                  |L1.1064|
                          DCD      VKL144A_dispram
                  |L1.1068|
;;;434    	else
;;;435    		addrbit=(1<<(4+com));
00042c  1d28              ADDS     r0,r5,#4
00042e  2101              MOVS     r1,#1
000430  4081              LSLS     r1,r1,r0
000432  b2ce              UXTB     r6,r1
                  |L1.1076|
;;;436    	tempdat=VKL144A_dispram[seg/2]&(~addrbit);
000434  4620              MOV      r0,r4
000436  eb0471d0          ADD      r1,r4,r0,LSR #31
00043a  1049              ASRS     r1,r1,#1
00043c  4a9c              LDR      r2,|L1.1712|
00043e  5c51              LDRB     r1,[r2,r1]
000440  43b1              BICS     r1,r1,r6
000442  9100              STR      r1,[sp,#0]
;;;437    	VKL144A_dispram[seg/2]=tempdat;
000444  f89d1000          LDRB     r1,[sp,#0]
000448  eb0472d0          ADD      r2,r4,r0,LSR #31
00044c  1052              ASRS     r2,r2,#1
00044e  4b98              LDR      r3,|L1.1712|
000450  5499              STRB     r1,[r3,r2]
;;;438    	WritenDataVKL144A(addrbyte,&tempdat,1);		//这里送8bit数据对应2个SEG，seg/com对应的bit清0，其余7bit不改变
000452  2201              MOVS     r2,#1
000454  4669              MOV      r1,sp
000456  4638              MOV      r0,r7
000458  f7fffffe          BL       WritenDataVKL144A
;;;439    }
00045c  bdf8              POP      {r3-r7,pc}
;;;440    /*******************************************************************************
                          ENDP

                  VKL144A_Enter_PowerOff PROC
;;;446    *******************************************************************************/
;;;447    unsigned char VKL144A_Enter_PowerOff(void)
00045e  b510              PUSH     {r4,lr}
;;;448    {		
;;;449    	VKL144A_I2CStart();
000460  f7fffffe          BL       VKL144A_I2CStart
;;;450    	VKL144A_I2CWRCmd(VKL144A_ADDRWR); 
000464  207c              MOVS     r0,#0x7c
000466  f7fffffe          BL       VKL144A_I2CWRCmd
;;;451    	if( 1 == VKL144A_I2CSlaveAck() )
00046a  f7fffffe          BL       VKL144A_I2CSlaveAck
00046e  2801              CMP      r0,#1
000470  d103              BNE      |L1.1146|
;;;452    	{
;;;453    		VKL144A_I2CStop();
000472  f7fffffe          BL       VKL144A_I2CStop
;;;454    		return 1; 
000476  2001              MOVS     r0,#1
                  |L1.1144|
;;;455    	}
;;;456    	VKL144A_I2CWRCmd(VKL144A_LCD_OFF);		//关显示
;;;457    	if( 1 == VKL144A_I2CSlaveAck() )
;;;458    	{
;;;459    		VKL144A_I2CStop();
;;;460    		return 1; 
;;;461    	}
;;;462    	VKL144A_I2CStop();
;;;463      return 0; 
;;;464    }
000478  bd10              POP      {r4,pc}
                  |L1.1146|
00047a  20c0              MOVS     r0,#0xc0              ;456
00047c  f7fffffe          BL       VKL144A_I2CWRCmd
000480  f7fffffe          BL       VKL144A_I2CSlaveAck
000484  2801              CMP      r0,#1                 ;457
000486  d103              BNE      |L1.1168|
000488  f7fffffe          BL       VKL144A_I2CStop
00048c  2001              MOVS     r0,#1                 ;460
00048e  e7f3              B        |L1.1144|
                  |L1.1168|
000490  f7fffffe          BL       VKL144A_I2CStop
000494  2000              MOVS     r0,#0                 ;463
000496  e7ef              B        |L1.1144|
;;;465    /*******************************************************************************
                          ENDP

                  VKL144A_InitSequence PROC
;;;487    *******************************************************************************/
;;;488    unsigned char VKL144A_InitSequence(void)
000498  b510              PUSH     {r4,lr}
;;;489    {			
;;;490      //上电初始化时序（参考数据手册上电复位时序图和参数）	
;;;491    	//上电100uS后初始化
;;;492      Delay_nuS(100);
00049a  2064              MOVS     r0,#0x64
00049c  f7fffffe          BL       Delay_nuS
;;;493    	//STOP信号
;;;494    	VKL144A_I2CStop();
0004a0  f7fffffe          BL       VKL144A_I2CStop
;;;495    	//START信号
;;;496    	VKL144A_I2CStart();
0004a4  f7fffffe          BL       VKL144A_I2CStart
;;;497    	//发送SLAVE地址(0x7C)
;;;498    	VKL144A_I2CWRCmd(VKL144A_ADDRWR); 
0004a8  207c              MOVS     r0,#0x7c
0004aa  f7fffffe          BL       VKL144A_I2CWRCmd
;;;499    	if( 1 == VKL144A_I2CSlaveAck() )
0004ae  f7fffffe          BL       VKL144A_I2CSlaveAck
0004b2  2801              CMP      r0,#1
0004b4  d103              BNE      |L1.1214|
;;;500    	{
;;;501    		VKL144A_I2CStop();	
0004b6  f7fffffe          BL       VKL144A_I2CStop
;;;502    		return 1;
0004ba  2001              MOVS     r0,#1
                  |L1.1212|
;;;503    	}
;;;504    	//系统设置命令(软复位)
;;;505    	VKL144A_I2CWRCmd(VKL144A_SOFTRST);
;;;506    	if( 1 == VKL144A_I2CSlaveAck() )
;;;507    	{
;;;508    		VKL144A_I2CStop();	
;;;509    		return 1;
;;;510    	}
;;;511    	//显示控制命令(设置帧频，功耗模式和驱动方式)，电流为实测样品值，仅供参考
;;;512    	//VKL144A_I2CWRCmd(VKL144A_FR80HZ|VKL144A_SRNOR|VKL144A_LINER);  	//上电默认 	VDD=5V:18.2uA  	VDD=3.3V:13uA
;;;513    	VKL144A_I2CWRCmd(VKL144A_FR53HZ|VKL144A_SRPM1|VKL144A_FRAMER);  //最省电 		VDD=5V:9.1uA  VDD=3.3V:6.8uA
;;;514    	//VKL144A_I2CWRCmd(VKL144A_FR80HZ|VKL144A_SRHP|VKL144A_LINER);  	//电流最大 			VDD=5V:20uA  	VDD=3.3V:15uA 
;;;515    	if( 1 == VKL144A_I2CSlaveAck() )
;;;516    	{
;;;517    		VKL144A_I2CStop();	
;;;518    		return 1;
;;;519    	}
;;;520      //模式设置命令
;;;521    	VKL144A_I2CWRCmd(VKL144A_BIAS_1_3|VKL144A_LCD_ON);		//1/3bias,打开显示 
;;;522    	//VKL144A_I2CWRCmd(VKL144A_BIAS_1_2|VKL144A_LCD_ON);		//1/2bias,打开显示 
;;;523    	if( 1 == VKL144A_I2CSlaveAck() )
;;;524    	{
;;;525    		VKL144A_I2CStop();	
;;;526    		return 1;
;;;527    	}
;;;528    	//STOP信号
;;;529    	VKL144A_I2CStop();	
;;;530    		
;;;531      return  0; 
;;;532    }
0004bc  bd10              POP      {r4,pc}
                  |L1.1214|
0004be  20ea              MOVS     r0,#0xea              ;505
0004c0  f7fffffe          BL       VKL144A_I2CWRCmd
0004c4  f7fffffe          BL       VKL144A_I2CSlaveAck
0004c8  2801              CMP      r0,#1                 ;506
0004ca  d103              BNE      |L1.1236|
0004cc  f7fffffe          BL       VKL144A_I2CStop
0004d0  2001              MOVS     r0,#1                 ;509
0004d2  e7f3              B        |L1.1212|
                  |L1.1236|
0004d4  20bc              MOVS     r0,#0xbc              ;513
0004d6  f7fffffe          BL       VKL144A_I2CWRCmd
0004da  f7fffffe          BL       VKL144A_I2CSlaveAck
0004de  2801              CMP      r0,#1                 ;515
0004e0  d103              BNE      |L1.1258|
0004e2  f7fffffe          BL       VKL144A_I2CStop
0004e6  2001              MOVS     r0,#1                 ;518
0004e8  e7e8              B        |L1.1212|
                  |L1.1258|
0004ea  20c8              MOVS     r0,#0xc8              ;521
0004ec  f7fffffe          BL       VKL144A_I2CWRCmd
0004f0  f7fffffe          BL       VKL144A_I2CSlaveAck
0004f4  2801              CMP      r0,#1                 ;523
0004f6  d103              BNE      |L1.1280|
0004f8  f7fffffe          BL       VKL144A_I2CStop
0004fc  2001              MOVS     r0,#1                 ;526
0004fe  e7dd              B        |L1.1212|
                  |L1.1280|
000500  f7fffffe          BL       VKL144A_I2CStop
000504  2000              MOVS     r0,#0                 ;531
000506  e7d9              B        |L1.1212|
;;;533    /*******************************************************************************
                          ENDP

                  VKL144A_Exit_PowerOff PROC
;;;471    *******************************************************************************/
;;;472    unsigned char VKL144A_Exit_PowerOff(void)
000508  b510              PUSH     {r4,lr}
;;;473    {	
;;;474    	unsigned char errorflag; 
;;;475    	
;;;476    	//退出掉电模式重新初始化时序
;;;477    	errorflag=VKL144A_InitSequence();
00050a  f7fffffe          BL       VKL144A_InitSequence
00050e  4604              MOV      r4,r0
;;;478    	
;;;479      return(errorflag);
000510  4620              MOV      r0,r4
;;;480    }
000512  bd10              POP      {r4,pc}
;;;481    /*******************************************************************************
                          ENDP

                  VKL144A_Lowlevel_Init PROC
;;;539    *******************************************************************************/
;;;540    void VKL144A_Lowlevel_Init(void)
000514  b510              PUSH     {r4,lr}
;;;541    {
;;;542    	//通信线电平不同，建议加电平转换电路
;;;543    	//此函数根据客户单片机做相应的修改	
;;;544    	GPIO_SetMode(VKL144A_SCL_PORT, VKL144A_SCL_PIN, GPIO_MODE_OUTPUT);
000516  2201              MOVS     r2,#1
000518  03d1              LSLS     r1,r2,#15
00051a  4866              LDR      r0,|L1.1716|
00051c  f7fffffe          BL       GPIO_SetMode
;;;545    	VKL144_SET_SDA_OUT();
000520  2201              MOVS     r2,#1
000522  2120              MOVS     r1,#0x20
000524  4863              LDR      r0,|L1.1716|
000526  f7fffffe          BL       GPIO_SetMode
;;;546    	
;;;547      //I2C总线空闲为高电平	
;;;548    	VKL144A_SCL_H();  
00052a  2001              MOVS     r0,#1
00052c  4962              LDR      r1,|L1.1720|
00052e  6008              STR      r0,[r1,#0]
;;;549    	VKL144A_SDA_H(); 	
000530  4961              LDR      r1,|L1.1720|
000532  3928              SUBS     r1,r1,#0x28
000534  6008              STR      r0,[r1,#0]
;;;550    }
000536  bd10              POP      {r4,pc}
;;;551    /*******************************************************************************
                          ENDP

                  VKL144A_Init PROC
;;;557    *******************************************************************************/
;;;558    void VKL144A_Init(void)
000538  b510              PUSH     {r4,lr}
;;;559    {	
;;;560    	//管脚配置根据客户单片机做相应的修改
;;;561    	VKL144A_Lowlevel_Init();
00053a  f7fffffe          BL       VKL144A_Lowlevel_Init
;;;562    	//初始化时序
;;;563    	VKL144A_InitSequence();
00053e  f7fffffe          BL       VKL144A_InitSequence
;;;564    }
000542  bd10              POP      {r4,pc}
;;;565    /*******************************************************************************
                          ENDP

                  VKL144A_Main PROC
;;;571    *******************************************************************************/
;;;572    void VKL144A_Main(void)
000544  f7fffffe          BL       VKL144A_Init
;;;573    {	
;;;574    	VKL144A_Init();
;;;575    	
;;;576    	//选择外部时钟(OSCI脚)频率为32KHz(根据实际帧频修正这个频率)
;;;577    	//WriteCmdVKL144A(VKL144A_EXTCLK); //设置显示地址时VKL144A_ADDRWR5的bit0一定要置1
;;;578    	
;;;579    	//整体闪烁命令
;;;580    	//WriteCmdVKL144A(VKL144A_BLKCTL_05HZ); //闪烁频率0.5Hz
;;;581    	//WriteCmdVKL144A(VKL144A_BLKCTL_1HZ); 	//闪烁频率1Hz
;;;582    	WriteCmdVKL144A(VKL144A_BLKCTL_2HZ); 	//闪烁频率2Hz
000548  20f3              MOVS     r0,#0xf3
00054a  f7fffffe          BL       WriteCmdVKL144A
;;;583    	//WriteCmdVKL144A(VKL144A_BLKCTL_OFF);	//闪烁关闭
;;;584    	
;;;585    	//全屏强制开命令
;;;586    	WriteCmdVKL144A(VKL144A_APCTL_ALLON2);	
00054e  20fe              MOVS     r0,#0xfe
000550  f7fffffe          BL       WriteCmdVKL144A
;;;587    	Delay_nmS(3000);					//延时
000554  f64030b8          MOV      r0,#0xbb8
000558  f7fffffe          BL       Delay_nmS
;;;588    	//全屏强制关命令
;;;589    	WriteCmdVKL144A(VKL144A_APCTL_ALLOFF1);
00055c  20fd              MOVS     r0,#0xfd
00055e  f7fffffe          BL       WriteCmdVKL144A
;;;590    	Delay_nmS(1000);					//延时
000562  f44f707a          MOV      r0,#0x3e8
000566  f7fffffe          BL       Delay_nmS
;;;591    	
;;;592    	//全屏强制取消,恢复正常
;;;593    	WriteCmdVKL144A(VKL144A_APCTL_NORMAL);
00056a  20fc              MOVS     r0,#0xfc
00056c  f7fffffe          BL       WriteCmdVKL144A
;;;594    	WriteCmdVKL144A(VKL144A_BLKCTL_OFF);	//闪烁关闭
000570  20f0              MOVS     r0,#0xf0
000572  f7fffffe          BL       WriteCmdVKL144A
;;;595    	
;;;596    	VKL144A_DisAll(0x00);
000576  2000              MOVS     r0,#0
000578  f7fffffe          BL       VKL144A_DisAll
;;;597    	while(1)
00057c  e096              B        |L1.1708|
                  |L1.1406|
;;;598    	{		
;;;599    		//LCD全显
;;;600    		VKL144A_DisAll(0xFF);			
00057e  20ff              MOVS     r0,#0xff
000580  f7fffffe          BL       VKL144A_DisAll
;;;601    		Delay_nmS(3000);					//延时
000584  f64030b8          MOV      r0,#0xbb8
000588  f7fffffe          BL       Delay_nmS
;;;602    		
;;;603    		//LCD全关
;;;604    		VKL144A_DisAll(0x00);			
00058c  2000              MOVS     r0,#0
00058e  f7fffffe          BL       VKL144A_DisAll
;;;605    		Delay_nmS(3000);					//延时
000592  f64030b8          MOV      r0,#0xbb8
000596  f7fffffe          BL       Delay_nmS
;;;606    	
;;;607    		//LCD半显
;;;608    		VKL144A_DisAll(0x55);			
00059a  2055              MOVS     r0,#0x55
00059c  f7fffffe          BL       VKL144A_DisAll
;;;609    		ReadnDataVKL144A(0,VKL144A_readbuf,18);	//读回RAM数据
0005a0  2212              MOVS     r2,#0x12
0005a2  4946              LDR      r1,|L1.1724|
0005a4  2000              MOVS     r0,#0
0005a6  f7fffffe          BL       ReadnDataVKL144A
;;;610    		Delay_nmS(1500);					//延时
0005aa  f24050dc          MOV      r0,#0x5dc
0005ae  f7fffffe          BL       Delay_nmS
;;;611    		VKL144A_DisAll(0xAA);			
0005b2  20aa              MOVS     r0,#0xaa
0005b4  f7fffffe          BL       VKL144A_DisAll
;;;612    		ReadnDataVKL144A(0,VKL144A_readbuf,18);	//读回RAM数据
0005b8  2212              MOVS     r2,#0x12
0005ba  4940              LDR      r1,|L1.1724|
0005bc  2000              MOVS     r0,#0
0005be  f7fffffe          BL       ReadnDataVKL144A
;;;613    		Delay_nmS(1500);					//延时
0005c2  f24050dc          MOV      r0,#0x5dc
0005c6  f7fffffe          BL       Delay_nmS
;;;614    		
;;;615    		//掉电
;;;616    		VKL144A_DisAll(0x00);			//LCD全关		
0005ca  2000              MOVS     r0,#0
0005cc  f7fffffe          BL       VKL144A_DisAll
;;;617    		VKL144A_Enter_PowerOff();	//进入掉电模式
0005d0  f7fffffe          BL       VKL144A_Enter_PowerOff
;;;618    		Delay_nmS(5000);					//延时5S		
0005d4  f2413088          MOV      r0,#0x1388
0005d8  f7fffffe          BL       Delay_nmS
;;;619    		VKL144A_Exit_PowerOff();	//退出掉电模式
0005dc  f7fffffe          BL       VKL144A_Exit_PowerOff
;;;620    				
;;;621    		//LCD单点点亮
;;;622    		VKL144A_DisAll(0x00);			//LCD全关
0005e0  2000              MOVS     r0,#0
0005e2  f7fffffe          BL       VKL144A_DisAll
;;;623    		Delay_nmS(500);						//延时
0005e6  f44f70fa          MOV      r0,#0x1f4
0005ea  f7fffffe          BL       Delay_nmS
;;;624    		for(VKL144A_segi=0;VKL144A_segi<36;VKL144A_segi++)//seg0-35
0005ee  2000              MOVS     r0,#0
0005f0  4933              LDR      r1,|L1.1728|
0005f2  7008              STRB     r0,[r1,#0]
0005f4  e021              B        |L1.1594|
                  |L1.1526|
;;;625    		{
;;;626    			for(VKL144A_comi=0;VKL144A_comi<4;VKL144A_comi++)//com0-3
0005f6  2000              MOVS     r0,#0
0005f8  4932              LDR      r1,|L1.1732|
0005fa  7008              STRB     r0,[r1,#0]
0005fc  e014              B        |L1.1576|
                  |L1.1534|
;;;627    			{
;;;628    				VKL144A_DisDotOn(VKL144A_segi,VKL144A_comi);		//LCD单点点亮
0005fe  4831              LDR      r0,|L1.1732|
000600  7801              LDRB     r1,[r0,#0]  ; VKL144A_comi
000602  482f              LDR      r0,|L1.1728|
000604  7800              LDRB     r0,[r0,#0]  ; VKL144A_segi
000606  f7fffffe          BL       VKL144A_DisDotOn
;;;629    				Delay_nmS(300);				//延时
00060a  f44f7096          MOV      r0,#0x12c
00060e  f7fffffe          BL       Delay_nmS
;;;630    				VKL144A_DisDotOff(VKL144A_segi,VKL144A_comi);		//此行配合单点点亮函数实现单点点亮，屏蔽此行顺序点亮
000612  482c              LDR      r0,|L1.1732|
000614  7801              LDRB     r1,[r0,#0]  ; VKL144A_comi
000616  482a              LDR      r0,|L1.1728|
000618  7800              LDRB     r0,[r0,#0]  ; VKL144A_segi
00061a  f7fffffe          BL       VKL144A_DisDotOff
00061e  4829              LDR      r0,|L1.1732|
000620  7800              LDRB     r0,[r0,#0]            ;626  ; VKL144A_comi
000622  1c40              ADDS     r0,r0,#1              ;626
000624  4927              LDR      r1,|L1.1732|
000626  7008              STRB     r0,[r1,#0]            ;626
                  |L1.1576|
000628  4826              LDR      r0,|L1.1732|
00062a  7800              LDRB     r0,[r0,#0]            ;626  ; VKL144A_comi
00062c  2804              CMP      r0,#4                 ;626
00062e  dbe6              BLT      |L1.1534|
000630  4823              LDR      r0,|L1.1728|
000632  7800              LDRB     r0,[r0,#0]            ;624  ; VKL144A_segi
000634  1c40              ADDS     r0,r0,#1              ;624
000636  4922              LDR      r1,|L1.1728|
000638  7008              STRB     r0,[r1,#0]            ;624
                  |L1.1594|
00063a  4821              LDR      r0,|L1.1728|
00063c  7800              LDRB     r0,[r0,#0]            ;624  ; VKL144A_segi
00063e  2824              CMP      r0,#0x24              ;624
000640  dbd9              BLT      |L1.1526|
;;;631    			}
;;;632    		}
;;;633    		
;;;634    		//LCD单点关闭
;;;635    		VKL144A_DisAll(0xff);			//LCD全显
000642  20ff              MOVS     r0,#0xff
000644  f7fffffe          BL       VKL144A_DisAll
;;;636    		Delay_nmS(500);						//延时
000648  f44f70fa          MOV      r0,#0x1f4
00064c  f7fffffe          BL       Delay_nmS
;;;637    		for(VKL144A_segi=0;VKL144A_segi<36;VKL144A_segi++)//seg0-35
000650  2000              MOVS     r0,#0
000652  491b              LDR      r1,|L1.1728|
000654  7008              STRB     r0,[r1,#0]
000656  e021              B        |L1.1692|
                  |L1.1624|
;;;638    		{
;;;639    			for(VKL144A_comi=0;VKL144A_comi<4;VKL144A_comi++)//com0-3
000658  2000              MOVS     r0,#0
00065a  491a              LDR      r1,|L1.1732|
00065c  7008              STRB     r0,[r1,#0]
00065e  e014              B        |L1.1674|
                  |L1.1632|
;;;640    			{
;;;641    				VKL144A_DisDotOff(VKL144A_segi,VKL144A_comi);		//LCD单点关闭
000660  4818              LDR      r0,|L1.1732|
000662  7801              LDRB     r1,[r0,#0]  ; VKL144A_comi
000664  4816              LDR      r0,|L1.1728|
000666  7800              LDRB     r0,[r0,#0]  ; VKL144A_segi
000668  f7fffffe          BL       VKL144A_DisDotOff
;;;642    				Delay_nmS(300);				//延时
00066c  f44f7096          MOV      r0,#0x12c
000670  f7fffffe          BL       Delay_nmS
;;;643    				VKL144A_DisDotOn(VKL144A_segi,VKL144A_comi);		//此行配合单点关闭函数实现单点关闭，屏蔽此行顺序关闭
000674  4813              LDR      r0,|L1.1732|
000676  7801              LDRB     r1,[r0,#0]  ; VKL144A_comi
000678  4811              LDR      r0,|L1.1728|
00067a  7800              LDRB     r0,[r0,#0]  ; VKL144A_segi
00067c  f7fffffe          BL       VKL144A_DisDotOn
000680  4810              LDR      r0,|L1.1732|
000682  7800              LDRB     r0,[r0,#0]            ;639  ; VKL144A_comi
000684  1c40              ADDS     r0,r0,#1              ;639
000686  490f              LDR      r1,|L1.1732|
000688  7008              STRB     r0,[r1,#0]            ;639
                  |L1.1674|
00068a  480e              LDR      r0,|L1.1732|
00068c  7800              LDRB     r0,[r0,#0]            ;639  ; VKL144A_comi
00068e  2804              CMP      r0,#4                 ;639
000690  dbe6              BLT      |L1.1632|
000692  480b              LDR      r0,|L1.1728|
000694  7800              LDRB     r0,[r0,#0]            ;637  ; VKL144A_segi
000696  1c40              ADDS     r0,r0,#1              ;637
000698  4909              LDR      r1,|L1.1728|
00069a  7008              STRB     r0,[r1,#0]            ;637
                  |L1.1692|
00069c  4808              LDR      r0,|L1.1728|
00069e  7800              LDRB     r0,[r0,#0]            ;637  ; VKL144A_segi
0006a0  2824              CMP      r0,#0x24              ;637
0006a2  dbd9              BLT      |L1.1624|
;;;644    			}
;;;645    		}		
;;;646    		Delay_nmS(1000);					//延时
0006a4  f44f707a          MOV      r0,#0x3e8
0006a8  f7fffffe          BL       Delay_nmS
                  |L1.1708|
0006ac  e767              B        |L1.1406|
;;;647    	}
;;;648    }
;;;649    /************************END OF FILE****/
                          ENDP

0006ae  0000              DCW      0x0000
                  |L1.1712|
                          DCD      VKL144A_dispram
                  |L1.1716|
                          DCD      0x40004040
                  |L1.1720|
                          DCD      0x4000487c
                  |L1.1724|
                          DCD      VKL144A_readbuf
                  |L1.1728|
                          DCD      VKL144A_segi
                  |L1.1732|
                          DCD      VKL144A_comi

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  VKL144A_dispram
                          %        18
                  VKL144A_readbuf
                          %        18

                          AREA ||.data||, DATA, ALIGN=0

                  VKL144A_segi
000000  00                DCB      0x00
                  VKL144A_comi
000001  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\lcd_driver\\VKL144A_IO_I2C_DIR.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_VKL144A_IO_I2C_DIR_c_f70de489____REV16|
#line 114 "..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___20_VKL144A_IO_I2C_DIR_c_f70de489____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_VKL144A_IO_I2C_DIR_c_f70de489____REVSH|
#line 128
|__asm___20_VKL144A_IO_I2C_DIR_c_f70de489____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
